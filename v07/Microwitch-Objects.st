ArgMorph subclass: #LedArgMorph	instanceVariableNames: 'image '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Objects'!!LedArgMorph methodsFor: 'event handling' stamp: 'EiichiroIto 6/29/2018 08:45'!handlesMouseDown: evt	^ evt hand toolType isNil! !!LedArgMorph methodsFor: 'event handling'!mouseUp: evt 	self showLedEditorAt: evt cursorPoint.! !!LedArgMorph methodsFor: 'private'!showLedEditorAt: aPoint 	| morph ret |	World submorphs do: [:m | (m isKindOf: MicrobitLedEditorMorph)			ifTrue: [m delete]].	morph := MicrobitLedEditorMorph new.	morph image: self image.	morph position: aPoint.	ret := morph getUserResponse.	ret ifFalse: [^ self].	self image: morph image! !!LedArgMorph methodsFor: 'private'!valueAt: aPoint 	| index v |	index := aPoint y * (MicrobitLed columns + 1) + aPoint x + 1.	index > image size ifTrue: [^ 0].	v := image at: index.	^ v asciiValue - $0 asciiValue! !!LedArgMorph methodsFor: 'initialization'!initialize	super initialize.	self extent: 14 @ 14.	self color: Color white.	image := '00000:00000:00900:00000:00000:'.! !!LedArgMorph methodsFor: 'accessing' stamp: 'EiichiroIto 6/29/2018 17:15'!argString: aGenerator	^ aGenerator imageString: self! !!LedArgMorph methodsFor: 'accessing'!defaultValue: anObject	self image: anObject! !!LedArgMorph methodsFor: 'accessing'!evaluate	^ image! !!LedArgMorph methodsFor: 'accessing'!image	^ image! !!LedArgMorph methodsFor: 'accessing'!image: aString	image := aString.	self changed.! !!LedArgMorph methodsFor: 'drawing'!drawOn: aCanvas 	| w h x y r |	super drawOn: aCanvas.	w := 2.	h := 2.	x := self left + 2.	1 to: MicrobitLed columns do: 		[:xx | 		y := self top + 2.		1 to: MicrobitLed lines do: 			[:yy | 			(self valueAt: (xx - 1) @ (yy - 1))				> 0				ifTrue: 					[r := x @ y extent: 2 @ 2.					aCanvas fillRectangle: r color: Color red].			y := y + h].		x := x + w]! !Morph subclass: #LedEditorButtonMorph	instanceVariableNames: 'value forIntensity '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Objects'!!LedEditorButtonMorph methodsFor: 'event handling' stamp: 'EiichiroIto 6/28/2018 20:19'!handlesMouseDown: evt	^ true! !!LedEditorButtonMorph methodsFor: 'event handling'!mouseDown: evt 	| v |	forIntensity		ifTrue: 			[owner intensity: value.			owner marker position: self position + (0@12)]		ifFalse: 			[v := owner intensity.			self value = v ifTrue: [v := 0].			self value: v]! !!LedEditorButtonMorph methodsFor: 'private'!changeColor	self color: (Color			r: value * 0.11			g: 0.0			b: 0.0)! !!LedEditorButtonMorph methodsFor: 'initialization'!initialize	super initialize.	self value: 0.	forIntensity := false.! !!LedEditorButtonMorph methodsFor: 'accessing' stamp: 'EiichiroIto 7/15/2018 18:39'!intensity	^ value! !!LedEditorButtonMorph methodsFor: 'accessing'!intensity: anInteger	(anInteger < 0 or: [anInteger > 9])		ifTrue: [^ self].	forIntensity := true.	value := anInteger.	self changeColor.! !!LedEditorButtonMorph methodsFor: 'accessing' stamp: 'EiichiroIto 6/28/2018 20:21'!value	^ value! !!LedEditorButtonMorph methodsFor: 'accessing'!value: anInteger 	(anInteger < 0 or: [anInteger > 9])		ifTrue: [^ self].	forIntensity := false.	value := anInteger.	self changeColor.! !Object subclass: #MicrobitButton	instanceVariableNames: 'count on '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Objects'!!MicrobitButton methodsFor: 'initialize' stamp: 'EiichiroIto 6/27/2018 19:00'!initialize	super initialize.	on := false.	count := 0.! !!MicrobitButton methodsFor: 'accessing' stamp: 'EiichiroIto 6/19/2018 18:48'!count	^ count! !!MicrobitButton methodsFor: 'accessing' stamp: 'EiichiroIto 6/27/2018 19:00'!on	count := 0.	^ on! !!MicrobitButton methodsFor: 'accessing' stamp: 'EiichiroIto 6/27/2018 19:00'!on: aBoolean 	(on not and: [aBoolean])		ifTrue: [count := count + 1].	on := aBoolean! !!MicrobitButton methodsFor: 'accessing' stamp: 'EiichiroIto 6/19/2018 17:48'!reset	count := 0.! !!MicrobitButton methodsFor: 'private' stamp: 'EiichiroIto 6/20/2018 13:55'!privCount	^ count! !!MicrobitButton methodsFor: 'private' stamp: 'EiichiroIto 6/20/2018 14:18'!privCount: anInteger	count := anInteger.! !!MicrobitButton methodsFor: 'private' stamp: 'EiichiroIto 6/20/2018 13:55'!privOn	^ on! !!MicrobitButton methodsFor: 'private' stamp: 'EiichiroIto 6/20/2018 14:18'!privOn: aBoolean	on := aBoolean.! !!MicrobitButton methodsFor: 'printing' stamp: 'EiichiroIto 6/20/2018 07:32'!printOn: aStream 	aStream nextPutAll: 'Button('.	aStream nextPutAll: (on			ifTrue: ['on']			ifFalse: ['off']).	aStream nextPut: $,.	aStream nextPutAll: count asString.	aStream nextPut: $).! !Morph subclass: #MicrobitButtonMorph	instanceVariableNames: 'target '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Objects'!!MicrobitButtonMorph methodsFor: 'accessing' stamp: 'EiichiroIto 6/19/2018 21:42'!target: anObject	target := anObject.! !!MicrobitButtonMorph methodsFor: 'event handling' stamp: 'EiichiroIto 6/19/2018 21:42'!handlesMouseDown: evt	^ true! !!MicrobitButtonMorph methodsFor: 'event handling'!mouseDown: anEvent 	target ifNil: [^ self].	target on: true.	self color: Color cyan! !!MicrobitButtonMorph methodsFor: 'event handling'!mouseUp: anEvent 	target ifNil: [^ self].	target on: false.	self color: Color blue! !!MicrobitButtonMorph methodsFor: 'object i/o' stamp: 'EiichiroIto 6/20/2018 20:44'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		target	) from: anObjStream.! !!MicrobitButtonMorph methodsFor: 'object i/o' stamp: 'EiichiroIto 6/20/2018 20:44'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		target	) on: anObjStream.! !!MicrobitButtonMorph methodsFor: 'initialization' stamp: 'EiichiroIto 6/21/2018 16:33'!initialize	super initialize.	self color: Color blue.! !Object subclass: #MicrobitIOPin	instanceVariableNames: 'direction mode status '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Objects'!!MicrobitIOPin methodsFor: 'accessing' stamp: 'EiichiroIto 6/20/2018 13:52'!mode	^ mode! !!MicrobitIOPin methodsFor: 'accessing' stamp: 'EiichiroIto 6/20/2018 13:53'!mode: aSymbol	mode := aSymbol.! !!MicrobitIOPin methodsFor: 'accessing' stamp: 'EiichiroIto 6/20/2018 13:53'!status	^ status! !!MicrobitIOPin methodsFor: 'accessing' stamp: 'EiichiroIto 6/20/2018 13:53'!status: aSymbol	status := aSymbol.! !Object subclass: #MicrobitImage	instanceVariableNames: 'matrix '	classVariableNames: 'CharDict SymbolDict '	poolDictionaries: ''	category: 'Microwitch-Objects'!!MicrobitImage methodsFor: 'private' stamp: 'EiichiroIto 7/9/2018 10:25'!blitFrom: otherImage x: srcX y: srcY w: w h: h dstX: dstX dstY: dstY 	0 to: w - 1 do: [:dx |		0 to: h - 1 do: [:dy |			self				x: dstX + dx				y: dstY + dy				v: (otherImage x: srcX + dx y: srcY + dy)]]! !!MicrobitImage methodsFor: 'private'!clearMatrixAtColumns: columns lines: lines	matrix := self newMatrixAtColumns: columns lines: lines value: 0.! !!MicrobitImage methodsFor: 'private' stamp: 'EiichiroIto 7/21/2018 08:31'!newColumnAtLines: anInteger value: value	^ Array new: anInteger withAll: value! !!MicrobitImage methodsFor: 'private' stamp: 'EiichiroIto 7/21/2018 08:31'!newMatrixAtColumns: columns lines: lines value: value	^ (1 to: columns)		collect: [:each | self newColumnAtLines: lines value: value]! !!MicrobitImage methodsFor: 'private' stamp: 'EiichiroIto 7/12/2018 21:45'!privMatrix	^ matrix! !!MicrobitImage methodsFor: 'private' stamp: 'EiichiroIto 7/12/2018 21:45'!privMatrix: anArray	matrix := anArray.! !!MicrobitImage methodsFor: 'private'!shiftDownBy: anInteger 	| newLines |	anInteger = 0 ifTrue: [^ self].	anInteger < 0 ifTrue: [^ self shiftUpBy: anInteger negated].	anInteger >= self lines ifTrue: [^ self clearMatrixAtColumns: self columns lines: self lines].	1 to: self columns do: 		[:each | 		newLines := Array new: anInteger withAll: 0.		matrix at: each put: newLines , ((matrix at: each)					copyFrom: 1 to: self lines - anInteger)]! !!MicrobitImage methodsFor: 'private'!shiftLeftBy: anInteger 	| newColumns |	anInteger = 0 ifTrue: [^ self].	anInteger < 0 ifTrue: [^ self shiftRightBy: anInteger negated].	anInteger >= self columns ifTrue: [^ self clearMatrixAtColumns: self columns lines: self lines].	newColumns := (1 to: anInteger)				collect: [:each | self newColumnAtLines: self lines value: 0].	matrix := (matrix copyFrom: anInteger + 1 to: self columns)				, newColumns! !!MicrobitImage methodsFor: 'private'!shiftRightBy: anInteger 	| newColumns |	anInteger = 0 ifTrue: [^ self].	anInteger < 0 ifTrue: [^ self shiftLeftBy: anInteger negated].	anInteger >= self columns ifTrue: [^ self clearMatrixAtColumns: self columns lines: self lines].	newColumns := (1 to: anInteger)				collect: [:each | self newColumnAtLines: self lines value: 0].	matrix := newColumns				, (matrix copyFrom: 1 to: self columns - anInteger).! !!MicrobitImage methodsFor: 'private'!shiftUpBy: anInteger 	| newLines |	anInteger = 0 ifTrue: [^ self].	anInteger < 0 ifTrue: [^ self shiftDownBy: anInteger negated].	anInteger >= self lines ifTrue: [^ self clearMatrixAtColumns: self columns lines: self lines].	1 to: self columns do: 		[:each | 		newLines := Array new: anInteger withAll: 0.		matrix at: each put: ((matrix at: each)				copyFrom: anInteger + 1 to: self lines)				, newLines]! !!MicrobitImage methodsFor: 'accessing' stamp: 'EiichiroIto 7/2/2018 21:11'!animateOn: aLed atInterval: anInteger	aLed animateImages: (Array with: self) interval: anInteger.! !!MicrobitImage methodsFor: 'accessing' stamp: 'EiichiroIto 7/2/2018 20:19'!asArray	^ matrix copy! !!MicrobitImage methodsFor: 'accessing'!asString	| stream v |	stream := WriteStream on: ''.	1 to: self lines do: 		[:y | 		1 to: self columns do: 			[:x | 			v := self x: x y: y.			stream nextPutAll: v asString].		stream nextPut: $:].	^ stream contents! !!MicrobitImage methodsFor: 'accessing' stamp: 'EiichiroIto 7/7/2018 09:43'!columns	^ matrix size! !!MicrobitImage methodsFor: 'accessing' stamp: 'EiichiroIto 7/21/2018 08:41'!copy	^ self class fromString: self asString! !!MicrobitImage methodsFor: 'accessing'!cropX: x y: y w: w h: h 	| newMatrix sx sy dx dy cw ch x1 x2 |	cw := (x + w - 1 min: self columns) - x + 1.	ch := (y + h - 1 min: self lines) - y + 1.	sx := x.	sy := y.	dx := dy := 1.	x < 1		ifTrue: 			[sx := 1.			dx := 2 - x.			cw := cw + x - 1].	y < 1		ifTrue: 			[sy := 1.			dy := 2 - y.			ch := ch + y - 1].	newMatrix := self class columns: w lines: h.	(sx > self columns or: [sy > self lines])		ifTrue: [^ newMatrix].	(dx > w or: [dy > h])		ifTrue: [^ newMatrix].	(cw < 1 or: [ch < 1])		ifTrue: [^ newMatrix].	ch		timesRepeat: 			[x1 := sx.			x2 := dx.			cw				timesRepeat: 					[newMatrix						x: x2						y: dy						v: (self x: x1 y: sy).					x1 := x1 + 1.					x2 := x2 + 1].			sy := sy + 1.			dy := dy + 1].	^ newMatrix! !!MicrobitImage methodsFor: 'accessing' stamp: 'EiichiroIto 7/21/2018 08:34'!fillWith: value	matrix := self newMatrixAtColumns: self columns lines: self lines value: value.! !!MicrobitImage methodsFor: 'accessing'!fromColumns: anArray	matrix := anArray deepCopy.! !!MicrobitImage methodsFor: 'accessing' stamp: 'EiichiroIto 7/2/2018 17:48'!fromString: aString	| stream c x y |	stream := ReadStream on: aString.	x := 1.	y := 1.	[stream atEnd]		whileFalse: 			[c := stream next.			c = $:				ifTrue: 					[y := y + 1.					x := 1].			(c between: $0 and: $9)				ifTrue: [self x: x y: y v: c asciiValue - $0 asciiValue.						x := x + 1]]! !!MicrobitImage methodsFor: 'accessing' stamp: 'EiichiroIto 7/21/2018 10:28'!invert	matrix do: [:each | (1 to: self lines)			do: [:v | each at: v put: 9 - (each at: v)]]! !!MicrobitImage methodsFor: 'accessing'!lines	^ matrix first size! !!MicrobitImage methodsFor: 'accessing'!shift: aSymbol by: anInteger	aSymbol = #left ifTrue: [^ self shiftLeftBy: anInteger].	aSymbol = #right ifTrue: [^ self shiftRightBy: anInteger].	aSymbol = #up ifTrue: [^ self shiftUpBy: anInteger].	aSymbol = #down ifTrue: [^ self shiftDownBy: anInteger].! !!MicrobitImage methodsFor: 'accessing'!x: x y: y	(x between: 1 and: self columns)		ifFalse: [^ 0].	(y between: 1 and: self lines)		ifFalse: [^ 0].	^ (matrix at: x) at: y! !!MicrobitImage methodsFor: 'accessing'!x: x y: y v: v 	(x between: 1 and: self columns)		ifFalse: [^ 0].	(y between: 1 and: self lines)		ifFalse: [^ 0].	(v between: 0 and: 9)		ifFalse: [^ self].	(matrix at: x)		at: y put: v! !!MicrobitImage methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self asString.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MicrobitImage class	instanceVariableNames: ''!!MicrobitImage class methodsFor: 'private' stamp: 'EiichiroIto 7/7/2018 10:12'!dimensionOfString: aString	| tmp columns lines |	tmp := aString findTokens: ':'.	lines := tmp size.	columns := tmp first size.	^ Array with: columns with: lines! !!MicrobitImage class methodsFor: 'instance creation'!charAt: aCharacter	^ self fromFixedString: (CharDict at: ('char_', aCharacter asString) asSymbol)! !!MicrobitImage class methodsFor: 'instance creation'!columns: columns lines: lines	^ self basicNew clearMatrixAtColumns: columns lines: lines! !!MicrobitImage class methodsFor: 'instance creation' stamp: 'EiichiroIto 7/7/2018 10:23'!fromColumns: anArray	^ self basicNew fromColumns: anArray! !!MicrobitImage class methodsFor: 'instance creation' stamp: 'EiichiroIto 7/7/2018 10:02'!fromFixedString: aString	| obj |	obj := self columns: 5 lines: 5.	^ obj fromString: aString! !!MicrobitImage class methodsFor: 'instance creation'!fromString: aString 	| dimension obj |	dimension := self dimensionOfString: aString.	obj := self columns: (dimension at: 1)				lines: (dimension at: 2).	^ obj fromString: aString! !!MicrobitImage class methodsFor: 'instance creation' stamp: 'EiichiroIto 7/7/2018 09:41'!new	self shouldNotImplement! !!MicrobitImage class methodsFor: 'instance creation'!symbolAt: aSymbol	^ self fromFixedString: (SymbolDict at: aSymbol)! !!MicrobitImage class methodsFor: 'initialization' stamp: 'EiichiroIto 7/2/2018 20:00'!initialize	"MicrobitImage initialize."	self initializeSymbolDict.	self initializeCharDict! !!MicrobitImage class methodsFor: 'initialization' stamp: 'EiichiroIto 7/2/2018 20:00'!initializeCharDict	"MicrobitImage initializeCharDict."	CharDict := Dictionary new.	CharDict at: #'char_a' put: '00000:09990:90090:90090:09999:'.	CharDict at: #'char_b' put: '90000:90000:99900:90090:99900:'.	CharDict at: #'char_c' put: '00000:09990:90000:90000:09990:'.	CharDict at: #'char_d' put: '00090:00090:09990:90090:09990:'.	CharDict at: #'char_e' put: '09900:90090:99900:90000:09990:'.	CharDict at: #'char_f' put: '00990:09000:99900:09000:09000:'.	CharDict at: #'char_g' put: '09990:90090:09990:00090:09900:'.	CharDict at: #'char_h' put: '90000:90000:99900:90090:90090:'.	CharDict at: #'char_i' put: '09000:00000:09000:09000:09000:'.	CharDict at: #'char_j' put: '00090:00000:00090:00090:09900:'.	CharDict at: #'char_k' put: '90000:90900:99000:90900:90090:'.	CharDict at: #'char_l' put: '09000:09000:09000:09000:00990:'.	CharDict at: #'char_m' put: '00000:99099:90909:90009:90009:'.	CharDict at: #'char_n' put: '00000:99900:90090:90090:90090:'.	CharDict at: #'char_o' put: '00000:09900:90090:90090:09900:'.	CharDict at: #'char_p' put: '00000:99900:90090:99900:90000:'.	CharDict at: #'char_q' put: '00000:09990:90090:09990:00090:'.	CharDict at: #'char_r' put: '00000:09990:90000:90000:90000:'.	CharDict at: #'char_s' put: '00000:00990:09000:00900:99000:'.	CharDict at: #'char_t' put: '09000:09000:09990:09000:00999:'.	CharDict at: #'char_u' put: '00000:90090:90090:90090:09999:'.	CharDict at: #'char_v' put: '00000:90009:90009:09090:00900:'.	CharDict at: #'char_w' put: '00000:90009:90009:90909:99099:'.	CharDict at: #'char_x' put: '00000:90090:09900:09900:90090:'.	CharDict at: #'char_y' put: '00000:90009:09090:00900:99000:'.	CharDict at: #'char_z' put: '00000:99990:00900:09000:99990:'.	CharDict at: #'char_A' put: '09900:90090:99990:90090:90090:'.	CharDict at: #'char_B' put: '99900:90090:99900:90090:99900:'.	CharDict at: #'char_C' put: '09990:90000:90000:90000:09990:'.	CharDict at: #'char_D' put: '99900:90090:90090:90090:99900:'.	CharDict at: #'char_E' put: '99990:90000:99900:90000:99990:'.	CharDict at: #'char_F' put: '99990:90000:99900:90000:90000:'.	CharDict at: #'char_G' put: '09990:90000:90099:90009:09990:'.	CharDict at: #'char_H' put: '90090:90090:99990:90090:90090:'.	CharDict at: #'char_I' put: '99900:09000:09000:09000:99900:'.	CharDict at: #'char_J' put: '99999:00090:00090:90090:09900:'.	CharDict at: #'char_K' put: '90090:90900:99000:90900:90090:'.	CharDict at: #'char_L' put: '90000:90000:90000:90000:99990:'.	CharDict at: #'char_M' put: '90009:99099:90909:90009:90009:'.	CharDict at: #'char_N' put: '90009:99009:90909:90099:90009:'.	CharDict at: #'char_O' put: '09900:90090:90090:90090:09900:'.	CharDict at: #'char_P' put: '99900:90090:99900:90000:90000:'.	CharDict at: #'char_Q' put: '09900:90090:90090:09900:00990:'.	CharDict at: #'char_R' put: '99900:90090:99900:90090:90009:'.	CharDict at: #'char_S' put: '09990:90000:09900:00090:99900:'.	CharDict at: #'char_T' put: '99999:00900:00900:00900:00900:'.	CharDict at: #'char_U' put: '90090:90090:90090:90090:09900:'.	CharDict at: #'char_V' put: '90009:90009:90009:09090:00900:'.	CharDict at: #'char_W' put: '90009:90009:90909:99099:90009:'.	CharDict at: #'char_X' put: '90090:90090:09900:90090:90090:'.	CharDict at: #'char_Y' put: '90009:09090:00900:00900:00900:'.	CharDict at: #'char_Z' put: '99990:00900:09000:90000:99990:'.	CharDict at: #'char_0' put: '09900:90090:90090:90090:09900:'.	CharDict at: #'char_1' put: '00900:09900:00900:00900:09990:'.	CharDict at: #'char_2' put: '99900:00090:09900:90000:99990:'.	CharDict at: #'char_3' put: '99990:00090:00900:90090:09900:'.	CharDict at: #'char_4' put: '00990:09090:90090:99999:00090:'.	CharDict at: #'char_5' put: '99999:90000:99990:00009:99990:'.	CharDict at: #'char_6' put: '00090:00900:09990:90009:09990:'.	CharDict at: #'char_7' put: '99999:00090:00900:09000:90000:'.	CharDict at: #'char_8' put: '09990:90009:09990:90009:09990:'.	CharDict at: #'char_9' put: '09990:90009:09990:00900:09000:'.	CharDict at: #'char_!!' put: '09000:09000:09000:00000:09000:'.	CharDict at: #'char_"' put: '09090:09090:00000:00000:00000:'.	CharDict at: #'char_#' put: '09090:99999:09090:99999:09090:'.	CharDict at: #'char_$' put: '09990:99009:09990:90099:09990:'.	CharDict at: #'char_%' put: '99009:90090:00900:09009:90099:'.	CharDict at: #'char_&' put: '09900:90090:09900:90090:09909:'.	CharDict at: #'char_;' put: '00000:00900:00000:00900:09000:'.	CharDict at: #'char_(' put: '00900:09000:09000:09000:00900:'.	CharDict at: #'char_)' put: '09000:00900:00900:00900:09000:'.	CharDict at: #'char_*' put: '00000:09090:00900:09090:00000:'.	CharDict at: #'char_+' put: '00000:00900:09990:00900:00000:'.	CharDict at: #'char_,' put: '00000:00000:00000:00900:09000:'.	CharDict at: #'char_-' put: '00000:00000:09990:00000:00000:'.	CharDict at: #'char_.' put: '00000:00000:00000:09000:00000:'.	CharDict at: #'char_/' put: '00009:00090:00900:09000:90000:'.	CharDict at: #'char_:' put: '00000:09000:00000:09000:00000:'.	CharDict at: #'char_<' put: '00090:00900:09000:00900:00090:'.	CharDict at: #'char_=' put: '00000:09990:00000:09990:00000:'.	CharDict at: #'char_>' put: '09000:00900:00090:00900:09000:'.	CharDict at: #'char_?' put: '09990:90009:00990:00000:00900:'.	CharDict at: #'char_^' put: '00900:09090:00000:00000:00000:'.	CharDict at: #'char__' put: '00000:00000:00000:00000:99999:'.	CharDict at: #'char_`' put: '09000:00900:00000:00000:00000:'.	CharDict at: #'char_~' put: '00000:00000:09900:00099:00000:'.	CharDict at: #'char_\' put: '90000:09000:00900:00090:00009:'.	CharDict at: #'char_|' put: '09000:09000:09000:09000:09000:'.	CharDict at: #'char_''' put: '09000:09000:00000:00000:00000:'.	CharDict at: #'char_ ' put: '00000:00000:00000:00000:00000:'.! !!MicrobitImage class methodsFor: 'initialization' stamp: 'EiichiroIto 7/2/2018 20:01'!initializeSymbolDict	"MicrobitImage initializeSymbolDict."	SymbolDict := Dictionary new.	SymbolDict at: #heart put: '09090:99999:99999:09990:00900:'.	SymbolDict at: #heartSmall put: '00000:09090:09990:00900:00000:'.	SymbolDict at: #happy put: '00000:09090:00000:90009:09990:'.	SymbolDict at: #smile put: '00000:00000:00000:90009:09990:'.	SymbolDict at: #sad put: '00000:09090:00000:09990:90009:'.	SymbolDict at: #confused put: '00000:09090:00000:09090:90909:'.	SymbolDict at: #angry put: '90009:09090:00000:99999:90909:'.	SymbolDict at: #asleep put: '00000:99099:00000:09990:00000:'.	SymbolDict at: #surprised put: '09090:00000:00900:09090:00900:'.	SymbolDict at: #silly put: '90009:00000:99999:00909:00999:'.	SymbolDict at: #fabulous put: '99999:99099:00000:09090:09990:'.	SymbolDict at: #meh put: '09090:00000:00090:00900:09000:'.	SymbolDict at: #yes put: '00000:00009:00090:90900:09000:'.	SymbolDict at: #no put: '90009:09090:00900:09090:90009:'.	SymbolDict at: #clock12 put: '00900:00900:00900:00000:00000:'.	SymbolDict at: #clock11 put: '09000:09000:00900:00000:00000:'.	SymbolDict at: #clock10 put: '00000:99000:00900:00000:00000:'.	SymbolDict at: #clock9 put: '00000:00000:99900:00000:00000:'.	SymbolDict at: #clock8 put: '00000:00000:00900:99000:00000:'.	SymbolDict at: #clock7 put: '00000:00000:00900:09000:09000:'.	SymbolDict at: #clock6 put: '00000:00000:00900:00900:00900:'.	SymbolDict at: #clock5 put: '00000:00000:00900:00090:00090:'.	SymbolDict at: #clock4 put: '00000:00000:00900:00099:00000:'.	SymbolDict at: #clock3 put: '00000:00000:00999:00000:00000:'.	SymbolDict at: #clock2 put: '00000:00099:00900:00000:00000:'.	SymbolDict at: #clock1 put: '00090:00090:00900:00000:00000:'.	SymbolDict at: #arrowN put: '00900:09990:90909:00900:00900:'.	SymbolDict at: #arrowNE put: '00999:00099:00909:09000:90000:'.	SymbolDict at: #arrowE put: '00900:00090:99999:00090:00900:'.	SymbolDict at: #arrowSE put: '90000:09000:00909:00099:00999:'.	SymbolDict at: #arrowS put: '00900:00900:90909:09990:00900:'.	SymbolDict at: #arrowSW put: '00009:00090:90900:99000:99900:'.	SymbolDict at: #arrowW put: '00900:09000:99999:09000:00900:'.	SymbolDict at: #arrowNW put: '99900:99000:90900:00090:00009:'.	SymbolDict at: #triangle put: '00000:00900:09090:99999:00000:'.	SymbolDict at: #triangleLeft put: '90000:99000:90900:90090:99999:'.	SymbolDict at: #chessboard put: '09090:90909:09090:90909:09090:'.	SymbolDict at: #diamond put: '00900:09090:90009:09090:00900:'.	SymbolDict at: #diamondSmall put: '00000:00900:09090:00900:00000:'.	SymbolDict at: #square put: '99999:90009:90009:90009:99999:'.	SymbolDict at: #squareSmall put: '00000:09990:09090:09990:00000:'.	SymbolDict at: #rabbit put: '90900:90900:99990:99090:99990:'.	SymbolDict at: #cow put: '90009:90009:99999:09990:00900:'.	SymbolDict at: #musicCrotchet put: '00900:00900:00900:99900:99900:'.	SymbolDict at: #musicQuaver put: '00900:00990:00909:99900:99900:'.	SymbolDict at: #musicQuavers put: '09999:09009:09009:99099:99099:'.	SymbolDict at: #pitchfork put: '90909:90909:99999:00900:00900:'.	SymbolDict at: #xmas put: '00900:09990:00900:09990:99999:'.	SymbolDict at: #pacman put: '09999:99090:99900:99990:09999:'.	SymbolDict at: #target put: '00900:09990:99099:09990:00900:'.	SymbolDict at: #tshirt put: '99099:99999:09990:09990:09990:'.	SymbolDict at: #rollerskate put: '00099:00099:99999:99999:09090:'.	SymbolDict at: #duck put: '09900:99900:09999:09990:00000:'.	SymbolDict at: #house put: '00900:09990:99999:09990:09090:'.	SymbolDict at: #tortoise put: '00000:09990:99999:09090:00000:'.	SymbolDict at: #butterfly put: '99099:99999:00900:99999:99099:'.	SymbolDict at: #stickfigure put: '00900:99999:00900:09090:90009:'.	SymbolDict at: #ghost put: '99999:90909:99999:99999:90909:'.	SymbolDict at: #sword put: '00900:00900:00900:09990:00900:'.	SymbolDict at: #giraffe put: '99000:09000:09000:09990:09090:'.	SymbolDict at: #skull put: '09990:90909:99999:09990:09990:'.	SymbolDict at: #umbrella put: '09990:99999:00900:90900:09900:'.	SymbolDict at: #snake put: '99000:99099:09090:09990:00000:'.! !Object subclass: #MicrobitLed	instanceVariableNames: 'matrix active scrollingPos scrollingRaster animatingPos animateImages interval timer '	classVariableNames: 'CharDict SymbolDict '	poolDictionaries: ''	category: 'Microwitch-Objects'!!MicrobitLed methodsFor: 'initialize'!initialize	super initialize.	self clear.	active := true.	scrollingPos := 0.	animatingPos := 0.	interval := 100.	timer := 0.! !!MicrobitLed methodsFor: 'accessing' stamp: 'EiichiroIto 6/20/2018 12:58'!active	^ active! !!MicrobitLed methodsFor: 'accessing' stamp: 'EiichiroIto 6/20/2018 12:59'!active: aBoolean	active := aBoolean.! !!MicrobitLed methodsFor: 'accessing'!animateImages: anArray interval: anInteger	scrollingPos := 0.	animateImages := anArray deepCopy.	interval := anInteger.	timer := 0.	animateImages isEmpty		ifTrue: [animatingPos := 0]		ifFalse: [animatingPos := 1].	self doAnimationForce: true.! !!MicrobitLed methodsFor: 'accessing'!animateString: aString interval: anInteger	| images |	images := OrderedCollection new.	aString do: [:each | images add: (MicrobitImage charAt: each) ].	self animateImages: images interval: anInteger.! !!MicrobitLed methodsFor: 'accessing' stamp: 'EiichiroIto 6/27/2018 19:00'!clear	matrix := self newMatrix.! !!MicrobitLed methodsFor: 'accessing'!doOneCycle	self doScroll.	self doAnimationForce: false.! !!MicrobitLed methodsFor: 'accessing'!matrix	^ matrix asArray! !!MicrobitLed methodsFor: 'accessing'!scroll: aString 	| in result c m cols |	scrollingPos > 0 ifTrue: [^ self].	in := ReadStream on: aString.	result := OrderedCollection new.	self addSpaceTo: result.	[in atEnd]		whileFalse: 			[c := in next.			m := MicrobitImage charAt: c.			cols := self trimMatrix: m asArray.			cols ifNil: [self addSpaceTo: result]				ifNotNil: [result add: self newColumn;					 addAll: cols;					 add: self newColumn]].	self addSpaceTo: result.	scrollingRaster := result asArray.	scrollingPos := 1.! !!MicrobitLed methodsFor: 'accessing'!x: x y: y 	(x between: 0 and: matrix columns - 1)		ifFalse: [^ 0].	(y between: 0 and: matrix lines - 1)		ifFalse: [^ 0].	^ matrix x: x + 1 y: y + 1! !!MicrobitLed methodsFor: 'accessing'!x: x y: y v: v	(x between: 0 and: matrix columns - 1)		ifFalse: [^ self].	(y between: 0 and: matrix lines - 1)		ifFalse: [^ self].	matrix x: x + 1 y: y + 1 v: v.! !!MicrobitLed methodsFor: 'private'!addSpaceTo: aCollection	self class columns timesRepeat: [aCollection add: self newColumn].! !!MicrobitLed methodsFor: 'private' stamp: 'EiichiroIto 7/2/2018 17:14'!doAnimationForce: aBoolean 	animatingPos < 1 ifTrue: [^ self].	timer := timer + 100.	(aBoolean or: [timer < interval])		ifTrue: [^ self].	timer := 0.	matrix := animateImages at: animatingPos.	animatingPos := animatingPos + 1.	animatingPos > animateImages size ifTrue: [animatingPos := 0].! !!MicrobitLed methodsFor: 'private'!doScroll	scrollingPos < 1 ifTrue: [^ self].	matrix := MicrobitImage fromColumns: (scrollingRaster copyFrom: scrollingPos to: scrollingPos + 4).	scrollingPos := scrollingPos + 1.	scrollingPos + 5 > scrollingRaster size ifTrue: [scrollingPos := 0]! !!MicrobitLed methodsFor: 'private'!matrixFromImage: aString	^ self newMatrix fromString: aString	! !!MicrobitLed methodsFor: 'private'!newColumn	^ Array new: self class lines withAll: 0! !!MicrobitLed methodsFor: 'private'!newMatrix	^ MicrobitImage columns: self class columns lines: self class lines! !!MicrobitLed methodsFor: 'private' stamp: 'EiichiroIto 7/2/2018 20:52'!privMatrix	^ matrix! !!MicrobitLed methodsFor: 'private'!privMatrix: anImage	matrix := anImage.! !!MicrobitLed methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!trimMatrix: anArray 	| start end |	start := end := nil.	anArray		withIndexDo: [:each :index | each sum = 0				ifFalse: 					[start ifNil: [start := index].					end := index]].	start ifNil: [^ nil].	^ anArray copyFrom: start to: end! !!MicrobitLed methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: 'Image('.	matrix printOn: aStream.	aStream nextPut: $).! !!MicrobitLed methodsFor: 'testing' stamp: 'EiichiroIto 7/2/2018 06:19'!isAnimating	^ animatingPos > 0! !!MicrobitLed methodsFor: 'testing' stamp: 'EiichiroIto 6/22/2018 07:06'!isScrolling	^ scrollingPos > 0! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MicrobitLed class	instanceVariableNames: ''!!MicrobitLed class methodsFor: 'accessing' stamp: 'EiichiroIto 6/29/2018 16:36'!columns	^ 5! !!MicrobitLed class methodsFor: 'accessing' stamp: 'EiichiroIto 6/29/2018 16:36'!lines	^ 5! !Morph subclass: #MicrobitLedEditorMorph	instanceVariableNames: 'image matrix done response intensity marker '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Objects'!!MicrobitLedEditorMorph methodsFor: 'private' stamp: 'EiichiroIto 6/28/2018 21:29'!buttonAt: aPoint	^ (matrix at: aPoint x) at: aPoint y	! !!MicrobitLedEditorMorph methodsFor: 'private'!cancel	response := false.	done := true.	self delete.	World doOneCycle.! !!MicrobitLedEditorMorph methodsFor: 'private'!createWatcher	| morph |	morph := WatcherMorph new.	morph layoutStyle: #slider.	morph target: self selector: #level: parameter: 'level'.	morph sliderRange: #(0 9).	^ morph! !!MicrobitLedEditorMorph methodsFor: 'private'!newImage	| morph out |	out := WriteStream on: ''.	1 to: MicrobitLed lines do: 		[:y | 		1 to: MicrobitLed columns do: 			[:x | 			morph := self buttonAt: x @ y.			out nextPut: (Character value: $0 asciiValue + morph value)].		out nextPut: $:].	^ out contents! !!MicrobitLedEditorMorph methodsFor: 'private'!newIntensityButtonFor: anInteger 	^ LedEditorButtonMorph new		extent: 10 @ 10;		intensity: anInteger! !!MicrobitLedEditorMorph methodsFor: 'private'!newMatrix	| m row |	m := Array new: MicrobitLed columns.	1 to: MicrobitLed columns do: 		[:x | 		row := Array new: MicrobitLed lines.		1 to: MicrobitLed lines do: [:y | row at: y put: (self newMatrixButtonFor: 0)].		m at: x put: row].	^ m! !!MicrobitLedEditorMorph methodsFor: 'private'!newMatrixButtonFor: anInteger	^ LedEditorButtonMorph new		extent: 10 @ 10;		value: anInteger! !!MicrobitLedEditorMorph methodsFor: 'private'!ok	image := self newImage.	response := true.	done := true.	self delete.	World doOneCycle.! !!MicrobitLedEditorMorph methodsFor: 'private'!updateImage	| in x y c |	x := 1.	y := 1.	in _ ReadStream on: image.	[in atEnd]		whileFalse: 			[c := in next.			c = $:				ifTrue: 					[y := y + 1.					x := 1]				ifFalse: [(c between: $0 and: $9)						ifTrue: 							[(self buttonAt: x @ y)								value: c asciiValue - $0 asciiValue.							x := x + 1]]]! !!MicrobitLedEditorMorph methodsFor: 'event handling' stamp: 'EiichiroIto 6/29/2018 16:17'!handlesMouseDown: evt	^ true! !!MicrobitLedEditorMorph methodsFor: 'event handling' stamp: 'EiichiroIto 6/29/2018 16:17'!mouseDown: evt	self! !!MicrobitLedEditorMorph methodsFor: 'initialization'!addButtons	| x y w h |	w := self width - 20 + 5 // MicrobitLed columns.	h := self height - 60 + 9 // MicrobitLed lines.	x := self left + 15.	matrix do: 		[:each | 		y := self top + 30.		each do: 			[:morph | 			morph position: x @ y.			self addMorphBack: morph.			y := y + h].		x := x + w]! !!MicrobitLedEditorMorph methodsFor: 'initialization'!addIntensityMorphs	| x y w m |	marker := Morph new		extent: 10 @ 3;		color: Color blue.	self addMorph: marker.	w := self width - 20 + 5 // 10.	x := self left + 10.	y := self top + 10.	(0 to: 9)		do: 			[:each | 			m := self newIntensityButtonFor: each.			m position: x @ y.			self addMorphBack: m.			each == 9 ifTrue: [marker position: x @ (y + 12)].			x := x + w]! !!MicrobitLedEditorMorph methodsFor: 'initialization'!addOKCancelButton	| cancel ok |	cancel := ScratchFrameMorph buttonLabel: 'Cancel' localized selector: #cancel.	cancel target: self.	self addMorphBack: cancel.	ok := ScratchFrameMorph buttonLabel: 'OK' localized selector: #ok.	ok target: self.	self addMorphBack: ok.	cancel position: self right - cancel width - 2 @ (self bottom - cancel height - 2).	ok position: cancel left - ok width - 2 @ (self bottom - ok height - 2).! !!MicrobitLedEditorMorph methodsFor: 'initialization'!initialize	super initialize.	self extent: 150 @ 150.	self color: Color white.	intensity := 9.	matrix := self newMatrix.	self addIntensityMorphs.	self addButtons.	self addOKCancelButton! !!MicrobitLedEditorMorph methodsFor: 'accessing'!getUserResponse	| w |	response := false.	self openInWorld.	"self position: owner center - (self extent // 2)."	w := self world.	done := false.	[done]		whileFalse: [w doOneCycle].	^ response! !!MicrobitLedEditorMorph methodsFor: 'accessing' stamp: 'EiichiroIto 6/28/2018 20:11'!image	^ image! !!MicrobitLedEditorMorph methodsFor: 'accessing'!image: aString	image := aString.	self updateImage.! !!MicrobitLedEditorMorph methodsFor: 'accessing' stamp: 'EiichiroIto 7/15/2018 18:41'!intensity	^ intensity! !!MicrobitLedEditorMorph methodsFor: 'accessing' stamp: 'EiichiroIto 7/15/2018 18:41'!intensity: anInteger	intensity := anInteger! !!MicrobitLedEditorMorph methodsFor: 'accessing' stamp: 'EiichiroIto 7/15/2018 19:26'!marker	^ marker! !Morph subclass: #MicrobitLedMorph	instanceVariableNames: 'target '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Objects'!!MicrobitLedMorph methodsFor: 'accessing' stamp: 'EiichiroIto 6/19/2018 22:13'!target: anObject	target := anObject.! !!MicrobitLedMorph methodsFor: 'stepping and presenter' stamp: 'EiichiroIto 6/27/2018 19:00'!step	target doOneCycle.	self changed.! !!MicrobitLedMorph methodsFor: 'stepping and presenter'!stepTime	^ 100! !!MicrobitLedMorph methodsFor: 'stepping and presenter' stamp: 'EiichiroIto 6/20/2018 05:57'!wantsSteps	^ true! !!MicrobitLedMorph methodsFor: 'drawing'!drawOn: aCanvas 	| w h x y r c |	target ifNil: [^ self].	target active ifFalse: [^ aCanvas fillRectangle: self bounds color: Color black].	aCanvas frameRectangle: self bounds color: Color blue.	w := self width + 5 // MicrobitLed columns.	h := self height + 9 // MicrobitLed lines.	x := self left.	target matrix do: 		[:each | 		y := self top.		each do: 			[:v | 			r := x @ y extent: 5 @ 9.			c := Color r: v * 0.11 g: 0.0 b: 0.0.			v > 0 ifTrue: [aCanvas fillRectangle: r color: c].			y := y + h].		x := x + w]! !!MicrobitLedMorph methodsFor: 'object i/o' stamp: 'EiichiroIto 6/20/2018 20:48'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		target	) from: anObjStream.! !!MicrobitLedMorph methodsFor: 'object i/o' stamp: 'EiichiroIto 6/20/2018 20:48'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		target	) on: anObjStream.! !ScratchSpriteMorph subclass: #MicrobitSpriteMorph	instanceVariableNames: 'led pins sensors buttons startMsec calibrated '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Objects'!!MicrobitSpriteMorph methodsFor: 'private' stamp: 'EiichiroIto 6/20/2018 07:21'!coerceChoiceArg: aMorphOrSymbol	(aMorphOrSymbol isKindOf: Symbol) ifTrue: [^ aMorphOrSymbol].	^ aMorphOrSymbol choice! !!MicrobitSpriteMorph methodsFor: 'private' stamp: 'EiichiroIto 6/19/2018 10:11'!costumePath: fileName 	| costumeFolder |	costumeFolder := ScratchFileChooserDialog getDefaultFolderForType: #costume.	^ costumeFolder pathName , FileDirectory slash , fileName! !!MicrobitSpriteMorph methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!layoutChanged	super layoutChanged.	submorphs size >= 3		ifTrue: 			[(submorphs at: 1)				position: self topLeft + (14 @ 75).			(submorphs at: 2)				position: self topLeft + (166 @ 75).			(submorphs at: 3)				position: self topLeft + (65 @ 53)]! !!MicrobitSpriteMorph methodsFor: 'list names' stamp: 'EiichiroIto 6/16/2018 10:48'!buttonNames	^ #(a b)! !!MicrobitSpriteMorph methodsFor: 'list names' stamp: 'EiichiroIto 6/16/2018 17:07'!gestureNames	^ #(up down left right 'face up' 'face down' freefall '3g' '6g' '8g' shake)! !!MicrobitSpriteMorph methodsFor: 'list names' stamp: 'EiichiroIto 6/27/2018 19:00'!ledArrowNames	^ #(arrowN arrowNE arrowE arrowSE arrowS arrowSW arrowW arrowNW)! !!MicrobitSpriteMorph methodsFor: 'list names' stamp: 'EiichiroIto 6/15/2018 20:16'!ledCharacterNames	^ #(rabbit cow musicCrotchet musicQuaver musicQuavers pitchfork xmas pacman target tshirt rollerskate duck house tortoise butterfly stickfigure ghost sword giraffe skull umbrella snake)! !!MicrobitSpriteMorph methodsFor: 'list names'!ledClockNames	^ #(clock12 clock1 clock2 clock3 clock4 clock5 clock6 clock7 clock8 clock9 clock10 clock11)! !!MicrobitSpriteMorph methodsFor: 'list names' stamp: 'EiichiroIto 6/27/2018 19:00'!ledShapeNames	^ #(triangle triangleLeft chessboard diamond diamondSmall square squareSmall)! !!MicrobitSpriteMorph methodsFor: 'list names' stamp: 'EiichiroIto 6/27/2018 19:00'!ledSymbolNames	^ #(heart heartSmall happy smile sad confused angry asleep surprised silly fabulous meh yes no)! !!MicrobitSpriteMorph methodsFor: 'list names' stamp: 'EiichiroIto 6/16/2018 09:47'!musicNames	^ #(dadadadum entertainer prelude ode nyan ringtone funk blues birthday wedding funeral punchline python baddy chase baDing wawawawaa jumpUp jumpDown powerUp powerDown)! !!MicrobitSpriteMorph methodsFor: 'list names' stamp: 'EiichiroIto 6/27/2018 19:00'!sensorNames	^ #(accelX accelY accelZ compassX compassY compassZ)! !!MicrobitSpriteMorph methodsFor: 'list names' stamp: 'EiichiroIto 7/9/2018 09:06'!shiftDirection	^ #(left right up down)! !!MicrobitSpriteMorph methodsFor: 'initialization' stamp: 'EiichiroIto 6/27/2018 19:00'!buildSubmorphs	| morph |	morph := MicrobitButtonMorph new extent: 20 @ 20;			 target: (buttons at: 1).	self addMorphBack: morph.	morph := MicrobitButtonMorph new extent: 20 @ 20;			 target: (buttons at: 2).	self addMorphBack: morph.	morph := MicrobitLedMorph new extent: 75 @ 75;			 target: led.	self addMorphBack: morph! !!MicrobitSpriteMorph methodsFor: 'initialization'!initialize	super initialize.	self extent: 400 @ 169.	buttons := Array with: MicrobitButton new with: MicrobitButton new.	led := MicrobitLed new.	startMsec := Time millisecondClockValue.	calibrated := false.	pins := Array new: 21.	self buildSubmorphs.! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 7/14/2018 07:04'!addIOBlocksTo: page x: orgX y: orgY 	| x y |	x := orgX.	y := orgY.	(self blocksFor: 'io')		do: [:blockOrSym |			((blockOrSym = #-) | (blockOrSym = #~))				ifTrue: 					[(blockOrSym = #-) ifTrue: [y := y + 15].					(blockOrSym = #~) ifTrue: [y := y + 5]]				ifFalse: [y := self								createBlock: blockOrSym								atPosition: x @ y								onPage: page]].	^ y! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!buttonIsPressed: aMorph	| choice |	choice := self coerceChoiceArg: aMorph.	choice = #a ifTrue: [^ (buttons at: 1) on].	choice = #b ifTrue: [^ (buttons at: 2) on].	self error: 'invalid arg'.! !!MicrobitSpriteMorph methodsFor: 'io blocks'!buttonWasPressed: aMorph	| choice |	choice := self coerceChoiceArg: aMorph.	choice = #a ifTrue: [^ (buttons at: 1) count > 0].	choice = #b ifTrue: [^ (buttons at: 2) count > 0].	self error: 'invalid arg'.! !!MicrobitSpriteMorph methodsFor: 'io blocks'!countOfButtonPressed: aMorph	| choice |	choice := self coerceChoiceArg: aMorph.	choice = #a ifTrue: [^ (buttons at: 1) count].	choice = #b ifTrue: [^ (buttons at: 2) count].	self error: 'invalid arg'.! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 7/5/2019 14:29'!i2cRead: addr	! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 7/5/2019 14:30'!i2cWrite: addr list: list	! !!MicrobitSpriteMorph methodsFor: 'io blocks'!ioPage	| page addButton deleteButton x y maxX hasNeoPixel |	page := ScratchBlockPaletteMorph new color: (Color r: 0.8 g: 0.8 b: 1.0);			 borderWidth: 0.	x := 12.	y := 10.	y := self addIOBlocksTo: page x: x y: y.	y := y + 10.	addButton := ScratchFrameMorph buttonLabel: 'Make a NeoPixel' localized selector: #addNeoPixel.	deleteButton := ScratchFrameMorph buttonLabel: 'Delete a NeoPixel' localized selector: #deleteNeoPixel.	page addMorph: (addButton target: self; position: x @ y).	y := addButton bottom + 3.	hasNeoPixel := self neoPixels size > 0.	hasNeoPixel		ifTrue: 			[page addMorph: (deleteButton target: self; position: x @ y).			y := deleteButton bottom + 10.			y := self addNeoPixelsTo: page x: x y: y.			y := y + 12.			y := self addNeoPixelBlocksTo: page x: x y: y].	maxX := page submorphs inject: 0 into: [:t :m | t max: m right].	page extent: maxX + 10 @ y.	^ page! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 10/14/2018 15:33'!ioPinMenu	| menu |	menu _ CustomMenu new.	(0 to: 16)		, #(19 20 ) do: [:s | menu add: s asString action: s].	menu localize.	^ menu! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!pinIsTouched: anInteger	Transcript cr; show: 'pinIsTouched: '; show: anInteger asString.	^ false! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!readAnalog: anInteger	Transcript cr; show: 'readAnalog: '; show: anInteger asString.	^ 0! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!readDigital: anObject	Transcript cr; show: 'readDigital: '; show: anObject asString.	^ 0! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 6/22/2018 16:42'!setAnalogPeriod: anInteger msec: anObject	Transcript cr; show: 'setAnalogPeriod: '; show: anInteger; show: ' msec: '; show: anObject.! !!MicrobitSpriteMorph methodsFor: 'io blocks'!setServo: pin msec: msec min: min max: max 	Transcript show: 'setServo: ';	 show: pin;	 show: ' msec: ';	 show: msec;	 show: ' min: ';	 show: min;	 show: ' max: ';	 show: max;	 cr! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 6/22/2018 16:41'!writeAnalog: anInteger to: anObject	Transcript cr; show: 'writeAnalog: '; show: anInteger asString; show: ' to: '; show: anObject.! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 6/22/2018 16:40'!writeDigital: anInteger to: anObject	Transcript cr; show: 'writeDigital: '; show: anInteger asString; show: ' to: '; show: anObject.! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 10/15/2018 14:46'!writeServo: pin to: value 	Transcript show: 'writeServo: ';	 show: pin;	 show: ' to: ';	 show: value;	 cr! !!MicrobitSpriteMorph methodsFor: 'led blocks'!animate: anObject	anObject animateOn: led atInterval: 400.! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 7/13/2018 07:37'!arrowImageOf: aSymbol	^ self symbolImageOf: aSymbol! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 7/13/2018 07:37'!characterImageOf: aSymbol	^ self symbolImageOf: aSymbol! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!clearPixels	led clear! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 7/13/2018 07:27'!clockImageOf: aSymbol	^ self symbolImageOf: aSymbol! !!MicrobitSpriteMorph methodsFor: 'led blocks'!cropX: x y: y w: w h: h of: image	^ image cropX: x + 1 y: y + 1 w: w h: h! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!getPixelAtx: x y: y	^ led x: x y: y! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 6/20/2018 13:00'!isOnLed	^ led active! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 6/20/2018 12:59'!offLed	led active: false.! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 6/20/2018 12:59'!onLed	led active: true.! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!scroll: anObject	led scroll: anObject asString.! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!setPixelAtx: x y: y v: v 	led x: x y: y v: v.! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 7/13/2018 07:37'!shapeImageOf: aSymbol	^ self symbolImageOf: aSymbol! !!MicrobitSpriteMorph methodsFor: 'led blocks' stamp: 'EiichiroIto 7/13/2018 07:02'!symbolImageOf: aSymbol	^ MicrobitImage symbolAt: aSymbol.! !!MicrobitSpriteMorph methodsFor: 'object i/o'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		buttons		led		pins	) from: anObjStream.! !!MicrobitSpriteMorph methodsFor: 'object i/o'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		buttons		led		pins	) on: anObjStream.! !!MicrobitSpriteMorph methodsFor: 'testing'!ioPinInUse: anInteger 	^ (pins at: anInteger + 1) notNil! !!MicrobitSpriteMorph methodsFor: 'testing' stamp: 'EiichiroIto 7/2/2018 07:05'!isAnimating	^ led isAnimating! !!MicrobitSpriteMorph methodsFor: 'testing' stamp: 'EiichiroIto 6/22/2018 07:09'!isScrolling	^ led isScrolling! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/23/2018 18:29'!abs: absoluteValue sign: signValue 	^ absoluteValue abs * signValue sign! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/27/2018 19:00'!anyOf: aCollection 	| obj |	obj := aCollection atRandom.	(obj isKindOf: Character)		ifTrue: [obj := obj asString].	^ obj! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/23/2018 11:40'!equal: x to: y	^ x = y! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/23/2018 11:46'!false	^ false! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 8/28/2018 11:10'!isNone: x	^ x isNil! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/27/2018 19:00'!less: x than: y	^ x < y! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/23/2018 11:40'!more: x than: y	^ x > y! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/27/2018 19:00'!not: x	^ x not! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 8/28/2018 12:15'!numberOf: anObject	^ anObject asNumberNoError! !!MicrobitSpriteMorph methodsFor: 'operators'!setRandomSeed: anInteger	RandomGen seed: anInteger.! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/23/2018 11:30'!stringOf: anObject	^ anObject asString! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/23/2018 11:46'!true	^ true! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/27/2018 19:00'!x: x andY: y	^ x & y! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/27/2018 19:00'!x: x divY: y	^ x / y! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/23/2018 11:27'!x: x minusY: y	^ x - y! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/23/2018 11:28'!x: x modY: y	^ x \\ y! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/23/2018 11:27'!x: x mulY: y	^ x * y! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/27/2018 19:00'!x: x orY: y	^ x | y! !!MicrobitSpriteMorph methodsFor: 'operators' stamp: 'EiichiroIto 6/27/2018 19:00'!x: x plusY: y	^ x + y! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 6/27/2018 19:00'!calibrateCompass	calibrated := true.! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 6/23/2018 19:34'!clearCalibration	calibrated := false.! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 6/23/2018 18:58'!currentGesture	^ 'up'! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 6/23/2018 19:34'!fieldStrength	^ 0! !!MicrobitSpriteMorph methodsFor: 'sensing ops'!gestures	^ 'up down'! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 6/23/2018 19:34'!headingCompass	^ 0! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 6/27/2018 19:00'!isCalibrated	^ calibrated! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 6/27/2018 19:00'!isGesture: aString	^ aString = self currentGesture! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 6/23/2018 18:33'!runningTime	^ Time millisecondClockValue - startMsec! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 6/27/2018 19:00'!sensorValueOf: aSymbol	^ 0! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 6/23/2018 18:33'!temperature	^ 0! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 6/23/2018 18:59'!wasGesture: aString	^ aString = self currentGesture! !!MicrobitSpriteMorph methodsFor: 'sound ops' stamp: 'EiichiroIto 6/24/2018 20:00'!getTempo	^ 120! !!MicrobitSpriteMorph methodsFor: 'sound ops' stamp: 'EiichiroIto 6/24/2018 20:00'!playMusicList: aCollection	! !!MicrobitSpriteMorph methodsFor: 'sound ops' stamp: 'EiichiroIto 6/24/2018 19:59'!playMusicSymbol: aSymbol	! !!MicrobitSpriteMorph methodsFor: 'sound ops' stamp: 'EiichiroIto 6/24/2018 19:59'!playMusicSymbolRepeat: aSymbol	! !!MicrobitSpriteMorph methodsFor: 'sound ops' stamp: 'EiichiroIto 6/24/2018 19:59'!playMusicSymbolWait: aSymbol	! !!MicrobitSpriteMorph methodsFor: 'sound ops' stamp: 'EiichiroIto 6/24/2018 20:01'!playPitch: hz msec: msec	! !!MicrobitSpriteMorph methodsFor: 'sound ops' stamp: 'EiichiroIto 6/24/2018 20:01'!resetMusic	! !!MicrobitSpriteMorph methodsFor: 'sound ops' stamp: 'EiichiroIto 6/24/2018 20:00'!resetTempo	! !!MicrobitSpriteMorph methodsFor: 'sound ops' stamp: 'EiichiroIto 6/24/2018 20:00'!setTempoBpm: anInteger	! !!MicrobitSpriteMorph methodsFor: 'sound ops' stamp: 'EiichiroIto 6/24/2018 20:00'!setTempoTicks: anInteger	! !!MicrobitSpriteMorph methodsFor: 'sound ops' stamp: 'EiichiroIto 6/24/2018 20:01'!stopMusic	! !!MicrobitSpriteMorph methodsFor: 'comm ops' stamp: 'EiichiroIto 8/28/2018 11:02'!configRadioGroup: aNumber	! !!MicrobitSpriteMorph methodsFor: 'comm ops' stamp: 'EiichiroIto 6/24/2018 20:25'!offRadio	! !!MicrobitSpriteMorph methodsFor: 'comm ops' stamp: 'EiichiroIto 6/24/2018 20:25'!onRadio	! !!MicrobitSpriteMorph methodsFor: 'comm ops' stamp: 'EiichiroIto 6/24/2018 20:25'!receiveRadio	^ 'Hello!!'! !!MicrobitSpriteMorph methodsFor: 'comm ops' stamp: 'EiichiroIto 6/24/2018 20:26'!resetRadio	! !!MicrobitSpriteMorph methodsFor: 'comm ops' stamp: 'EiichiroIto 6/24/2018 20:25'!sendRadio: aString	! !!MicrobitSpriteMorph methodsFor: 'image blocks'!arrowImageAt: anInteger 	| list index sym |	list := self ledArrowNames.	index := anInteger \\ list size + 1.	sym := list at: index.	^ MicrobitImage symbolAt: sym! !!MicrobitSpriteMorph methodsFor: 'image blocks'!clockImageAt: anInteger 	| list index sym |	list := self ledClockNames.	index := anInteger \\ list size + 1.	sym := list at: index.	^ MicrobitImage symbolAt: sym! !!MicrobitSpriteMorph methodsFor: 'image blocks' stamp: 'EiichiroIto 7/21/2018 10:29'!copiedImageOf: image	^ image copy! !!MicrobitSpriteMorph methodsFor: 'image blocks' stamp: 'EiichiroIto 7/21/2018 08:35'!fill: image with: value	image fillWith: value.! !!MicrobitSpriteMorph methodsFor: 'image blocks' stamp: 'EiichiroIto 7/9/2018 09:23'!getPixelAtx: x y: y of: image 	^ image		x: x + 1		y: y + 1! !!MicrobitSpriteMorph methodsFor: 'image blocks' stamp: 'EiichiroIto 7/9/2018 09:23'!heightOfImage: image	^ image lines! !!MicrobitSpriteMorph methodsFor: 'image blocks'!imageOf: aString 	| obj |	obj := MicrobitImage columns: MicrobitLed columns lines: MicrobitLed lines.	^ obj fromString: aString! !!MicrobitSpriteMorph methodsFor: 'image blocks'!imageWidth: width height: height	| obj |	obj := MicrobitImage columns: width lines: height.	^ obj! !!MicrobitSpriteMorph methodsFor: 'image blocks'!imagesOfList: aString	| list |	list := self listNamed: aString ifNone: [^ 0].	^ (list listContents collect: [:each | MicrobitImage fromString: each]) asArray! !!MicrobitSpriteMorph methodsFor: 'image blocks' stamp: 'EiichiroIto 7/21/2018 10:29'!invertedImageOf: image	^ image copy invert! !!MicrobitSpriteMorph methodsFor: 'image blocks' stamp: 'EiichiroIto 7/9/2018 09:20'!setPixelAtx: x y: y v: v of: image 	image		x: x + 1		y: y + 1		v: v! !!MicrobitSpriteMorph methodsFor: 'image blocks'!shiftDir: direction pixels: n of: image	image shift: direction by: n! !!MicrobitSpriteMorph methodsFor: 'image blocks' stamp: 'EiichiroIto 7/9/2018 09:23'!widthOfImage: image	^ image columns! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks'!addNeoPixel	| sFrame result pin |	(sFrame := self ownerThatIsA: ScratchFrameMorph) ifNil: [^ self beep].	result := StringDialog ask: 'pin No?'.	result size = 0 ifTrue: [^ self].	pin := result asNumberNoError asInteger.	(self ioPinInUse: pin)		ifTrue: 			[self beep.			^ DialogBoxMorph warn: 'That pin is already in use'].	(pin between: 0 and: 15)		ifFalse: 			[self beep.			^ DialogBoxMorph warn: 'Currently pin number is supported up to 15'].	self addNeoPixel: pin.	sFrame viewerPane categoryChanged: 'io'! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks'!addNeoPixel: anInteger	pins at: anInteger + 1 put: #neoPixel.! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks'!addNeoPixelBlocksTo: page x: x y: startY 	| y npBlocks |	y := startY.	npBlocks := OrderedCollection new.	(self blocksFor: 'neoPixel')		do: [:each | npBlocks add: each].	npBlocks do: 		[:each | 		each color: self neoPixelBlockColor.		page addMorph: (each position: x @ y).		y := each bottom + 3].	^ y! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks'!addNeoPixelsTo: page x: x y: startY 	| y block spec |	y := startY.	self neoPixels do: 		[:pin | 		spec := self neoPixelSpecFor: pin.		block := NeoPixelBlockMorph new				position: x @ y;				pin: pin;				color: self neoPixelBlockColor;				commandSpec: spec;				receiver: self blockReceiver.		block expressionArg numExpression: self defaultNeoPixelNumber.		page addMorph: block.		y := y + block height + 3].	^ y! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks' stamp: 'EiichiroIto 7/14/2018 10:52'!defaultNeoPixelName	^ self neoPixelPinNames first! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks' stamp: 'EiichiroIto 7/14/2018 15:54'!defaultNeoPixelNumber	^ 10! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks'!deleteNeoPixel	| sFrame menu choice |	sFrame := self ownerThatIsA: ScratchFrameMorph.	sFrame ifNil: [^ self].	self neoPixels isEmpty ifTrue: [^ self inform: 'No NeoPixels.' localized].	menu := CustomMenu new.	self neoPixels do: [:pin | menu add: 'pin ' localized , pin asString action: pin].	choice := menu startUp.	choice ifNil: [^ self].	self deleteNeoPixel: choice.	sFrame viewerPane categoryChanged: 'io'! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks'!deleteNeoPixel: anInteger	pins at: anInteger + 1 put: nil.! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks'!neoPixelBlockColor	^ self class blockColorFor: 'neoPixel'! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks'!neoPixelBlockFromTuple: tuple receiver: scriptOwner 	| pin number rcvr block spec |	pin := tuple at: 2.	number := tuple at: 3.	rcvr := scriptOwner.	(self neoPixels includes: pin)		ifFalse: [self addNeoPixel: pin].	tuple first = #neoPixel		ifTrue: 			[spec := self neoPixelSpecFor: pin.			block := NeoPixelBlockMorph new			 pin: pin;			 commandSpec: spec;			 receiver: rcvr;			 color: self neoPixelBlockColor.			block expressionArg numExpression: number.			^ block].	self error: 'unknown neoPixel spec'! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks'!neoPixelPinNames	^ self neoPixels collect: [:each | each asString]! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks' stamp: 'EiichiroIto 7/14/2018 15:48'!neoPixelSpecFor: pin	^ 'setup NeoPixel as pin ', pin asString , ' number %n'! !!MicrobitSpriteMorph methodsFor: 'neopixel blocks'!neoPixels	^ (0 to: pins size - 1) select: [:each | (pins at: each + 1) = #neoPixel]! !!MicrobitSpriteMorph methodsFor: 'neopixel ops'!clearNeoPixel: neoPixel	! !!MicrobitSpriteMorph methodsFor: 'neopixel ops' stamp: 'EiichiroIto 7/14/2018 11:11'!setNo: no r: r g: g b: b neoPixel: neoPixel	! !!MicrobitSpriteMorph methodsFor: 'neopixel ops'!setupNeoPixelPin0number: anInteger	! !!MicrobitSpriteMorph methodsFor: 'neopixel ops' stamp: 'EiichiroIto 7/14/2018 11:34'!setupNeoPixelPin1number: anInteger	! !!MicrobitSpriteMorph methodsFor: 'neopixel ops'!setupNeoPixelPin2number: anInteger	! !!MicrobitSpriteMorph methodsFor: 'neopixel ops'!showNeoPixel: neoPixel	! !!MicrobitSpriteMorph methodsFor: 'blocks' stamp: 'EiichiroIto 7/17/2018 09:48'!viewerPageForCategory: aCategoryName	aCategoryName = 'io' ifTrue: [^ self ioPage].	^ super viewerPageForCategory: aCategoryName! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MicrobitSpriteMorph class	instanceVariableNames: ''!!MicrobitSpriteMorph class methodsFor: 'block specs' stamp: 'EiichiroIto 6/27/2018 19:00'!additionalControlBlocks	^ #(		'control'			('wait %n msecs'				t	mwait:elapsed:from: 1000)			('panic %n'					-	panic: 0)	)! !!MicrobitSpriteMorph class methodsFor: 'block specs' stamp: 'EiichiroIto 6/27/2018 19:00'!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	^ self ioBlocks, self ledBlocks, self soundBlocks, self commBlocks, self sensingBlocks, self additionalControlBlocks, super blockSpecs! !!MicrobitSpriteMorph class methodsFor: 'block specs'!commBlocks	^ #(		'comm'			('radio on'								-	onRadio)			('radio off'								-	offRadio)			('config radio group %n'			-	configRadioGroup:	0)			-			('send a radio message %s'		-	sendRadio:	'Hello!!')			('received radio message'			r	receiveRadio)			-			('radio reset'							-	resetRadio)	)! !!MicrobitSpriteMorph class methodsFor: 'block specs'!ioBlocks	^ #(		'io'			('button %M is pressed'			b		buttonIsPressed:)			('button %M was pressed'		b		buttonWasPressed:)			('count of button %M pressed'		r		countOfButtonPressed:)			-			('digital read pin %n'				r		readDigital: 0)			('digital write pin %n to %n'	-		writeDigital:to: 0 0) 			('analog read pin %n'				r		readAnalog: 0)			('analog write pin %n to %n'	- 		writeAnalog:to: 0 0)			('analog set period pin %n to %n msec'	- setAnalogPeriod:msec: 0 500)			('pin %n is touched'					b		pinIsTouched: 0)			-			('servo write pin %j to %n degrees'		-		writeServo:to: 0 180)			('servo set pin %j %n msec %n to %n'	-		setServo:msec:min:max:	0	5	100	500)			-			('I2C read addr %n'					r	i2cRead:	0)			('I2C write addr %n data %L'	-	i2cWrite:list:	0)		'neoPixel'			('set %n to r %n g %n b %n of NeoPixel pin %k'		-		setNo:r:g:b:neoPixel: 0 255 255 255 '')			('show NeoPixel of pin %k'								-		showNeoPixel:)			('clear NeoPixel of pin %k'								-		clearNeoPixel:)		)! !!MicrobitSpriteMorph class methodsFor: 'block specs'!ledBlocks	^ #(		'led'			('scroll %s'					s		scrollAndWait)			('scroll %s no wait'		-		scroll: 		'World!!')			('show %s'					s		animateAndWait)			-			('set x %n y %n to %n'		-	setPixelAtx:y:v: 0 0 0)			('point x %n y %n'	r	getPixelAtx:y: 0 0)			('clear'				-		clearPixels)			-			('symbol image of %g'		r		symbolImageOf:	heart)			('clock image of %D'			r		clockImageOf:	clock12)			('arrow image of %I'			r		arrowImageOf:	arrowN)			('shape image of %S'			r		shapeImageOf:	triangle)			('character image of %l'	r		characterImageOf: 	rabbit)			('clock image at %n'		r		clockImageAt: 0)			('arrow image at %n'	r		arrowImageAt: 0)			('image of %C'				r		imageOf: '')			('images of %L'				r		imagesOfList:)			('image width %n height %n'	r	imageWidth:height: 5 5)			('set x %n y %n to %n of %s'	-	setPixelAtx:y:v:of:	0 0 0 '')			('point x %n y %n of %s'	-	getPixelAtx:y:of:	0 0 '')			('width of %s'				r	widthOfImage: '')			('height of %s'				r	heightOfImage: '')			('shift %x %n pixels of %s'	-	shiftDir:pixels:of:	left 1 '')			('crop area x %n y %n w %n h %n of %s'	r	cropX:y:w:h:of:	0 0 5 5 '')			('copy image of %s'				r	copiedImageOf: '')			('inverted image of %s'		r	invertedImageOf: '')			('fill %s with %n'					-	fill:with: '' 0)			-			('led on'			-		onLed)			('led off'			-		offLed)			('led is on'			b		isOnLed)	)! !!MicrobitSpriteMorph class methodsFor: 'block specs' stamp: 'EiichiroIto 6/27/2018 19:00'!sensingBlocks	^ #(		'sensing'			('running time'			r	runningTime)			('temperature'				r	temperature)			('%H sensor value'		r	sensorValueOf: 'accelX')			-			('current gesture'		r	currentGesture)			('is gesture %m ?'		b	isGesture: up)			('was gesture %m ?'		b	wasGesture: up)			('gestures'					r	gestures)			-			('calibrate compass'		-	calibrateCompass)			('is calibrated'				b	isCalibrated)			('heading'						r	headingCompass)			('clear calibration'		-	clearCalibration)			('field strength'			r	fieldStrength)	)! !!MicrobitSpriteMorph class methodsFor: 'block specs' stamp: 'EiichiroIto 6/17/2018 09:49'!soundBlocks	^ #(		'sound'			('play music %N'						-	playMusicSymbol: nyan)			('play music %N repeat'			-	playMusicSymbolRepeat: nyan)			('play music %N until done'	-	playMusicSymbolWait: nyan)			('play music %L'				-	playMusicList:)			('set tempo to %n ticks'	-	setTempoTicks: 4)			('set tempo to %n bpm'		-	setTempoBpm: 120)			('reset tempo'					-	resetTempo)			('tempo'							r	getTempo)			('play pitch %n Hz for %n msec'	-	playPitch:msec: 440 1000)			('stop music'					-	stopMusic)			('reset music'					-	resetMusic)	)! !CommandBlockMorph subclass: #NeoPixelBlockMorph	instanceVariableNames: 'pin '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Objects'!!NeoPixelBlockMorph methodsFor: 'accessing'!asBlockTuple	^ Array with: #neoPixel with: pin with: (argMorphs first evaluate) with: commandSpec! !!NeoPixelBlockMorph methodsFor: 'accessing'!commandSpec: aString	| sel |	super commandSpec: aString localized.	argPermutation := CommandBlockMorph argPermutationForSpec: aString withTranslation: commandSpec.	sel := ('setupNeoPixelPin', pin asString, 'number:') asSymbol.	self selector: sel! !!NeoPixelBlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 7/14/2018 08:57'!expressionArg	submorphs do:		[:m | (m isKindOf: ExpressionArgMorph)			ifTrue: [^ m]].	^ nil! !!NeoPixelBlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 7/14/2018 08:53'!pin	^ pin! !!NeoPixelBlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 7/14/2018 08:52'!pin: anInteger	pin := anInteger.! !MicrobitImage initialize!
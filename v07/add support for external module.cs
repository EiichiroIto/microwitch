'From MIT Squeak 0.9.4 (June 1, 2003) [No updates present.] on 29 March 2021 at 2:15:35 pm'!Object subclass: #MPBoardProcess	instanceVariableNames: 'expression topBlock readyToYield errorFlag readyToTerminate mpboard code state frameMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'MicroPython-Board'!Object subclass: #MicrobitModule	instanceVariableNames: 'moduleName '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Modules'!MicrobitModule subclass: #ExtModule	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Modules'!ExtModule subclass: #ExBoardModule	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Modules'!MicrobitModule subclass: #ModuleObject	instanceVariableNames: 'objectName '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Modules'!ExtModule subclass: #USonicModule2	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Modules'!!CommandBlockMorph methodsFor: 'private'!uncoloredArgMorphFor: specString	"Answer an argument morph for the given argument specification string."	| code |	code := specString at: 2.	$a = code ifTrue: [^ AttributeArgMorph new choice: 'volume'].	$b = code ifTrue: [^ BooleanArgMorph new].	$c = code ifTrue: [^ ColorArgMorph new showPalette: true].	$C = code ifTrue: [^ LedArgMorph new].	$d = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #directionMenu].	$D = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledClockNames].	$e = code ifTrue: [^ EventTitleMorph new].	$f = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #mathFunctionNames; choice: 'sqrt'].	$g = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledSymbolNames].	$H = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #sensorNames].	$h = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #hookupBooleanSensorNames].	$I = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledArrowNames].	$i = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #listIndexMenu].	$j = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #ioPinMenu].	$k = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #neoPixelPinNames].	$L = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #listVarMenu].	$l = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledCharacterNames].	$m = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #gestureNames].	$M = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #buttonNames].	$n = code ifTrue: [^ ExpressionArgMorph new numExpression: '10'].	$N = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #musicNames].	$s = code ifTrue: [^ ExpressionArgMorph new stringExpression: ''].	$S = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledShapeNames].	$T = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #touchPinNames].	$v = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #varNamesMenu; choice: ''].	$W = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #motorDirection].	$x = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #shiftDirection].	$y = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #listIndexForDeleteMenu].	^ ExpressionArgMorph new numExpression: '10'! !!MPBoardProcess methodsFor: 'initialization'!initialize	expression := nil.	errorFlag := false.	state := #start! !!MPBoardProcess methodsFor: 'entry points'!runStepFor: aStageMorph 	self setupFrameMorph: aStageMorph.	self checkConnecting.	self perform: state! !!MPBoardProcess methodsFor: 'entry points'!stop	frameMorph ifNotNil: [frameMorph stopIfRunning].	topBlock ifNotNil: [topBlock scratchProc: nil]! !!MPBoardProcess methodsFor: 'private'!checkConnecting	state = #terminated ifTrue: [^ self].	frameMorph isConnecting ifFalse: [state := #readyToTerminate]! !!MPBoardProcess methodsFor: 'private'!executeScript	frameMorph execute: topBlock.	state := #waitForExecuting! !!MPBoardProcess methodsFor: 'private' stamp: 'EiichiroIto 3/28/2021 15:24'!readyToTerminate	(expression isKindOf: BlockMorph)				ifTrue: [expression litUp: false].			expression := nil.	state := #terminated! !!MPBoardProcess methodsFor: 'private'!setupFrameMorph: aStageMorph 	frameMorph ifNotNil: [^ self].	frameMorph := aStageMorph ownerThatIsA: ScratchFrameMorph! !!MPBoardProcess methodsFor: 'private' stamp: 'EiichiroIto 3/28/2021 15:46'!start	frameMorph stopIfRunning.	state := #executeScript! !!MPBoardProcess methodsFor: 'private' stamp: 'EiichiroIto 3/28/2021 15:24'!terminated	self! !!MPBoardProcess methodsFor: 'private'!waitForExecuting	frameMorph isRunning ifTrue: [^ self].	state := #readyToTerminate! !!MicroPythonBoard methodsFor: 'commands'!existsFileNamed: aString 	| cmd ret |	cmd := 'import os' , String cr , '''' , aString , ''' in os.listdir()'.	ret := self evaluate: cmd timeout: 1000.	ret ifNil: [^ false].	^ ret = 'True'! !!MicroPythonBoard methodsFor: 'commands'!filenames	| cmd ret |	cmd := 'import os' , String cr , 'os.listdir()'.	ret := self evaluate: cmd timeout: 500.	ret ifNil: [^ #()].	^ ret! !!MicroPythonBoard methodsFor: 'commands' stamp: 'EiichiroIto 3/27/2021 17:03'!removeFileNamed: aString 	| cmd ret |	cmd := 'import os' , String cr , 'os.remove(''' , aString , ''')'.	ret := self evaluate: cmd timeout: 500.	ret ifNil: [^ false].	^ ret! !!MicroPythonBoard methodsFor: 'commands'!stopTimeout: anInteger 	| timeout |	self portIsOpen ifFalse: [^ self].	self isReady ifTrue: [^ self].	self stop.	timeout := Time millisecondClockValue + anInteger.	[Time millisecondClockValue > timeout]		whileFalse: 			[self step.			self isReady ifTrue: [^ self]]! !!MicroPythonBoard methodsFor: 'commands'!write: aString fileNamed: aFilename 	| cmd tmp |	"Transcript cr; show: 'sending '; show: aFilename."	cmd := 'f = open(''' , aFilename , ''', ''w'')'.	self request: cmd.	aString lines do: 		[:each | 		tmp := each copyReplaceAll: '''' with: '\'''.		cmd := 'f.write(''' , tmp , '\n'')'.		self request: cmd].	cmd := 'f.close()'.	self request: cmd.	useRaw := true! !!MicroPythonBoard methodsFor: 'commands'!write: aString ifNotExists: aString2 	(self existsFileNamed: aString2)		ifTrue: [^ self].	self write: aString fileNamed: aString2! !!MicrobitCode methodsFor: 'accessing'!externalModules	^ modules select: [:each | each isExtModule]! !!MicrobitCode methodsFor: 'accessing'!pythonScriptFrom: aCollection stageMorph: aMorph	| code header |	stream := WriteStream on: (String new: 10000).	generator := ScratchCodeGenerator hats: aCollection target: self.	generator emitCode.	code := stream contents.	stream := WriteStream on: (String new: 1000).	self generateHeaderOf: aMorph.	header := stream contents.	^ header, code! !!MicrobitCode methodsFor: 'io blocks'!exMotorChspeed: aMorph 	| args ch speed |	self useExBoard.	args := aMorph blockArgs.	ch := args first argString: generator.	speed := args second argString: generator.	stream nextPutAll: (ExBoardModule motorChannel: ch speed: speed)! !!MicrobitCode methodsFor: 'io blocks'!exServoChdegrees: aMorph 	| args ch degrees |	self useExBoard.	args := aMorph blockArgs.	ch := args first argString: generator.	degrees := args second argString: generator.	stream nextPutAll: (ExBoardModule servoChannel: ch degrees: degrees)! !!MicrobitCode methodsFor: 'io blocks'!i2cWritedata: aMorph 	| args |	self useI2C.	args := aMorph blockArgs.	stream nextPutAll: 'microbit.i2c.write(';	 nextPutAll: (args first argString: generator);	 nextPutAll: ',bytes([';	 nextPutAll: (args second argString: generator);	 nextPutAll: ']))'! !!MicrobitCode methodsFor: 'io blocks'!i2cWritedataand: aMorph 	| args |	self useI2C.	args := aMorph blockArgs.	stream nextPutAll: 'microbit.i2c.write(';	 nextPutAll: (args first argString: generator);	 nextPutAll: ',bytes([';	 nextPutAll: (args second argString: generator);	 nextPut: $,;	 nextPutAll: (args third argString: generator);	 nextPutAll: ']))'! !!MicrobitCode methodsFor: 'io blocks' stamp: 'EiichiroIto 3/29/2021 12:49'!i2cWritedataandand: aMorph 	| args |	self useI2C.	args := aMorph blockArgs.	stream nextPutAll: 'microbit.i2c.write(';	 nextPutAll: (args first argString: generator);	 nextPutAll: ',bytes([';	 nextPutAll: (args second argString: generator);	 nextPut: $,;	 nextPutAll: (args third argString: generator);	 nextPut: $,;	 nextPutAll: (args fourth argString: generator);	 nextPutAll: ']))'! !!MicrobitCode methodsFor: 'io blocks'!initExBoard: aMorph	stream nextPutAll: ExBoardModule init! !!MicrobitCode methodsFor: 'io blocks'!pinIsTouched: aMorph 	^ 'microbit.' , aMorph blockArgs first evaluate , '.is_touched()'! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 3/28/2021 17:10'!useExBoard	modules add: MicrobitModule exBoard! !!MicrobitCode methodsFor: 'private'!useUsonic	modules add: MicrobitModule usonic! !!MicrobitCode methodsFor: 'sensor blocks'!setUsonicTrigecho: aMorph 	| args trig echo |	self useUsonic.	args := aMorph blockArgs.	trig := self pinString: args first evaluate asNumberNoError.	echo := self pinString: args second evaluate asNumberNoError.	stream nextPutAll: (USonicModule2 initTrig: trig echo: echo)! !!MicrobitCode methodsFor: 'sensor blocks'!usonicDistance: aMorph 	^ USonicModule2 distance! !!MicrobitModule methodsFor: 'testing' stamp: 'EiichiroIto 3/27/2021 16:15'!isExtModule	^ false! !!ExtModule methodsFor: 'accessing' stamp: 'EiichiroIto 3/28/2021 16:23'!fileContents	self subclassResponsibility! !!ExtModule methodsFor: 'accessing' stamp: 'EiichiroIto 3/27/2021 16:19'!filename	^ self moduleName , '.py'! !!ExtModule methodsFor: 'initialization' stamp: 'EiichiroIto 3/28/2021 16:58'!initialize	super initialize.	moduleName := self class moduleName! !!ExtModule methodsFor: 'testing' stamp: 'EiichiroIto 3/27/2021 16:18'!isExtModule	^ true! !!ExBoardModule methodsFor: 'accessing'!fileContents	^ 'from microbit import i2c, sleepAddr=64def init():    i2c.write(Addr,bytes([0,0]))    oldmode = (i2c.read(Addr,1))[0]    newmode = ((oldmode & 127) | 16)    i2c.write(Addr,bytes([0,newmode]))    i2c.write(Addr,bytes([254,121]))    i2c.write(Addr,bytes([0,oldmode]))    sleep(5)    i2c.write(Addr,bytes([0,(oldmode | 161)]))def servo(ch, deg):    tmp = round(((((deg * 10) + 600) * 4095) / 20000))    pxt = [0]*5    pxt[0]=6 + (4 * (16 - ch))    pxt[3]=tmp & 255    pxt[4]=(int(tmp) >> int(8)) & 255    i2c.write(Addr,bytes(pxt))def motor(ch, speed):    tmp = speed * 16    tmp = min(tmp,4095)    tmp = max(tmp,-4095)    tmp2 = 0    if (tmp < 0):        tmp2 = -tmp        tmp = 0    pxt = [0]*5    pxt[0]=6 + (4 * (((4 - ch) * 2) + 1))    pxt[3]=tmp & 255    pxt[4]=(int(tmp) >> int(8)) & 255    i2c.write(Addr,bytes(pxt))    pxt = [0]*5    pxt[0]=6 + (4 * ((4 - ch) * 2))    pxt[3]=tmp2 & 255    pxt[4]=(int(tmp2) >> int(8)) & 255    i2c.write(Addr,bytes(pxt))'! !!MicrobitModule class methodsFor: 'instance creation' stamp: 'EiichiroIto 3/28/2021 16:32'!exBoard	^ ExBoardModule new! !!MicrobitModule class methodsFor: 'instance creation' stamp: 'EiichiroIto 3/28/2021 17:01'!usonic	^ USonicModule2 new! !!ExBoardModule class methodsFor: 'accessing' stamp: 'EiichiroIto 3/29/2021 13:39'!init	^ self moduleName , '.init()'! !!ExBoardModule class methodsFor: 'accessing' stamp: 'EiichiroIto 3/28/2021 16:58'!moduleName	^ 'exboard'! !!ExBoardModule class methodsFor: 'accessing' stamp: 'EiichiroIto 3/28/2021 17:14'!motorChannel: aString1 speed: aString2 	^ self moduleName , '.motor(' , aString1 , ',' , aString2 , ')'! !!ExBoardModule class methodsFor: 'accessing'!servoChannel: aString1 degrees: aString2 	^ self moduleName , '.servo(' , aString1 , ',' , aString2 , ')'! !!MicrobitSpriteMorph methodsFor: 'list names'!touchPinNames	^ #(pin0 pin1 pin2)! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 3/29/2021 12:41'!exMotorCh: anInteger speed: anInteger2	! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 3/29/2021 12:41'!exServoCh: anInteger degrees: anInteger2! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 3/29/2021 12:40'!i2cWrite: addr data: list	! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 3/29/2021 12:40'!i2cWrite: addr data: data1 and: data2	! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 3/29/2021 12:40'!i2cWrite: addr data: data1 and: data2 and: data3	! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 3/29/2021 13:40'!initExBoard	! !!MicrobitSpriteMorph methodsFor: 'io blocks'!pinIsTouched: anInteger	^ false! !!ReporterBlockMorph methodsFor: 'microwitch'!evaluate	| frame |	frame := self ownerThatIsA: ScratchFrameMorph.	frame ifNil: [^ super evaluate].	frame mpboard isConnecting ifFalse: [^ super evaluate].	^ frame evaluate: self! !!ScratchFrameMorph methodsFor: 'menu/button actions'!fileMenu: aMenuTitleMorph	| menu |	menu := CustomMenu new.	menu add: 'New' action: #newScratchProject.	menu add: 'Open' action: #openScratchProject.	menu add: 'Save' action: #saveScratchProjectNoDialog.	menu add: 'Save As' action: #saveScratchProject.	menu addLine.	menu add: 'Write Python program' action: #writePythonProgram.	"menu add: 'Write HEX program' action: #writeHexCode."	Sensor shiftPressed ifTrue: [  "developer menu"		menu addLine.		fillScreenFlag			ifTrue: [				menu add: 'Exit User Mode' action: #fillScreenOff]			ifFalse: [				menu add: 'Enter User Mode' action: #fillScreenOn.				menu add: 'Save Image in User Mode' action: #saveImageForEndUser]].	menu addLine.	menu add: 'Quit' action: #quitScratch.	menu localize.		#(2 4 "5 6 7") do: [:n |		menu labels at: n put:			((menu labels at: n) copyFrom: 1 to: (menu labels at: n) size - 1), ScratchTranslator ellipsesSuffix].	menu invokeOn: self at: aMenuTitleMorph bottomLeft + (0@10).! !!ScratchFrameMorph methodsFor: 'microwitch'!evaluate: aMorph 	| code ret |	code := MicrobitCode new newlineCR; pythonScriptFrom: {aMorph} stageMorph: workPane.	ret := mpboard evaluate: code timeout: 500.	^ ret! !!ScratchFrameMorph methodsFor: 'microwitch'!execute: aMorph 	| code |	code := MicrobitCode new newlineCR; pythonScriptFrom: {aMorph} stageMorph: workPane.	mpboard request: code.	^ code! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 3/28/2021 15:48'!isConnecting	^ mpboard isConnecting! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 3/28/2021 15:29'!isRunning	^ mpboard isRunning! !!ScratchFrameMorph methodsFor: 'microwitch'!microbitMenu: aMenuTitleMorph 	| menu |	menu := CustomMenu new.	mpboard isConnecting		ifTrue: 			[menu add: 'Send to micro:bit' action: #sendMicroPythonScript.			menu add: 'Disconnect from micro:bit' action: #disconnectMicrobit]		ifFalse: [menu add: 'Connect to micro:bit' action: #connectMicrobit].	menu addLine.	menu add: 'initialize micro:bit' action: #uploadFirmware.	menu add: 'show python code' action: #showPythonProgram.	Sensor shiftPressed		ifTrue: 			[menu addLine.			menu add: 'inspect' action: #inspect.			menu add: 'update firmware' action: #updateFirmware].	menu addLine.	menu add: 'About micro:witch' action: #aboutScratch.	menu localize.	menu invokeOn: self at: aMenuTitleMorph bottomLeft + (0 @ 10)! !!ScratchFrameMorph methodsFor: 'microwitch'!sendMicroPythonScript	| script code |	self currentHatBlocks isEmpty ifTrue: [^ self].	self hasDuplicateHatBlocks ifTrue: [^ DialogBoxMorph inform: 'has duplicate hat blocks.' localized].	mpboard isConnecting ifFalse: [^ DialogBoxMorph inform: 'connect before send' localized].	self stopAll.	code := MicrobitCode new newlineCR.	script := code pythonScriptFrom: self currentHatBlocks stageMorph: workPane.	self uploadExternalModules: code externalModules.	mpboard write: script fileNamed: 'main.py'.	mpboard reboot! !!ScratchFrameMorph methodsFor: 'microwitch'!stopIfRunning	mpboard stopTimeout: 1000! !!ScratchFrameMorph methodsFor: 'microwitch'!stopMpBoard	mpboard isConnecting ifTrue: [mpboard stop]! !!ScratchFrameMorph methodsFor: 'microwitch'!uploadExternalModules: aCollection 	aCollection do: [:each | mpboard write: each fileContents ifNotExists: each filename]! !!ScratchFrameMorph methodsFor: 'microwitch'!uploadFirmware	| s path |	self stopAll.	s := WriteStream on: String new.	s nextPutAll: MicrobitCode mainFirmware.	s nextPutAll: MicrobitCode restFirmware.	path := self hexCodePath.	path ifNil: [^ self].	(DialogBoxMorph ask: 'initialize micro:bit?' localized)		ifFalse: [^ self].	self writeString: s contents as: path! !!ScratchFrameMorph methodsFor: 'microwitch'!writePythonProgram	| path |	self currentHatBlocks isEmpty ifTrue: [^ self].	self hasDuplicateHatBlocks		ifTrue: [^ DialogBoxMorph inform: 'has duplicate hat blocks.' localized].	path := self programPathByUser.	path ifNil: [^ self].	self writePythonProgramAs: path.! !!ScratchStageMorph methodsFor: 'scratch processes/events'!startProcessFor: topBlock 	"Start a process to run the given block or stack of blocks. Return the  	new process."	| sequence proc frame mpboard |	sequence := topBlock blockSequence.	sequence first isHatBlock ifTrue: [sequence := sequence allButFirst].	"skip hat block"	topBlock scratchProc ifNotNil: [topBlock stop].	(frame := self ownerThatIsA: ScratchFrameMorph) ifNil: [^ self].	mpboard := frame mpboard.	proc := mpboard isConnecting				ifTrue: [MPBoardProcess new]				ifFalse: [ScratchProcess new].	proc topBlock: topBlock;	 expression: sequence.	topBlock scratchProc: proc.	(runningBlocks includes: topBlock)		ifFalse: [runningBlocks addLast: topBlock].	^ proc! !!ScriptableScratchMorph class methodsFor: 'microwitch'!controlBlocks	^ #(		'control'			('when %m clicked'		S	-)			('subroutine %e'			E	-)			-			('forever'						c	doForever)			('repeat %n'					c	doRepeat 10)			('while %b'					c	doWhile)			('repeat until %b'		c	doUntil)			-			('break'						-	break)			('continue'					-	continue)			-			('if %b'							c	doIf)			('if %b'							c	doIfElse)			-			('call %e'						s	callSubroutine)	)! !!MicrobitSpriteMorph class methodsFor: 'block specs'!additionalControlBlocks	^ #(		'control'			-			('wait %n msecs'			t	mwait:elapsed:from: 1000)			('panic %n'					-	panic: 0)			('nop %s'						-	print:	'')	)! !!MicrobitSpriteMorph class methodsFor: 'block specs'!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	^ self ioBlocks, self ledBlocks, self soundBlocks, self commBlocks, self sensingBlocks, super blockSpecs, self additionalControlBlocks! !!MicrobitSpriteMorph class methodsFor: 'block specs'!ioBlocks	^ #(		'io'			('button %M is pressed'			b		buttonIsPressed:)			('button %M was pressed'		b		buttonWasPressed:)			('count of button %M pressed'		r		countOfButtonPressed:)			-			('digital read pin %n'				r		readDigital: 0)			('digital write pin %n to %n'	-		writeDigital:to: 0 0) 			('analog read pin %n'				r		readAnalog: 0)			('analog write pin %n to %n'	- 		writeAnalog:to: 0 0)			('analog set period pin %n to %n usec'	- setAnalogPeriod:msec: 0 500)			('%T is touched'					b		pinIsTouched: 'pin0')			-			('servo write pin %j to %n degrees'		-		writeServo:to:					0 180)			('servo set pin %j %n msec %n to %n'	-		setServo:msec:min:max:	0	5	100	500)			('servo set pin %j %n msec'					-		setServo:msec:					0	5)			-			('I2C read addr %n'								r	i2cRead:	0)			('I2C write addr %n data %n'				-	i2cWrite:data:	0 0)			('I2C write addr %n data %n %n'			-	i2cWrite:data:and:	0 0 0)			('I2C write addr %n data %n %n %n'	-	i2cWrite:data:and:and:	0 0 0 0)			('I2C write addr %n data %L'				-	i2cWrite:list:	0)			-			('init exboard'								-	initExBoard)			('servo ch %n degrees %n'			-	exServoCh:degrees: 1 90)			('motor ch %n speed %n'				-	exMotorCh:speed: 1 0)		'neoPixel'			('set %n to r %n g %n b %n of NeoPixel pin %k'		-		setNo:r:g:b:neoPixel: 0 255 255 255 '')			('show NeoPixel of pin %k'								-		showNeoPixel:)			('clear NeoPixel of pin %k'								-		clearNeoPixel:)		)! !!MicrobitSpriteMorph class methodsFor: 'block specs'!sensingBlocks	^ #(		'sensing'			('running time'			r	runningTime)			('ticks ms'					r	ticksMs)			('ticks us'					r	ticksUs)			('light'							r	light)			('temperature'				r	temperature)			('%H sensor value'		r	sensorValueOf: 'accelX')			-			('current gesture'		r	currentGesture)			('is gesture %m ?'		b	isGesture: up)			('was gesture %m ?'		b	wasGesture: up)			('gestures'					r	gestures)			-			('calibrate compass'		-	calibrateCompass)			('is calibrated'				b	isCalibrated)			('heading'						r	headingCompass)			('clear calibration'		-	clearCalibration)			('field strength'			r	fieldStrength)			-			('set usonic trig %j echo %j'	-	setUsonicTrig:echo:	1 2)			('usonic distance'		r	usonicDistance)	)! !!USonicModule2 methodsFor: 'accessing'!fileContents	^ 'import utimetrigger = Noneecho = Nonedef init(_trigger, _echo):    global trigger, echo    trigger = _trigger    echo = _echodef _usec_getecho():    global trigger, echo    count = 0    trigger.write_digital(1)    trigger.write_digital(0)    while echo.read_digital() == 0:        utime.sleep_us(1)        count += 1        if count > 1000:            return 0    count = 0    t1 = utime.ticks_us()    while echo.read_digital() > 0:        utime.sleep_us(1)        count += 1        if count > 1000:            return 0    t2 = utime.ticks_us()    return utime.ticks_diff(t2, t1)def distance():    t = _usec_getecho()    return int(340.0 * t / 20000)'! !!USonicModule2 class methodsFor: 'accessing'!distance	^ self moduleName , '.distance()'! !!USonicModule2 class methodsFor: 'accessing'!initTrig: aString1 echo: aString2 	^ self moduleName , '.init(' , aString1 , ',' , aString2 , ')'! !!USonicModule2 class methodsFor: 'accessing' stamp: 'EiichiroIto 3/28/2021 16:59'!moduleName	^ 'usonic'! !!USonicModule2 reorganize!('accessing' fileContents)!ScratchCodeGenerator removeSelector: #codeString!ScratchCodeGenerator removeSelector: #headerStringOf:!ReporterBlockMorph removeSelector: #evaluateUsing:!MicrobitModule class removeSelector: #usonicTrig:echo:!!ExBoardModule reorganize!('accessing' fileContents)!!ExtModule reorganize!('accessing' fileContents filename)('initialization' initialize)('testing' isExtModule)!MicrobitCode removeSelector: #generator:stream:!MicrobitCode removeSelector: #stream:!MicrobitCode removeSelector: #useUsonicTrig:echo:!MPBoardProcess removeSelector: #mpboard:!Object subclass: #MPBoardProcess	instanceVariableNames: 'expression topBlock errorFlag state frameMorph '	classVariableNames: ''	poolDictionaries: ''	category: 'MicroPython-Board'!Smalltalk removeClassNamed: #USonicModule!
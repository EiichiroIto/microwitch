'From MIT Squeak 0.9.4 (June 1, 2003) [No updates present.] on 28 May 2020 at 9:31:34 pm'!Object subclass: #MicrobitModule	instanceVariableNames: 'moduleName '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Translator'!MicrobitModule subclass: #USonicModule	instanceVariableNames: 'trig echo '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Translator'!!MicrobitCode methodsFor: 'code generator'!generateHeaderOf: aWorkpane 	stream nextPutAll: 'import microbit';	 nextPutAll: newlineString.	modules do: [:each | each generateHeaderOn: stream withNewline: newlineString].	stream nextPutAll: newlineString.	self generateInitVarsIn: aWorkpane vars.	self generateInitListsIn: aWorkpane lists.	self generateI2CInit.	self generateServoSettings! !!MicrobitCode methodsFor: 'io blocks'!setUsonicTrigecho: aMorph	| args trig echo |	args := aMorph blockArgs.	trig := args first evaluate asNumberNoError.	echo := args second evaluate asNumberNoError.	self useUsonicTrig: trig echo: echo! !!MicrobitCode methodsFor: 'private'!useMath	modules add: MicrobitModule math.! !!MicrobitCode methodsFor: 'private'!useMusic	modules add: MicrobitModule music.! !!MicrobitCode methodsFor: 'private'!useNeoPixel: anInteger	neoPixels add: anInteger.	modules add: MicrobitModule neopixel.! !!MicrobitCode methodsFor: 'private'!useRadio	modules add: MicrobitModule radio.! !!MicrobitCode methodsFor: 'private'!useRandom	modules add: MicrobitModule random.! !!MicrobitCode methodsFor: 'private'!useUsonicTrig: anInteger1 echo: anInteger2 	modules add: (MicrobitModule usonicTrig: anInteger1 echo: anInteger2)! !!MicrobitCode methodsFor: 'sensor blocks'!usonicDistance: aMorph 	^ USonicModule functionName , '()'! !!MicrobitModule methodsFor: 'accessing'!generateHeaderOn: aStream withNewline: aString 	self generatedCodes do: [:each | aStream nextPutAll: each;		 nextPutAll: aString]! !!MicrobitModule methodsFor: 'accessing' stamp: 'EiichiroIto 5/28/2020 20:34'!moduleName	^ moduleName! !!MicrobitModule methodsFor: 'accessing' stamp: 'EiichiroIto 5/28/2020 20:33'!moduleName: aString	moduleName := aString! !!MicrobitModule methodsFor: 'comparing'!= other 	self == other ifTrue: [^ true].	self class == other class ifFalse: [^ false].	^ moduleName = other moduleName! !!MicrobitModule methodsFor: 'comparing' stamp: 'EiichiroIto 5/28/2020 20:38'!hash	^ moduleName hash! !!MicrobitModule methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self class name;	 nextPut: $(;	 nextPutAll: moduleName asString;	 nextPut: $)! !!MicrobitModule methodsFor: 'private' stamp: 'EiichiroIto 5/28/2020 21:12'!generatedCodes	^ {'import ' , moduleName}! !!MicrobitModule class methodsFor: 'instance creation' stamp: 'EiichiroIto 5/28/2020 20:40'!math	^ self new moduleName: #math;	 yourself! !!MicrobitModule class methodsFor: 'instance creation'!music	^ self new moduleName: #music;	 yourself! !!MicrobitModule class methodsFor: 'instance creation' stamp: 'EiichiroIto 5/28/2020 20:46'!neopixel	^ self new moduleName: #neopixel;	 yourself! !!MicrobitModule class methodsFor: 'instance creation' stamp: 'EiichiroIto 5/28/2020 20:41'!radio	^ self new moduleName: #radio;	 yourself! !!MicrobitModule class methodsFor: 'instance creation' stamp: 'EiichiroIto 5/28/2020 20:40'!random	^ self new moduleName: #random;	 yourself! !!MicrobitModule class methodsFor: 'instance creation'!usonicTrig: anInteger1 echo: anInteger2 	^ USonicModule new trig: anInteger1;	 echo: anInteger2;	 yourself! !!MicrobitSpriteMorph methodsFor: 'io blocks' stamp: 'EiichiroIto 5/28/2020 21:23'!setUsonicTrig: trig echo: echo	self! !!MicrobitSpriteMorph methodsFor: 'sensing ops' stamp: 'EiichiroIto 5/28/2020 21:23'!usonicDistance	^ 0! !!MicrobitSpriteMorph class methodsFor: 'block specs'!ioBlocks	^ #(		'io'			('button %M is pressed'			b		buttonIsPressed:)			('button %M was pressed'		b		buttonWasPressed:)			('count of button %M pressed'		r		countOfButtonPressed:)			-			('digital read pin %n'				r		readDigital: 0)			('digital write pin %n to %n'	-		writeDigital:to: 0 0) 			('analog read pin %n'				r		readAnalog: 0)			('analog write pin %n to %n'	- 		writeAnalog:to: 0 0)			('analog set period pin %n to %n usec'	- setAnalogPeriod:msec: 0 500)			('pin %n is touched'					b		pinIsTouched: 0)			-			('servo write pin %j to %n degrees'		-		writeServo:to:					0 180)			('servo set pin %j %n msec %n to %n'	-		setServo:msec:min:max:	0	5	100	500)			('servo set pin %j %n msec'					-		setServo:msec:					0	5)			-			('I2C read addr %n'					r	i2cRead:	0)			('I2C write addr %n data %L'	-	i2cWrite:list:	0)			-			('set usonic trig %n echo %n'	-	setUsonicTrig:echo:	1 2)		'neoPixel'			('set %n to r %n g %n b %n of NeoPixel pin %k'		-		setNo:r:g:b:neoPixel: 0 255 255 255 '')			('show NeoPixel of pin %k'								-		showNeoPixel:)			('clear NeoPixel of pin %k'								-		clearNeoPixel:)		)! !!MicrobitSpriteMorph class methodsFor: 'block specs'!sensingBlocks	^ #(		'sensing'			('running time'			r	runningTime)			('light'							r	light)			('temperature'				r	temperature)			('%H sensor value'		r	sensorValueOf: 'accelX')			-			('current gesture'		r	currentGesture)			('is gesture %m ?'		b	isGesture: up)			('was gesture %m ?'		b	wasGesture: up)			('gestures'					r	gestures)			-			('calibrate compass'		-	calibrateCompass)			('is calibrated'				b	isCalibrated)			('heading'						r	headingCompass)			('clear calibration'		-	clearCalibration)			('field strength'			r	fieldStrength)			-			('usonic distance'		r	usonicDistance)	)! !!USonicModule methodsFor: 'accessing' stamp: 'EiichiroIto 5/28/2020 20:51'!echo	^ echo! !!USonicModule methodsFor: 'accessing' stamp: 'EiichiroIto 5/28/2020 20:51'!echo: anInteger	echo := anInteger! !!USonicModule methodsFor: 'accessing' stamp: 'EiichiroIto 5/28/2020 20:51'!trig	^ trig! !!USonicModule methodsFor: 'accessing' stamp: 'EiichiroIto 5/28/2020 20:51'!trig: anInteger	trig := anInteger! !!USonicModule methodsFor: 'comparing'!= other 	self == other ifTrue: [^ true].	self class == other class ifFalse: [^ false].	^ trig = other trig and: [echo = other echo]! !!USonicModule methodsFor: 'comparing'!hash	^ (trig bitShift: 8)		+ echo! !!USonicModule methodsFor: 'initialization' stamp: 'EiichiroIto 5/28/2020 20:56'!initialize	trig := 0.	echo := 0! !!USonicModule methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self class name;	 nextPutAll: '(trig=';	 nextPutAll: trig asString;	 nextPutAll: ',echo=';	 nextPutAll: echo asString;	 nextPut: $)! !!USonicModule methodsFor: 'private'!code	^ 'from microbit import pin{!!trig}from microbit import pin{!!echo}import utimedef ' , self class functionName , '():    count = 0    pin{!!trig}.write_digital(1)    pin{!!trig}.write_digital(0)    while pin{!!echo}.read_digital() == 0:        utime.sleep_us(1)        count += 1        if count > 1000:            return 0    t1 = utime.ticks_us()    count = 0    while pin{!!echo}.read_digital() > 0:        utime.sleep_us(1)        count += 1        if count > 1000:            return 0    t2 = utime.ticks_us()    return int(340.0 * utime.ticks_diff(t2, t1) / 20000)'! !!USonicModule methodsFor: 'private'!generatedCodes	| str |	str := self code copyReplaceAll: '{!!trig}' with: trig asString.	str := str copyReplaceAll: '{!!echo}' with: echo asString.	^ str lines! !!USonicModule class methodsFor: 'private' stamp: 'EiichiroIto 5/28/2020 21:21'!functionName	^ '_usonic_distance'! !!USonicModule reorganize!('accessing' echo echo: trig trig:)('comparing' = hash)('initialization' initialize)('printing' printOn:)('private' code generatedCodes)!!MicrobitModule class reorganize!('instance creation' math music neopixel radio random usonicTrig:echo:)!!MicrobitModule reorganize!('accessing' generateHeaderOn:withNewline: moduleName moduleName:)('comparing' = hash)('printing' printOn:)('private' generatedCodes)!
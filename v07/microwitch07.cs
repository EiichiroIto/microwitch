'From MIT Squeak 0.9.4 (June 1, 2003) [No updates present.] on 2 July 2019 at 8:28:32 pm'!Morph subclass: #ScratchFrameMorph	instanceVariableNames: 'topPane viewerPane scriptsPane stageFrame workPane titlePane libraryPane menuPanel stageButtonsPanel readoutPane logoMorph projectTitleMorph flagButton fillScreenFlag paintingInProgress projectDirectory projectName projectInfo author loginName loginPassword watcherPositions shuffledCostumeNames justSaved viewModeButtons viewMode lastViewMode viewModeButtonsPanel toolbarPanel lastWeDoPoll mpboard '	classVariableNames: 'Clipboard DefaultNotes DefaultSprite Fonts FontsXO IsXO ScratchServers ScratchSkin ScratchSkinXO TakeOverScreen UseErrorCatcher Version VersionDate VisibleDrives WorkpaneExtent '	poolDictionaries: ''	category: 'Scratch-UI-Panes'!!ArgMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator argString: self.! !!Array methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!animateOn: aLed atInterval: anInteger 	aLed animateImages: self interval: anInteger.! !!BlockMorph methodsFor: 'event handling'!rightButtonMenu	| menu |	menu := CustomMenu new.	"menu add: 'help' action: #presentHelpScreen.	(owner isKindOf: ScratchBlockPaletteMorph) ifFalse: [		menu addLine.		menu add: 'duplicate' action: #duplicate.			(self owner isKindOf: BlockMorph) ifFalse: [			menu add: 'delete' action: #delete]]."	DebugMenu ifTrue: [		menu addLine.		menu add: 'show tuples' action: #showTuples].		menu localize; invokeOn: self.! !!BlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:09'!emitCode: aGenerator indent: indent	aGenerator emitBlock: self indent: indent.! !!BlockMorph methodsFor: 'microwitch'!emitTop: aGenerator	^ self! !!BooleanArgMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator booleanArgString: self.! !!ByteArray methodsFor: 'microwitch' stamp: 'EiichiroIto 6/26/2018 07:01'!asHexString	| out |	out := WriteStream on: ''.	self do: [:each | out nextPutAll: each asHexString].	^ out contents! !!CommandBlockMorph methodsFor: 'accessing'!isStop	^ self stopBlocks includes: selector! !!CommandBlockMorph methodsFor: 'evaluation'!coerceArgs: argList	"Answer an arugments array in which all arguments that should be numbers have been coerced to numbers if necessary."	| args specialCommands numFlags |	args := argList asArray.	specialCommands := #(		append:toList: deleteLine:ofList: getLine:ofList: insert:at:ofList: list:contains: setLine:ofList:to:		lookLike: showBackground:		playSound: doPlaySoundAndWait		setVar:to: scrollAndWait animateAndWait).	(specialCommands includes: selector) ifFalse: [		"ensure args are numbers where numbers are expected"		numFlags := self numberArgFlags.		1 to: args size do: [:i |			(numFlags at: i) ifTrue: [args at: i put: (args at: i) asNumberNoError]]].	^ args! !!CommandBlockMorph methodsFor: 'menus'!rightButtonMenu	| menu sFrame choice spec |	menu := CustomMenu new.	"menu add: 'help' action: #presentHelpScreen."	(owner isKindOf: ScratchBlockPaletteMorph) ifFalse: [		menu addLine.		(#(+ - * / \\) includes: selector) ifTrue: [			#(+ - * / mod) with: #(+ - * / \\) do: [:s :op | menu add: s action: op]].		(#(< = >) includes: selector) ifTrue: [			#(< = >) do: [:op | menu add: op action: op]].		(#(& |) includes: selector) ifTrue: [			#(and or) with: #(& |) do: [:s :op | menu add: s action: op]].		menu addLine.		menu add: 'duplicate' action: #duplicate.		(self owner isKindOf: BlockMorph) ifFalse: [  "can't yet delete a blocks inside a script"			menu add: 'delete' action: #delete]].	sFrame := self ownerThatIsA: ScratchFrameMorph.	(sFrame notNil and: [#(sensor: sensorPressed:) includes: selector]) ifTrue: [		menu addLine.		menu add: 'show ScratchBoard watcher' action: #showSensorBoard.		sFrame workPane scratchServer			ifNil: [menu add: 'enable remote sensor connections' action: #enableRemoteSensors]			ifNotNil: [menu add: 'disable remote sensor connections' action: #exitScratchSession]].	DebugMenu ifTrue: [		menu addLine.		menu add: 'show tuples' action: #showTuples].		(choice := menu localize; startUp) ifNil: [^ self].	(#(presentHelpScreen duplicate delete) includes: choice) ifTrue: [^ self perform: choice].	choice = #showSensorBoard ifTrue: [sFrame showSensorBoard. ^ self].	choice = #enableRemoteSensors ifTrue: [sFrame enableRemoteSensors. ^ self].	choice = #exitScratchSession ifTrue: [sFrame exitScratchSession. ^ self].	choice = #showTuples ifTrue: [^ self showTuples].	"change operator"	spec := '%n ', choice, ' %n'.	'\\' = choice	ifTrue: [spec := ScratchTranslator translationFor: '%n mod %n'].	'&' = choice	ifTrue: [spec := ScratchTranslator translationFor: '%b and %b'].	'|' = choice	ifTrue: [spec := ScratchTranslator translationFor: '%b or %b'].	self commandSpec: spec.	self selector: choice.! !!CommandBlockMorph methodsFor: 'private'!uncoloredArgMorphFor: specString	"Answer an argument morph for the given argument specification string."	| code |	code := specString at: 2.	$a = code ifTrue: [^ AttributeArgMorph new choice: 'volume'].	$b = code ifTrue: [^ BooleanArgMorph new].	$c = code ifTrue: [^ ColorArgMorph new showPalette: true].	$C = code ifTrue: [^ LedArgMorph new].	$d = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #directionMenu].	$D = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledClockNames].	$e = code ifTrue: [^ EventTitleMorph new].	$f = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #mathFunctionNames; choice: 'sqrt'].	$g = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledSymbolNames].	$H = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #sensorNames].	$h = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #hookupBooleanSensorNames].	$I = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledArrowNames].	$i = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #listIndexMenu].	$j = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #ioPinMenu].	$k = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #neoPixelPinNames].	$L = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #listVarMenu].	$l = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledCharacterNames].	$m = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #gestureNames].	$M = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #buttonNames].	$n = code ifTrue: [^ ExpressionArgMorph new numExpression: '10'].	$N = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #musicNames].	$s = code ifTrue: [^ ExpressionArgMorph new stringExpression: ''].	$S = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledShapeNames].	$v = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #varNamesMenu; choice: ''].	$W = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #motorDirection].	$x = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #shiftDirection].	$y = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #listIndexForDeleteMenu].	^ ExpressionArgMorph new numExpression: '10'! !!CommandBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!blockArgs	"^ submorphs select: [:m | (m isKindOf: ArgMorph) or: [m isKindOf: ReporterBlockMorph] ]"	^ self organizeArgs: argMorphs asArray! !!CommandBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/26/2019 15:42'!emitTop: aGenerator	aGenerator emitCode: self indent: 0.! !!CommandBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/16/2018 11:33'!stopBlocks	^ #(break continue panic:)! !!CBlockMorph methodsFor: 'private'!addCommandIcons	"Add additional icons to certain blocks. Do nothing if this isn't one of those blocks."	| f |	super addCommandIcons.	(#(doForever doForeverIf doRepeat doUntil doWhile) includes: selector) ifTrue: [		f := ScratchFrameMorph skinAt: #loopIcon ifAbsent: [^ self].		loopMorph := ImageMorph new form: f.		self addMorphBack: loopMorph].! !!CBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:12'!emitCode: aGenerator indent: indent	aGenerator emitCBlock: self indent: indent.! !!CBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:12'!nestedBlock	^ nestedBlock! !!ExpressionArgMorphWithMenu methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator expressionArgWithMenuString: self.! !!ExpressionArgMorphWithMenu methodsFor: 'microwitch' stamp: 'EiichiroIto 6/17/2018 16:31'!ownerSelector	^ owner selector! !!ExpressionArgMorphWithMenu methodsFor: 'microwitch' stamp: 'EiichiroIto 6/17/2018 16:09'!specialValue	^ specialValue! !!HandMorph methodsFor: 'world menu'!openMenu	"Build the open window menu for the world."	| menu |	menu := (MenuMorph entitled: 'open...') defaultTarget: self.	menu addStayUpItem.	menu add: 'browser' action: #openBrowser.	menu add: 'workspace' action: #openWorkspace.	menu add: 'file list' action: #openFileList.	menu add: 'transcript' action: #openTranscript.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'mvc project' action: #openMVCProject.	menu add: 'morphic project' action: #openMorphicProject.	menu addLine.	menu add: 'micro:witch' action: #openScratchFrame.	^ menu! !!HatBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/26/2019 15:38'!emitTop: aGenerator	aGenerator emitHatBlock: self indent: 0.! !!EventHatMorph methodsFor: 'initialization'!initialize	| parts label |	super initialize.	self removeAllMorphs.	parts _ ScratchTranslator labelPartsFor: 'subroutine %e'.	parts first size > 0 ifTrue: [		label _ StringMorph contents: parts first font: (ScratchFrameMorph getFont: #Label).		label color: Color white.		self addMorphBack: label].	scriptNameMorph _ EventTitleMorph new.	self addMorphBack: scriptNameMorph.	parts second size > 0 ifTrue: [		label _ (StringMorph contents: parts second font: (ScratchFrameMorph getFont: #Label)) color: Color white.		self addMorphBack: label].! !!EventHatMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/26/2019 15:38'!emitTop: aGenerator	aGenerator emitEventHatBlock: self indent: 0.! !!IfElseBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:38'!emitCode: aGenerator indent: indent	aGenerator emitIfElseBlock: self indent: indent.! !!IfElseBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:36'!falseBlock	^ falseBlock! !!IfElseBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:35'!trueBlock	^ trueBlock! !!Integer methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!asHexString	^ String with: (self // 16) asHexDigit with: (self \\ 16) asHexDigit! !!LibraryItemMorph methodsFor: 'right button menu'!rightButtonMenu	"Present the right button menu."	| menu |	menu := CustomMenu new.	menu add: 'show' action: #makeVisible.	"menu add: 'export this sprite' action: #exportObject."	menu addLine.	menu add: 'duplicate' action: #duplicateNoAttach.	menu add: 'delete' action: #undoableDeleteSprite.	menu localize; invokeOn: self target.! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!getButton: anObject id: classID 	| count on |	firstPass		ifTrue: 			[count := self readField.			on := self readField.			^ MicrobitButton new privCount: count;			 privOn: on].	anObject privCount: (self targetObjectFor: anObject privCount);	 privOn: (self targetObjectFor: anObject privOn)! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!getImage: anObject id: classID 	| matrix |	firstPass		ifTrue: 			[matrix := self readField.			^ MicrobitImage basicNew privMatrix: matrix].	anObject privMatrix: (self targetObjectFor: anObject privMatrix).! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!getLed: anObject id: classID 	| matrix active |	firstPass		ifTrue: 			[matrix := self readField.			active := self readField.			^ MicrobitLed new privMatrix: matrix;			 active: active].	anObject privMatrix: (self targetObjectFor: anObject privMatrix).	anObject active: (self targetObjectFor: anObject active)! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!putButton: anObject id: classID 	firstPass ifFalse: [stream nextPut: classID].	self putField: anObject privCount.	self putField: anObject privOn.! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!putIOPin: anObject id: classID 	firstPass ifFalse: [stream nextPut: classID].	self putField: anObject mode.	self putField: anObject status.! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 7/12/2018 21:46'!putImage: anObject id: classID 	firstPass ifFalse: [stream nextPut: classID].	self putField: anObject privMatrix.! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!putLed: anObject id: classID 	firstPass ifFalse: [stream nextPut: classID].	self putField: anObject matrix.	self putField: anObject active.! !!ObjStream class methodsFor: 'class initialization'!fixedFormatClasses	"Answer an array of records for fixed-format classes."	^ #(		"id	class					read selector		write selector"		(1	UndefinedObject			getConst:id:			putConst:id:)		(2	True					getConst:id:			putConst:id:)		(3	False					getConst:id:			putConst:id:)		(4	SmallInteger			getSmallInt:id:		putSmallInt:id:)		(5	SmallInteger16			getSmallInt:id:		putSmallInt:id:)  "optimization for ints that fit into 16 bits"		(6	LargePositiveInteger		getBigInt:id:			putBigInt:id:)		(7	LargeNegativeInteger	getBigInt:id:			putBigInt:id:)		(8	Float					getFloat:id:			putFloat:id:)		(9	String					getBytes:id:			putBytes:id:)		(10	Symbol					getBytes:id:			putBytes:id:)		(11	ByteArray				getBytes:id:			putBytes:id:)		(12	SoundBuffer			getSoundBuf:id:		putSoundBuf:id:)		(13	Bitmap					getBitmap:id:		putBitmap:id:)		(14	UTF8					getBytes:id:			putBytes:id:)	"12-19 reserved for additional non-pointer objects"		(20	Array					getArray:id:			putArray:id:)		(21	OrderedCollection		getCollection:id:		putCollection:id:)		(22	Set						getCollection:id:		putCollection:id:)		(23	IdentitySet				getCollection:id:		putCollection:id:)		(24	Dictionary				getDict:id:			putDict:id:)		(25	IdentityDictionary		getDict:id:			putDict:id:)	"26-29 reserved for additional collections"		(30	Color					getColor:id:			putColor:id:)		(31	TranslucentColor		getColor:id:			putColor:id:)		(32	Point					getPoint:id:			putPoint:id:)		(33	Rectangle				getRect:id:			putRect:id:)		(34	Form					getForm:id:			putForm:id:)		(35	ColorForm				getForm:id:			putForm:id:)		(36	MicrobitIOPin		getIOPin:id:			putIOPin:id:)		(37	MicrobitLed			getLed:id:				putLed:id:)		(38	MicrobitButton	getButton:id:		putButton:id:)		(39	MicrobitImage		getImage:id:			putImage:id:)	"99 reserved for object references"	"100-255 reserved for user-defined classes"	)! !!ObjStream class methodsFor: 'class initialization'!userClasses	"Answer an array of (<class id>, <class name>) records for all version numbered user classes."	"The following finds obsolete user classes:"	"self initialize. self userClasses reject: [:rec | Smalltalk includesKey: rec second]"	^ #(		"id		class"		(100		Morph)		(101		BorderedMorph)		(102		RectangleMorph)		(103		EllipseMorph)		(104		AlignmentMorph)		(105		StringMorph)		(106		UpdatingStringMorph)		(107		SimpleSliderMorph)		(108		SimpleButtonMorph)		(109		SampledSound)		(110		ImageMorph)		(111		SketchMorph)		"(120	SpriteMorph)"		"(121		SoundMorph)"		"(122	ImageBoxMorph)"		(123		SensorBoardMorph)		(124		ScratchSpriteMorph)		(125		ScratchStageMorph)		(126		MicrobitSpriteMorph)		(127		MicrobitLedMorph)		(128		MicrobitButtonMorph)		(129		NeoPixelBlockMorph)		(140		ChoiceArgMorph)		(141		ColorArgMorph)		(142		ExpressionArgMorph)		"(143	ParameterReferenceMorph)"		"(144	PositionArgMorph)"		(145		SpriteArgMorph)		"(146	VariableArgMorph)"		(147		BlockMorph)		(148		CommandBlockMorph)		(149		CBlockMorph)		"(150	MethodCallBlockMorph)"		(151		HatBlockMorph)		"(152	ScratchButtonMorph)"		(153		ScratchScriptsMorph)		(154		ScratchSliderMorph)		(155		WatcherMorph)		"(156	ParameterMorph)"		(157		SetterBlockMorph)		(158		EventHatMorph)		"(159	EventArgMorph)"		(160		VariableBlockMorph)		"(161		IACTHatBlock)"		(162		ImageMedia)		(163		MovieMedia)		(164		SoundMedia)		(165		KeyEventHatMorph)		(166		BooleanArgMorph)		(167		EventTitleMorph)		(168		MouseClickEventHatMorph)		(169		ExpressionArgMorphWithMenu)		(170		ReporterBlockMorph)		(171		MultilineStringMorph)		(172		ToggleButton)		(173		WatcherReadoutFrameMorph)		(174		WatcherSliderMorph)		(175		ScratchListMorph)		(176		ScrollingStringMorph)	)! !!ReporterBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator reporterArgString: self.! !!ReporterBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/16/2018 08:58'!canBecomeWatcher	^ false! !!ReporterBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2019 21:06'!emitTop: aGenerator	aGenerator emitReporter: self.! !!ReporterBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/26/2019 21:04'!evaluate	| frame mpboard |	frame := self ownerThatIsA: ScratchFrameMorph.	frame		ifNotNil: 			[mpboard := frame mpboard.			mpboard isConnecting ifTrue: [^ self evaluateUsing: mpboard]].	^ super evaluate! !!ReporterBlockMorph methodsFor: 'microwitch'!evaluateUsing: mpboard 	| stage code ret |	stage := self receiver ownerThatIsA: ScratchStageMorph.	stage		ifNil: 			[^ nil].	code := MicrobitCode new newlineCR; pythonScriptFrom: {self} stageMorph: stage.	ret := mpboard evaluate: code timeout: 500.	^ ret! !!ScratchCodeGenerator methodsFor: 'arg generator'!expressionArgWithMenuString: aMorph 	^ target expressionArgWithMenuString: aMorph! !!ScratchCodeGenerator methodsFor: 'arg generator'!imageString: aLedArgMorph 	^ target imageString: aLedArgMorph.! !!ScratchCodeGenerator methodsFor: 'code generator'!emitCode	hats do: 		[:each | 		each emitTop: self.		target generateLineFeed]! !!ScratchCodeGenerator methodsFor: 'code generator'!emitReporter: aMorph	| code |	code := self reporterArgString: aMorph.	target generateReporter: code.! !!ScratchFileChooserDialog class methodsFor: 'accessing'!userScratchProjectsDir	"Return the path to the user's 'Scratch' project folder, usually located inside the user's 'Documents' folder. If the folder does not already exists, attempt to create it. If the .ini file specifies an alternate home directory, create the folder there. If the directory can't be created, return the user's home folder."	| scratchFolderName homeDir |	scratchFolderName _ 'microwitch'.  "if this were localized a user could get multiple project folders for different languages..."	homeDir _ self homeDir.	"try to create Scratch Projects folder in the user's homeDir"	(homeDir directoryExists: scratchFolderName) ifFalse: [		[homeDir createDirectory: scratchFolderName] ifError: []].	^ (homeDir directoryExists: scratchFolderName)		ifTrue: [homeDir directoryNamed: scratchFolderName]		ifFalse: [homeDir]! !!ScratchFrameMorph methodsFor: 'intialization'!createMenuPanel	"Create and add a panel containing the menus and close button."	| menuSpecs m |	"create panel"	menuPanel := AlignmentMorph new		color: Color transparent;		centering: #center;		inset: 0;		height: 0.	"will grow as needed"	self addShortcutButtonsTo: menuPanel.	"menuSpecs defines the menus"	menuSpecs := #(		"name			selector"		(File			fileMenu:)		(Edit			editMenu:)		(Device		microbitMenu:)	).	menuSpecs do: [:spec |		m := ScratchMenuTitleMorph new			contents: (spec at: 1) localized;			target: self selector: (spec at: 2).		menuPanel addMorphBack: m.		#helpMenu: = (spec at: 2) ifFalse: [			menuPanel addMorphBack: (Morph new color: Color transparent; extent: 12@5)]].	topPane addMorph: menuPanel.! !!ScratchFrameMorph methodsFor: 'intialization'!createReadoutPane	"Create and add my presentation mode button, new sprite buttongs, and mouse readout pane."	| xyReadout |	readoutPane := ImageFrameMorph new initFromForm: (ScratchFrameMorph skinAt: #mouseReadoutPane).	xyReadout := self makeXYReadout.	readoutPane	 addMorph: xyReadout.	"make pane sticky so clicking on it doesn't pick up entire frame"	"self addMorph: (readoutPane isSticky: true)."! !!ScratchFrameMorph methodsFor: 'intialization'!createStageButtonsPanel	"Create and add a panel containing the project title, green flag, and stop buttons."	| buttonSpecs bName button |	"create panel"	stageButtonsPanel := AlignmentMorph new		color: Color transparent;		centering: #center;		height: 20.	projectTitleMorph := StringMorph new		forceUnicodeRendering: true;		contents: '';		font: (ScratchFrameMorph getFont: #FrameMorphProjectTitle).	stageButtonsPanel		addMorphBack: projectTitleMorph;		addMorphBack: (AlignmentMorph newSpacer: Color transparent).	"buttonSpecs defines the toolbar buttons; first is icon name, second is selector"	buttonSpecs := #(		"name	selector		tool tip"		(go		shoutGo		'Start green flag scripts')		(stop	stopAll		'Stop everything')		(send	sendMicrobit	'Send to micro:bit')).	buttonSpecs do: [:spec |		bName := spec first.		button := ToggleButton			onForm: (ScratchFrameMorph skinAt: (bName, 'ButtonGrayPressed') asSymbol)			offForm: (ScratchFrameMorph skinAt: (bName, 'ButtonGray') asSymbol)			overForm: (ScratchFrameMorph skinAt: (bName, 'ButtonGrayPressed') asSymbol).		button			target: self;			actionSelector: (spec at: 2);			isMomentary: true;			setProperty: #balloonText toValue: (spec at: 3) localized.		stageButtonsPanel addMorphBack: button.		bName = #go ifTrue: [			flagButton := button.			stageButtonsPanel addMorphBack: (Morph new color: Color transparent; extent: 2@5)]].	titlePane addMorph: stageButtonsPanel.! !!ScratchFrameMorph methodsFor: 'intialization'!createToolbar	"Create and add the toolbar."	| buttonSpecs bName button |	toolbarPanel := AlignmentMorph new		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent.			buttonSpecs := #(		"name			selector"			"tooltip"		(copy			copyTool		'Duplicate')		(delete			cutTool			'Delete')		(zoomIn 		zoomInTool		'Grow sprite')		(zoomOut 		zoomOutTool		'Shrink sprite')	).	buttonSpecs do: [:spec |		bName := spec at: 1.		button := ToggleButton			onForm: (ScratchFrameMorph skinAt: (bName, 'ButtonPressed') asSymbol)			offForm: (ScratchFrameMorph skinAt: (bName, 'Button') asSymbol)			overForm: (ScratchFrameMorph skinAt: (bName, 'ButtonOver') asSymbol).		button			target: self;			actionSelector: (spec at: 2);			isMomentary: true;			setProperty: #balloonText toValue: (spec at: 3) localized.		toolbarPanel addMorphBack: button].	"self addMorph: toolbarPanel."! !!ScratchFrameMorph methodsFor: 'intialization'!createViewModeButtonsPanel	| specs bName button |	viewModeButtonsPanel := AlignmentMorph newRow		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent.	viewModeButtons := OrderedCollection new.	specs := OrderedCollection new.	specs add: #(quarter			enterQuarterMode		'Switch to small stage').	specs add: #(normal			enterNormalMode		'Switch to full stage').	"specs add: #(presentation	enterPresentationMode	'Switch to presentation mode')."	specs do: [:spec |		bName := spec first.		button := ToggleButton new			onForm: (ScratchFrameMorph skinAt: bName, 'ViewModeOn')			offForm: (ScratchFrameMorph skinAt: bName, 'ViewMode')			overForm: (ScratchFrameMorph skinAt: bName, 'ViewModeOver').		button			target: self;			actionSelector: (spec at: 2);			alphaOn: true;			setProperty: #balloonText toValue: (spec at: 3) localized.		viewModeButtonsPanel			addMorphBack: button;			addMorphBack: (Morph new extent: 1@5; color: Color transparent).		viewModeButtons add: button].	self addMorph: viewModeButtonsPanel.! !!ScratchFrameMorph methodsFor: 'intialization'!initialize	super initialize.	fillScreenFlag _ false.	paintingInProgress _ false.	projectInfo _ Dictionary new.	watcherPositions _ Dictionary new.	justSaved _ false.	author _ ''.	loginName _ ''.	loginPassword _ ''.	viewMode _ #normal.	mpboard := MicroPythonBoard new.	self createBasicPanes.	self createLogo.	self createMenuPanel.	self createViewModeButtonsPanel.	self createStageButtonsPanel.	self createToolbar.	self extent: 1000@600.! !!ScratchFrameMorph methodsFor: 'menu/button actions'!aboutScratch	| dialogBox |	dialogBox := DialogBoxMorph new		title: 'About micro:witch';		withButtonsForYes: false no: false okay: true cancel: false.	dialogBox		message: 'micro:witch version 0.3Copyright 2018 Eiichiro Ito.All rights reserved.https://github.com/EiichiroIto/microwitchBased on Scratch from the MIT Media Lab, v', Version, 'Copyright © 2009 Massachusetts Institute of Technology.All rights reserved.http://info.scratch.mit.edu/Source_Code'		font: (ScratchFrameMorph getFont: #AboutScratch).	dialogBox getUserResponse.! !!ScratchFrameMorph methodsFor: 'menu/button actions'!editMenu: aMenuTitleMorph	| menu |	menu := CustomMenu new.	menu add: 'Undelete' action: #undoTool.	"menu addLine.	ScratchProcess blockHighlightMSecs <= 1		ifTrue: [menu add: 'Start Single Stepping' action: #toggleSingleStepping]		ifFalse: [menu add: 'Stop Single Stepping' action: #toggleSingleStepping].	menu add: 'Set Single Stepping' action: #setSingleStepping.	menu addLine.	menu add: 'Compress Sounds' action: #compressSounds.	menu add: 'Compress Images' action: #compressImages."	menu localize.	"#(3 4 5) do: [:n |		menu labels at: n put:			((menu labels at: n) copyFrom: 1 to: (menu labels at: n) size - 1), ScratchTranslator ellipsesSuffix]."	menu invokeOn: self at: aMenuTitleMorph bottomLeft + (0@10).! !!ScratchFrameMorph methodsFor: 'menu/button actions'!fileMenu: aMenuTitleMorph	| menu |	menu := CustomMenu new.	menu add: 'New' action: #newScratchProject.	menu add: 'Open' action: #openScratchProject.	menu add: 'Save' action: #saveScratchProjectNoDialog.	menu add: 'Save As' action: #saveScratchProject.	"menu addLine.	menu add: 'Import Project' action: #importScratchProject.	menu add: 'Export Sprite' action: #exportSprite.	menu addLine.	menu add: 'Project Notes' action: #editNotes."	Sensor shiftPressed ifTrue: [  "developer menu"		"menu addLine.		menu add: 'Write Project Summary' action: #writeSummaryFile.		menu add: 'Write Multiple Project Summaries' action: #writeMultipleSummaries."		menu addLine.		fillScreenFlag			ifTrue: [				menu add: 'Exit User Mode' action: #fillScreenOff]			ifFalse: [				menu add: 'Enter User Mode' action: #fillScreenOn.				menu add: 'Save Image in User Mode' action: #saveImageForEndUser]].	menu addLine.	menu add: 'Quit' action: #quitScratch.	menu localize.		#(2 4 "5 6 7") do: [:n |		menu labels at: n put:			((menu labels at: n) copyFrom: 1 to: (menu labels at: n) size - 1), ScratchTranslator ellipsesSuffix].	menu invokeOn: self at: aMenuTitleMorph bottomLeft + (0@10).! !!ScratchFrameMorph methodsFor: 'menu/button actions'!shoutGo	"Broadcasts the start event to all objects and processes."	mpboard isConnecting		ifTrue: [mpboard reboot]		ifFalse: 			[self stopAll.			workPane broadcastEventNamed: 'Scratch-StartClicked' with: 0].	flagButton on.	World displayWorldSafely.	"force button flash"	Delay waitMSecs: 20! !!ScratchFrameMorph methodsFor: 'menu/button actions'!stopAll	"Tell my workPane to stop everything."	| oldJustSaved |	oldJustSaved := justSaved.	workPane stopAll.	self stopMpBoard.	justSaved := oldJustSaved.! !!ScratchFrameMorph methodsFor: 'stepping'!step	"Run each process until it gives up control, then filter out any processes that have terminated."	| screenExtent oldJustSaved |	fillScreenFlag ifTrue: [		screenExtent _ Display extent.		((self position = (0@0)) and: [self extent = screenExtent]) ifFalse: [			oldJustSaved _ justSaved.			self position: 0@0.			self extent: screenExtent.			self enterQuarterModeIfSmallScreen.			scriptsPane currentCategory: scriptsPane currentCategory.			justSaved _ oldJustSaved.			^ self]].	workPane ifNotNil: [		ScriptableScratchMorph scratchOrigin: workPane center.		viewerPane target isNil 			ifTrue: [workPane viewBlocksAndScripts]			ifFalse: [viewerPane target isInWorld ifFalse: [workPane viewBlocksAndScripts]]].	Sensor processOSMenuEvents.	paintingInProgress ifTrue: [^ self].	workPane scratchServer ifNotNil: [workPane scratchServer stepServer].	mpboard ifNotNil: [mpboard step].	self checkForWeDo.	self updateToolButtons.	self processWhenConditions.	self processKeyboardEvents.	workPane stepProcesses.	workPane scratchServer ifNotNil: [workPane scratchServer stepServer].	self processDroppedFiles.	workPane processesToRun size > 0		ifTrue: [flagButton on]		ifFalse: [flagButton off].! !!ScratchFrameMorph methodsFor: 'other'!delete	mpboard closePort.	World activeHand toolType: nil.	super delete.! !!ScratchFrameMorph methodsFor: 'startup'!startup	| startupFileNames fileName arg presentationMode |	HostSystemMenus startUp.	HostSystemMenus menuBarControler reviseHostMenus.	ScriptableScratchMorph randomInit.	ScratchTranslator detectRenderPlugin.	ScratchTranslator importLanguagesList.	self processSettingsFile.	self readDefaultNotes.	self updateProjectName.	shuffledCostumeNames := nil.	author := ''.	loginName := ''.	loginPassword := ''.	justSaved := true.	presentationMode := false.	startupFileNames := InputSensor startupFileNames asOrderedCollection.	2 to: 10 do: [:i |		arg := Smalltalk getSystemAttribute: i.		(arg notNil and: [arg size > 0]) ifTrue: [			startupFileNames addLast: (ScratchPlugin primShortToLongPath: arg)]].	startupFileNames do: [:n |		(n asLowercase = 'presentation') ifTrue: [presentationMode := true].		(n asLowercase = 'fullscreen') ifTrue: [TakeOverScreen := true]].	TakeOverScreen ifTrue: [		Smalltalk fullScreenMode: true.		World restoreDisplay].	self enterQuarterModeIfSmallScreen.	fileName := startupFileNames		detect: [:fn |			(fn asLowercase endsWith: '.sb') or: [fn asLowercase endsWith: '.scratch']]		ifNone: [nil].	fileName ifNotNil: [		presentationMode ifTrue: [Display fillColor: Color black].		self openScratchProjectNamed: fileName.		presentationMode ifTrue: [self enterPresentationMode; shoutGo].		^ self].	viewerPane currentCategory: 'io'.	self setDefaultSprite.	self newScratchProject.	fileName := startupFileNames		detect: [:fn | fn asLowercase endsWith: '.sprite']		ifNone: [^ self].	"open a .sprite file"	workPane submorphs do: [:m | (m isKindOf: ScratchSpriteMorph) ifTrue: [m deleteSprite]].	self importSpriteOrProject: fileName.! !!ScratchFrameMorph methodsFor: 'private'!fixLayout	| stageExtent xyReadout w |	stageExtent :=		workPane isQuarterSize			ifTrue: [workPane extent // 2]			ifFalse: [workPane extent].	topPane		position: self topLeft;		width: self width;		height: (menuPanel height + 0 max: logoMorph height + 10).	stageFrame		extent: stageExtent + (14@42);		top: topPane bottom;		right: self right.	workPane position: stageFrame topLeft + (4@37).	titlePane		position: stageFrame topLeft + (0@1);		width: stageFrame width - 6;		height: 36.	self fixProjectTitleMorphLayout.	scriptsPane fixLayout.	w := (viewerPane catButtonsExtent x + 17)		within: 40		and: (self width - (scriptsPane bareMinimumWidth + stageFrame width)).	viewerPane position: topPane bottomLeft;		width: w;		height: self bottom - topPane bottom.	scriptsPane		position: viewerPane topRight;		width: self width - (stageFrame width + viewerPane width);		height: self bottom - topPane bottom;		fixLayout.	libraryPane position: stageFrame bottomLeft;		width: (self right - scriptsPane right);		height: self bottom - libraryPane top.	menuPanel		left: logoMorph right + 18;		top: topPane top + ((topPane height - menuPanel height) // 2) + 2.	viewModeButtonsPanel		right: stageFrame right - 8;		top: self top + 7.	stageButtonsPanel		position: (stageFrame left + 10)@(topPane bottom + 5);		width: stageFrame width - 28;		height: (workPane top - stageFrame top) - 8.	xyReadout := readoutPane submorphs at: 1.	readoutPane		width: xyReadout width + 23;		height: xyReadout height + 15;		position: stageFrame bottomRight - ((readoutPane width + 6)@3).	xyReadout position: readoutPane position + (18@5).	toolbarPanel		left: (stageFrame left - 4 max: menuPanel right);		top: self top + ((topPane height - toolbarPanel height) // 2) + 3."	((toolbarPanel right - 5) > viewModeButtonsPanel left)		ifTrue: [toolbarPanel delete]		ifFalse: [			(toolbarPanel owner = self) ifFalse: [				self addMorphFront: toolbarPanel]]."! !!ScratchFrameMorph methodsFor: 'private'!updateProjectName	"Update the project name display in the Scratch title bar."	| s |	projectName ifNil: [projectName := ''].	projectTitleMorph contents: (self nameFromFileName: projectName).	projectTitleMorph contents size > 0		ifTrue: [s := projectTitleMorph contents, '- micro:witch']		ifFalse: [s := 'micro:witch ', Version].	ScratchPlugin primSetWindowTitle: s.	self fixLayout.! !!ScratchFrameMorph methodsFor: 'microwitch'!addMicrobitCommandsTo: menu 	"Add micro:bit commands to the given menu."	menu addLine.	menu add: 'Send to micro:bit' action: #sendMicrobit.	menu add: 'Write Python program' action: #writePythonProgram.	menu add: 'Write HEX program' action: #writeHexCode.	Sensor shiftPressed		ifTrue: 			[menu addLine.			menu add: 'update firmware' action: #updateFirmware].	menu addLine.	mpboard isConnecting		ifTrue: [menu add: 'Disconnect from micro:bit' action: #disconnectMicrobit]		ifFalse: [menu add: 'Connect to micro:bit' action: #connectMicrobit].	menu addLine.	menu add: 'About micro:witch' action: #aboutScratch! !!ScratchFrameMorph methodsFor: 'microwitch'!connectMicrobit	| menu selection |	menu := CustomMenu new.	mpboard portNames do: [:each | menu add: each action: each].	selection := menu startUp.	selection ifNil: [^ self].	mpboard closePort.	mpboard openPort: selection.	mpboard stop.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!currentHatBlocks	^ self scriptsPane target hatBlocks! !!ScratchFrameMorph methodsFor: 'microwitch'!currentStatus	^ mpboard currentState localized! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2019 21:56'!disconnectMicrobit	mpboard disconnect.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!hexCodePath	| path |	path := self hexCodePathByPlugin.	path ifNotNil: [^ path].	^ self hexCodePathByUser! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 07:20'!hexCodePathByPlugin	| dir |	dir := MicrowitchPlugin microbitDevice.	^ dir ifNotNil: [dir , FileDirectory pathNameDelimiter asString , 'firmware.hex']! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!hexCodePathByUser	| path |	path := ScratchFileChooserDialog				chooseNewFileDefault: 'firmware.hex'				title: 'Write HEX program'				type: #hexCode.	^ path = #cancelled ifFalse: [path]! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/13/2018 11:09'!microbitMenu: aMenuTitleMorph 	| menu |	menu := CustomMenu new.	self addMicrobitCommandsTo: menu.	menu localize.	menu invokeOn: self at: aMenuTitleMorph bottomLeft + (0 @ 10)! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/25/2019 14:43'!mpboard	^ mpboard! !!ScratchFrameMorph methodsFor: 'microwitch'!portName	| ret |	ret := mpboard portName.	ret isEmpty ifTrue: [ret _ '(none)'].	^ ret! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!programPathByUser	| path |	path := ScratchFileChooserDialog				chooseNewFileDefault: 'microwitch.py'				title: 'Write Python program'				type: #python.	^ path = #cancelled ifFalse: [path]! !!ScratchFrameMorph methodsFor: 'microwitch'!sendMicrobit	| path script |	mpboard isConnecting		ifTrue: 			[script _ MicrobitCode new newlineCR; pythonScriptFrom: self currentHatBlocks stageMorph: workPane.			self stopAll.			mpboard write: script fileNamed: 'main.py'.			mpboard reboot]		ifFalse: 			[path _ self hexCodePath.			path ifNil: [^ self].			self writeHexCodeAs: path]! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/25/2019 14:34'!stopMpBoard	mpboard isConnecting ifTrue: [mpboard stop].! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!updateFirmware	MicrobitCode readFirmware.	self inform: 'firmware update done'.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writeHexCode	| path |	path := self hexCodePathByUser.	path ifNil: [^ self].	self writeHexCodeAs: path.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writeHexCodeAs: pathName 	| code |	code := MicrobitCode new hexCodeFrom: self currentHatBlocks stageMorph: workPane.	self stopAll.	self writeString: code as: pathName.	Delay waitMSecs: 500.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writePythonProgram	| path |	path := self programPathByUser.	path ifNil: [^ self].	self writePythonProgramAs: path.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writePythonProgramAs: pathName 	| script |	script := MicrobitCode new pythonScriptFrom: self currentHatBlocks stageMorph: workPane.	self stopAll.	self writeString: script as: pathName.	Delay waitMSecs: 500.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 12:42'!writeString: aString as: pathName 	| f dir fName |	dir := FileDirectory default.	FileDirectory splitName: pathName		to: 			[:dir2 :name | 			fName := name.			dir2 isEmpty ifFalse: [dir := FileDirectory on: dir2]].	(dir fileExists: fName)		ifTrue: [dir deleteFileNamed: fName].	f := StandardFileStream fileNamed: pathName.	f ifNil: [^ self].	f nextPutAll: aString.	f close! !!ScratchFrameMorph class methodsFor: 'utilities'!defaultSprite	"Return the default sprite if one was set, or the cat otherwise"	DefaultSprite		ifNotNil: [^ DefaultSprite]		ifNil: [^ MicrobitSpriteMorph new			addMediaItem: (ImageMedia new				mediaName: ('costume' localized, '1');				form: (ScratchFrameMorph skinAt: #defaultSpriteCostume))].! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 16:55'!createCategories	"ScratchFrameMorph createCategories."	self skinAt: #io put: (self skinAt: #motion).	self skinAt: #ioPressed put: (self skinAt: #motionPressed).	self skinAt: #ioOver put: (self skinAt: #motionOver).	self skinAt: #led put: (self skinAt: #looks).	self skinAt: #ledPressed put: (self skinAt: #looksPressed).	self skinAt: #ledOver put: (self skinAt: #looksOver).	self skinAt: #comm put: (self skinAt: #pen).	self skinAt: #commPressed put: (self skinAt: #penPressed).	self skinAt: #commOver put: (self skinAt: #penOver).! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!readDefaultSprite	"ScratchFrameMorph readDefaultSprite."	DefaultSprite := nil.	self readSkinAt: #defaultSpriteCostume from: 'images/sprite1-small.gif'.! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 7/6/2018 13:52'!readMicrowitchButtons	"ScratchFrameMorph readMicrowitchButtons."	ScratchFrameMorph readSkinAt: #sendButtonGray from: 'images/sendButtonGray.gif'.	ScratchFrameMorph readSkinAt: #sendButtonGrayPressed from: 'images/sendButtonGrayPressed.gif'! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!readMicrowitchLogo	"ScratchFrameMorph readMicrowitchLogo"	ScratchFrameMorph readSkinAt: #scratchLogo from: 'images/logo2.gif'.! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 12:14'!readSkinAt: aSymbol from: aString    self skinAt: aSymbol put: (Form fromFileNamed: aString)! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 12:13'!skinAt: aSymbol put: aForm    ScratchSkin at: aSymbol put: aForm! !!ScratchLibraryMorph methodsFor: 'initialization'!buildPanes	"Build my scroll pane."	| bin |	stagePane := Morph new		color: Color transparent;		position: self position + (7@0).	bin := ScratchSpriteLibraryMorph new		color: Color transparent;		borderWidth: 0.	scrollPane := ScrollFrameMorph2 new		color: Color transparent;		contents: bin;		showHorizontalScrollbar: false.	spritePane := Morph new		color: Color gray;		position: self position.	spriteLabel := self buildSpriteLabel.	buttonPane := self makeNewSpriteButtons: (self ownerThatIsA: ScratchFrameMorph).	self addMorph: spritePane.	"self addMorph: spriteLabel."	"self addMorph: buttonPane."	self addMorph: scrollPane.	self addMorph: stagePane.! !!ScratchLibraryMorph methodsFor: 'initialization'!clearLibrary	"Remove all library items. My step method will re-add items for existing objects."	| sFrame |	stagePane removeAllMorphs.	scrollPane contents removeAllMorphs.	scrollPane vScrollRelative: 0.	spriteLabel delete.	spriteLabel := self buildSpriteLabel.	sFrame := self ownerThatIsA: ScratchFrameMorph.	"(sFrame isNil or:	 [sFrame viewMode = #normal]) ifTrue: [		self addMorph: spriteLabel]."	buttonPane delete.	buttonPane := self makeNewSpriteButtons: sFrame.	"self addMorph: buttonPane."	topSectionHeight := ((spriteLabel height + 10) max: 60).	self fixLayout.! !!ScratchListMorph methodsFor: 'list ops'!deleteLineAt: aNumber	| index |	index := aNumber asInteger + 1.	(index > 0 and: [index <= cellMorphs size]) ifFalse: [		lastActivityError := true.		^ self].	index = numberMorphs size ifTrue: [		numberMorphs last delete.		numberMorphs := numberMorphs copyFrom: 1 to: numberMorphs size - 1].	(cellMorphs removeAt: index) delete.	self noteChangeAtIndex: index.! !!ScratchListMorph methodsFor: 'list ops'!insertLine: aString at: aNumber	| index newCell |	index := aNumber asInteger + 1.	(index > 0 and: [index <= (cellMorphs size + 1)]) ifFalse: [		lastActivityError := true.		^ self].	newCell := self createCell: aString.	index = 1		ifTrue: [cellMorphs addFirst: newCell]		ifFalse: [			index > cellMorphs size				ifTrue: [cellMorphs addLast: newCell]				ifFalse: [cellMorphs add: newCell afterIndex: index - 1]].	self noteChangeAtIndex: index.	^ newCell! !!ScratchListMorph methodsFor: 'list ops'!lineAt: aNumber	| index |	index := aNumber asInteger + 1.	(index > 0 and: [index <= cellMorphs size])		ifTrue: [			self noteChangeAtIndex: index.			^ (cellMorphs at: index) firstSubmorph contents asUTF8]		ifFalse: [			lastActivityError := true.			^ ''].! !!ScratchListMorph methodsFor: 'list ops'!setLineAt: aNumber to: newContents	| index |	index := aNumber asInteger + 1.	(index > 0 and: [index <= cellMorphs size]) ifFalse: [		lastActivityError := true.		^ self].	(cellMorphs at: index) firstSubmorph contents: newContents asString.	self noteChangeAtIndex: index.! !!ScratchListMorph methodsFor: 'private'!updateIndices: rightX	| s newNumbers page num cell |	numberMorphs size > cellMorphs size ifTrue: [		cellMorphs size + 1 to: numberMorphs size do: [:i | (numberMorphs at: i) delete].		numberMorphs := numberMorphs copyFrom: 1 to: cellMorphs size].	newNumbers := #().	numberMorphs size < cellMorphs size ifTrue: [		page := scrollPane contents.		s := StringMorph new			color: self indexColor;			font: (ScratchFrameMorph getFont: #Label).		newNumbers := (numberMorphs size + 1 to: cellMorphs size)			collect: [:i | s fullCopy contents: (i - 1) printString].		newNumbers do: [:m | page addMorph: m].		numberMorphs := numberMorphs, newNumbers].	1 to: cellMorphs size do: [:i |		num := numberMorphs at: i.		cell := cellMorphs at: i.		num position: (rightX - num width) @ (cell top + ((cell height - num height) // 2))].! !!ScratchProcess methodsFor: 'microwitch' stamp: 'EiichiroIto 7/2/2018 07:01'!animateAndWait	"Scroll message and block until it has finished scrolling."	| block args message ubit |	block := stackFrame expression.	args := stackFrame arguments.	"first time: send the event and collect a list of processes"	args size = 0		ifTrue: [			message := block args first.			ubit := block receiver.			ubit animate: message]		ifFalse: [			ubit := args first].	"if sound has stopped, pop this frame and we're done"	ubit isAnimating ifFalse: [^ self popStackFrame].	"Set up the wait loop. We need to:		1.  yield to another process		2.  evaluate our termination condition again	Push these onto stack in reverse order."	"2.  evaluate this block again"	"(Remove the current frame and replace it with one that will force the termination condition to be re-evaluated.)"	self popStackFrameNoUnhightlight.	self pushStackFrame: (ScratchStackFrame new		expression: block;		addArgument: ubit).	"1.  yield to another process"	self pushStackFrame: (ScratchStackFrame new shouldYield: true).! !!ScratchProcess methodsFor: 'microwitch' stamp: 'EiichiroIto 7/18/2018 06:09'!callSubroutine	| block args eventName stage procs |	block := stackFrame expression.	args := stackFrame arguments.	"first time: send the event and collect a list of processes"	args size = 0		ifTrue: 			[eventName := block args first asString.			stage := block receiver ownerThatIsA: ScratchStageMorph.			procs := stage broadcastEventNamed: eventName with: 0]		ifFalse: [procs := args first].	"if all processes have stopped, pop this frame and we're done."	(procs select: [:p | p isRunning]) size = 0 ifTrue: [^ self popStackFrame].	"Set up the wait loop. We need to: 	1. yield to another process 	2. evaluate the termination expression again 	Push these onto stack in reverse order."	"2. evaluate this block again"	"(Remove the current frame and replace it with one that will force the 	termination expression to be re-evaluated.)"	self popStackFrameNoUnhightlight.	self pushStackFrame: (ScratchStackFrame new expression: block;		 addArgument: procs).	"1. yield to another process"	self pushStackFrame: (ScratchStackFrame new shouldYield: true).! !!ScratchProcess methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!scrollAndWait	"Scroll message and block until it has finished scrolling."	| block args message ubit |	block := stackFrame expression.	args := stackFrame arguments.	"first time: send the event and collect a list of processes"	args size = 0		ifTrue: [			message := block args first.			ubit := block receiver.			ubit scroll: message]		ifFalse: [			ubit := args first].	"if sound has stopped, pop this frame and we're done"	ubit isScrolling ifFalse: [^ self popStackFrame].	"Set up the wait loop. We need to:		1.  yield to another process		2.  evaluate our termination condition again	Push these onto stack in reverse order."	"2.  evaluate this block again"	"(Remove the current frame and replace it with one that will force the termination condition to be re-evaluated.)"	self popStackFrameNoUnhightlight.	self pushStackFrame: (ScratchStackFrame new		expression: block;		addArgument: ubit).	"1.  yield to another process"	self pushStackFrame: (ScratchStackFrame new shouldYield: true).! !!ScratchScriptEditorMorph methodsFor: 'initialization'!createTabPane	| tabOnForm tabOffForm tabID tabLabel |	"create tab pane"	tabPaneMorph := ScratchTabPaneMorph new.	tabPaneMorph		borderWidth: 0;		color: Color transparent;		targetPane: self.	tabOnForm := (ScratchFrameMorph skinAt: #tabOn).	tabOffForm := (ScratchFrameMorph skinAt: #tabOff).	"add the tabs"	#(Scripts) do: [:spec |		tabID := spec asString.		tabLabel := tabID localized.		tabPaneMorph			createTab: tabID			withLabel: tabLabel			onForm: tabOnForm			offForm: tabOffForm].	"set current tab and add to frame"	tabPaneMorph currentTab: 'Scripts'.	self addMorph: tabPaneMorph.! !!ScratchScriptEditorMorph methodsFor: 'private'!addLockButton	"Add button to set sprite locked status."	self deleteLockButton.	lockButton := ToggleButton		onForm: (ScratchFrameMorph skinAt: #locked)		offForm: (ScratchFrameMorph skinAt: #unlocked).	lockButton		target: self;		actionSelector: #toggleSpriteDraggable;		setBalloonText: 'draggable on website?' localized;		actWhen: #buttonUp;		isMomentary: true;		position: (nameMorph right + 4)@(nameMorph top + ((nameMorph height - lockButton height) / 2)).	"self addMorph: lockButton."	self updateLockButton.! !!ScratchScriptEditorMorph methodsFor: 'private'!addReadouts	"Add readouts for my target's position and direction."	| x y label readout s sFrame |	self deleteReadouts.	readoutMorphs _ OrderedCollection new.	sFrame _ self ownerThatIsA: ScratchFrameMorph.	x _ nameMorph left.	y _ nameMorph bottom + 5.	#(('port' portName) ('status' currentStatus)) do: [:spec |		(ScratchTranslator isRTL and: [(spec at: 1) = 'x' or: [(spec at: 1) = 'y']])			ifTrue: [s _ (':', spec first) asUTF8]			ifFalse: [s _ (spec first localized, ScratchTranslator colonSuffix)].		label _ StringMorph new			contents: s;			font: (ScratchFrameMorph getFont: #XYReadout);			position: x@y.		readout _ (UpdatingStringMorph on: sFrame selector: spec second)			font: (ScratchFrameMorph getFont: #XYReadoutBold);			forceUnicodeRendering: true;			color: (Color gray: 0.2);			contents: '000000000000';  "this sets the readout size"			growable: false;			stepTime: 100;			position: (label right + 4)@y.		ScratchTranslator isRTL ifTrue:[			readout rightJustify: true].		self addMorph: label; addMorph: readout.		readoutMorphs add: label; add: readout.		readout startStepping.		x _ readout right + 2].	ScratchTranslator isRTL ifTrue: [		readoutMorphs reversed do: [: m |			readoutMorphs remove: m.			readoutMorphs add: m]].	penReadout _ Morph new extent: 15@5.	penReadout position: (lockButton right + 4)@(nameMorph top + ((nameMorph height - penReadout height) / 2));		color: Color transparent.	self addMorph: penReadout.	readoutMorphs add: penReadout.	penReadout startStepping.	readoutMorphs _ readoutMorphs asArray.! !!ScratchScriptEditorMorph methodsFor: 'private'!addRotationButtons	"Add buttons to set the rotation style."	| specs x y style button |	self deleteRotationButtons.	(self target respondsTo: #rotationStyle:) ifFalse: [^ self].	specs := #(		(Smooth		'can rotate')		(Flip		'only face left-right')		(None		'don''t rotate')).	x := self left + 13.	y := self top + 18.	specs do: [:pair |		style := pair first.		button := ToggleButton			onForm: (ScratchFrameMorph skinAt: ('rotStyle', style, 'On'))			offForm: (ScratchFrameMorph skinAt: ('rotStyle', style))			overForm: (ScratchFrameMorph skinAt: ('rotStyle', style, 'Over')).		button			target: self;			arguments: (Array with: style);			actionSelector: #setRotationStyle:;			setBalloonText: pair second localized;			actWhen: #buttonDown;			position: x@y.		"self addMorph: button."		rotationButtons := rotationButtons copyWith: button.		y := y + button height + 2].	self updateRotationButtonHighlight.! !!ScratchThread class methodsFor: 'class initialization'!initialize	"self initialize"	SystemCommands := IdentitySet new.	SystemCommands addAll: #(		doForever doForeverIf doIf doRepeat doReturn doWhile		doBroadcastAndWait doPlaySoundAndWait doWaitUntil		scrollAndWait animateAndWait callSubroutine).! !!ScratchThumbnailMorph methodsFor: 'event handling'!handlesMouseDown: evt	^ false! !!ScratchViewerMorph methodsFor: 'initialization'!rebuildCategorySelectors	| catList maxExtent buttons label offForm onForm overForm b pad leftColumnX rightColumnX x y |	catList := #(		io				control		led			sensing		sound		operators		comm		variables).	"First, delete the old category buttons"	submorphs do: [:m | (m isKindOf: ResizableToggleButton2) ifTrue: [m delete]].	"Create new buttons, keeping track of the maximum extent."	maxExtent := 75@0.	buttons := catList collect: [:cat |		label := (ScratchTranslator translationFor: cat asString) capitalized.		offForm := (ScratchFrameMorph skinAt: cat).		onForm := (ScratchFrameMorph skinAt: (cat, 'Pressed')).		overForm := (ScratchFrameMorph skinAt: (cat, 'Over')).		ScratchTranslator isRTL			ifTrue:[				b := ResizableToggleButton2 new					offForm:	(offForm flipBy: #horizontal centerAt: offForm center)					onForm:		(onForm flipBy: #horizontal centerAt: onForm center)					overForm:	(overForm flipBy: #horizontal centerAt: overForm center)]			ifFalse:[				b := ResizableToggleButton2 new					offForm:	offForm					onForm:		onForm					overForm:	overForm].		b			label: label font: (ScratchFrameMorph getFont: #Category);			setLabelColor: Color white;			target: self;			actionSelector: #currentCategory:;			arguments: (Array with: cat);			toggleButtonMode: true;			toggleMode: false.		ScratchTranslator isRTL			ifTrue:[b rightJustifyInset: 10]			ifFalse:[b leftJustifyInset: 10].		maxExtent := maxExtent max: (b extent + (3 @ -6)).		b].	"calculate catButtonsExtent"	pad := 15. "padding on left, right, and betwen the button columns"	catButtonsExtent := ((2 * maxExtent x) + (3 * pad)) @ (((catList size // 2) * (maxExtent y + 6)) + 25).	"place the buttons"	leftColumnX := self left + 12 + pad.	rightColumnX := leftColumnX + maxExtent x + pad.	x := leftColumnX.	y := self top + 17.	1 to: buttons size do: [:i |		b := buttons at: i.		b extent: maxExtent.		self addMorph: (b position: x@y).		i even			ifTrue: [x := leftColumnX. y := y + b height + 6]			ifFalse: [x := rightColumnX]].	self width: catButtonsExtent x.	pageViewer position: self position + (0@catButtonsExtent y).	topSectionHeight := catButtonsExtent y - 4.! !!ScriptableScratchMorph methodsFor: 'list ops'!append: anObject toList: listName	| list |	list := self listNamed: listName ifNone: [^ 0].	list insertLine: (self asListElement: anObject) at: list lineCount.! !!ScriptableScratchMorph methodsFor: 'list ops'!lineNum: lineNum forList: list	| s |	lineNum isNumber ifTrue: [^ lineNum asInteger].	s := lineNum.	s isUnicode ifTrue: [s := String withAll: lineNum].	(s isKindOf: String) ifTrue: [		#first = s ifTrue: [^ 0].		#last = s ifTrue: [^ list lineCount - 1].		#any = s ifTrue: [			list lineCount = 0 ifTrue: [^ 0].			^ (0 to: list lineCount - 1) atRandom].		^ s asNumberNoError].	^ -1! !!ScriptableScratchMorph methodsFor: 'list ops'!listIndexForDeleteMenu	| menu |	menu := CustomMenu new.	#('0' last) do: [:s | menu add: s action: s].	menu addLine.	menu add: #all action: #all.	menu localize.	^ menu! !!ScriptableScratchMorph methodsFor: 'list ops'!listIndexMenu	| menu |	menu := CustomMenu new.	#('0' any last) do: [:s | menu add: s action: s].	menu localize.	^ menu! !!ScriptableScratchMorph methodsFor: 'other ops'!mathFunctionNames	"Answer a collection of math function names."	^ #(		'sqrt'		'sin'		'cos'		'tan'		'asin'		'acos'		'atan'		'log'	)! !!ScriptableScratchMorph methodsFor: 'blocks'!blockFromSpec: spec color: blockColor	"Create a block from the given block specification. Answer nil if I don't implement the block spec selector."	| blockLabelSpec blockType selector defaultArgs block rcvr argPermutation c |	c := blockColor.	blockLabelSpec := ScratchTranslator translationFor: (spec at: 1).	argPermutation := CommandBlockMorph argPermutationForSpec: (spec at: 1) withTranslation: blockLabelSpec.	blockType := spec at: 2.	selector := (spec at: 3) asSymbol.	defaultArgs := self defaultArgsFor: spec.	(#(E K M S W) includes: blockType) ifTrue: [		^ (self hatBlockType: blockType) color: blockColor].	"basic block type: normal or C-shaped"	(blockType includes: $c)		ifTrue:	[			selector = #doIfElse				ifTrue: [block := IfElseBlockMorph new isSpecialForm: true]				ifFalse: [block := CBlockMorph new isSpecialForm: true]]		ifFalse:	[			(blockType includes: $r) | (blockType includes: $b)				ifTrue: [block := ReporterBlockMorph new. c := c darker]				ifFalse: [block := CommandBlockMorph new]].	(blockType includes: $b) ifTrue: [block isBoolean: true].	(blockType includes: $s) ifTrue: [block isSpecialForm: true].	(blockType includes: $t) ifTrue: [block isTimed: true].	(ScriptableScratchMorph isSpriteSpecificTarget: self selector: selector)		ifTrue: [rcvr := self]		ifFalse: [rcvr := self ownerThatIsA: ScratchStageMorph].	^ block		argPermutation: argPermutation;		color: c;		selector: selector;		commandSpec: blockLabelSpec;		defaultArgs: defaultArgs;		receiver: rcvr! !!ScriptableScratchMorph methodsFor: 'blocks'!blockFromTuple: tuple receiver: scriptOwner	"Answer a new block for the given tuple."	| k spec blockColor block argCount arg argBlock |	k := tuple first.	(#(readVariable changeVariable) includes: k) ifTrue: [		^ self variableBlockFromTuple: tuple receiver: scriptOwner].	(#(neoPixel) includes: k) ifTrue: [		^ self neoPixelBlockFromTuple: tuple receiver: scriptOwner].		#contentsOfList: = k ifTrue: [		^ ListContentsBlockMorph new			color: ScriptableScratchMorph listBlockColor;			receiver: scriptOwner;			commandSpec: tuple second;			selector: #contentsOfList:].	(#(EventHatMorph KeyEventHatMorph MouseClickEventHatMorph WhenHatBlockMorph) includes: k) ifTrue: [		block := self hatBlockFromTuple: tuple receiver: scriptOwner.		(block isKindOf: WhenHatBlockMorph) ifTrue: [block color: Color red].		^ block].	#scratchComment = k ifTrue: [		block := ScratchCommentMorph new.		tuple size > 1 ifTrue: [block commentMorph contents: (tuple at: 2)].		tuple size > 2 ifTrue: [(tuple at: 3) ifFalse: [block toggleShowing]].		tuple size > 3 ifTrue: [block width: (tuple at: 4)].		tuple size > 4 ifTrue: [block anchor: (self blockWithID: (tuple at: 5))].		^ block].	#comment: = k ifTrue: [		block := CommentBlockMorph new.		tuple size > 1 ifTrue: [block comment: (tuple at: 2)].		tuple size > 2 ifTrue: [(tuple at: 3) ifFalse: [block toggleShowing]].		block color: (Color r: 0.8 g: 0 b: 0).  "obsolete"		^ block].	spec := BlockSpecDict at: k ifAbsent: [nil].	spec ifNil: [		^ scriptOwner			blockFromSpec: #('obsolete!!' - yourself)			color: Color red].	blockColor := BlockColorDict at: k ifAbsent: [Color red].	block := scriptOwner blockFromSpec: spec color: blockColor.	(block isKindOf: CommandBlockMorph) ifTrue: [		argCount := block argumentCount min: tuple size - 1.		1 to: argCount do: [:i |			((#(+ - / * =) includes: block selector) and: [ScratchTranslator isRTLMath]) "RTLMath operators are RTL"				ifTrue: [arg := tuple at: ((argCount + 1) - (i - 1))]				ifFalse: [arg := tuple at: i + 1].			(arg isKindOf: Array)				ifTrue: [  "argument is a block"					((arg size = 1) and: [arg first isKindOf: Array]) ifTrue: [arg := arg first].					argBlock := self blockFromTuple: arg receiver: scriptOwner.					block replaceArgMorph: (block argumentAt: i) by: argBlock]				ifFalse: [  "argument is a value"					(block argumentAt: i) defaultValue: arg]].		(block isKindOf: CBlockMorph) ifTrue: [			(tuple last isKindOf: Array) ifTrue: [				block firstBlockList: (self stackFromTupleList: tuple last receiver: scriptOwner)]].		(block isKindOf: IfElseBlockMorph) ifTrue: [			arg := tuple at: tuple size - 1.			(arg isKindOf: Array) ifTrue: [				block trueBlock: (self stackFromTupleList: arg receiver: scriptOwner)].			arg := tuple at: tuple size.			(arg isKindOf: Array) ifTrue: [				block falseBlock: (self stackFromTupleList: arg receiver: scriptOwner)]].		(block isKindOf: ReporterBlockMorph) ifTrue: [			((spec at: 2) includes: $b) ifTrue: [block isBoolean: true]]].	^ block! !!ScriptableScratchMorph methodsFor: 'blocks'!defaultArgsFor: blockSpec	"Answer the default argument for the given block specification."	| defaultArgs stage sel currentSize list |	defaultArgs := blockSpec copyFrom: 4 to: blockSpec size.  "may be empty"	stage := self ownerThatIsA: ScratchStageMorph.	sel := (blockSpec at: 3) asSymbol.	#gotoX:y: = sel ifTrue: [		defaultArgs := Array			with: self referencePosition x rounded			with: self referencePosition y rounded].	#glideSecs:toX:y:elapsed:from: = sel ifTrue: [		defaultArgs := Array			with: 1			with: self referencePosition x rounded			with: self referencePosition y rounded].	#motor:direction: = self ifTrue: [		defaultArgs := Array with: 'reverse' localized with: 'this way' localized with: 'that way'].	#setSizeTo: = sel ifTrue: [		currentSize := (100.0 * (self scalePoint x max: self scalePoint y)) rounded.		defaultArgs := Array with: currentSize].	#getAttribute:of: = sel ifTrue: [		(stage := self ownerThatIsA: ScratchStageMorph) ifNotNil: [			list := stage submorphs select: [:m | m isKindOf: ScratchSpriteMorph].			list sort: [:s1 :s2 | s1 objName asLowercase < s2 objName asLowercase].			list size > 0				ifTrue: [defaultArgs := Array with: 'x position' with: list first]				ifFalse: [defaultArgs := Array with: 'background #' with: stage]]		ifNil:[defaultArgs := Array with: 'x position' with: self]].	#concatenate:with: = sel ifTrue: [		defaultArgs := Array with: 'hello ' localized with: 'world' localized].	#doAsk = sel ifTrue: [		defaultArgs := Array with: 'What''s your name?' localized].	#letter:of: = sel ifTrue: [		defaultArgs := Array with: 1 with: 'world' localized].	#stringLength: = sel ifTrue: [		defaultArgs := Array with: 'world' localized].	#say:duration:elapsed:from: = sel ifTrue: [		defaultArgs := Array with: 'Hello!!' localized with: 2].	#say: = sel ifTrue: [		defaultArgs := Array with: 'Hello!!' localized].	#think:duration:elapsed:from: = sel ifTrue: [		defaultArgs := Array with: 'Hmm...' localized with: 2].	#think: = sel ifTrue: [		defaultArgs := Array with: 'Hmm...' localized].	(#(lookLike: showBackground:) includes: sel) ifTrue: [		defaultArgs := Array with: self costumeNames last].	(#(playSound: doPlaySoundAndWait) includes: sel) ifTrue: [		list := self soundNames.		defaultArgs := list size <= 2			ifTrue: [Array with: '']			ifFalse: [Array with: (list at: (list size - 2))]].	(#(broadcast: doBroadcastAndWait) includes: sel) ifTrue: [		stage ifNotNil: [defaultArgs := Array with: stage defaultEventName]].	(#(append:toList: deleteLine:ofList: insert:at:ofList:) includes: sel) ifTrue: [		defaultArgs size >= 1 ifTrue: [			defaultArgs at: 1 put: (defaultArgs at: 1) localized]].	(#(append:toList: deleteLine:ofList: getLine:ofList: insert:at:ofList: lineCountOfList:)		includes: sel) ifTrue: [			defaultArgs := defaultArgs copyWith: self defaultListName].	#setLine:ofList:to: = sel ifTrue: [		defaultArgs size >= 3 ifTrue: [			defaultArgs at: 2 put: self defaultListName.			defaultArgs at: 3 put: (defaultArgs at: 3) localized]].	#appendLettersOf:toList: = sel ifTrue: [		defaultArgs size >= 2 ifTrue: [			defaultArgs at: 1 put: (defaultArgs at: 1) localized.			defaultArgs at: 2 put: self defaultListName]].	#list:contains: = sel ifTrue: [		defaultArgs size >= 2 ifTrue: [			defaultArgs at: 1 put: self defaultListName.			defaultArgs at: 2 put: (defaultArgs at: 2) localized]].	#scrollAndWait = sel ifTrue: [		defaultArgs := Array with: 'Hello!!'].	#animateAndWait = sel ifTrue: [		defaultArgs := Array with: 'A'].	#replaceAllList:with: = sel ifTrue: [		defaultArgs size >= 1 ifTrue: [			defaultArgs at: 1 put: self defaultListName]].	#clearNeoPixel: = sel ifTrue: [		defaultArgs := Array with: self defaultNeoPixelName].	#showNeoPixel: = sel ifTrue: [		defaultArgs := Array with: self defaultNeoPixelName].	#setNo:r:g:b:neoPixel: = sel ifTrue: [		defaultArgs at: 5 put: self defaultNeoPixelName].	#callSubroutine = sel ifTrue: [		stage ifNotNil: [defaultArgs := Array with: stage defaultEventName]].	^ defaultArgs! !!ScriptableScratchMorph methodsFor: 'blocks'!variablesPage	"Answer a morph containing my variables."	| page addButton deleteButton hasVars stage x y maxX |	page := ScratchBlockPaletteMorph new		color: (Color r: 0.8 g: 0.8 b: 1.0);		borderWidth: 0.	addButton := ScratchFrameMorph		buttonLabel: 'Make a variable' localized		selector: #addGlobalVariable.	"(self isKindOf: ScratchSpriteMorph) ifTrue: [addButton actionSelector: #addVariable]."	deleteButton := ScratchFrameMorph		buttonLabel: 'Delete a variable' localized		selector: #deleteVariable.	x := 13.	page addMorph: (addButton target: self; position: x@7).	y := addButton bottom + 3.	hasVars := self varNames size > 0.	(stage := self ownerThatIsA: ScratchStageMorph) ifNotNil: [		stage varNames size > 0 ifTrue: [hasVars := true]].	hasVars ifTrue: [		page addMorph: (deleteButton target: self; position: x@y).		y := deleteButton bottom + 10.		y := self addVariableReportersTo: page x: x y: y.		y := y + 12.		y := self addGenericVariableBlocksTo: page x: x y: y].	self addGenericListBlocksTo: page y: y.	page updateWatcherButtonsForFrame: (self ownerThatIsA: ScratchFrameMorph).	maxX := page submorphs inject: 0 into: [:t :m | t max: m right].	page extent: (maxX + 10) @ y.	^ page! !!ScriptableScratchMorph methodsFor: 'private' stamp: 'EiichiroIto 9/7/2017 12:03'!hatBlocks	^ blocksBin submorphs select: [:m | m isKindOf: HatBlockMorph]! !!ScriptableScratchMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!replaceAllList: listName with: aString 	| list data |	list := self listNamed: listName ifNone: [^ 0].	data := aString findTokens: ' '.	list newContents: data! !!ScriptableScratchMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/19/2018 07:59'!vars	^ vars! !!ScratchSpriteMorph methodsFor: 'right button menu'!rightButtonMenu	"Present the right button menu."	"| menu |	menu := CustomMenu new.	menu add: 'grab screen region for new costume' action: #grabFromScreen.	menu add: 'export this sprite' action: #exportObject.	menu addLine.	menu add: 'duplicate' action: #duplicate.	menu add: 'delete' action: #undoableDeleteSprite.	menu addLine.	menu add: 'resize this sprite' action: #resizeHandle.	menu add: 'rotate this sprite' action: #rotateHandle.	menu localize; invokeOn: self."! !!ScratchStageMorph methodsFor: 'initialization'!initialize	super initialize.	color := Color white.	self enableDragNDrop: true.	objName := 'Stage' localized.	costume := self defaultImageMedia.	media := OrderedCollection with: costume "with: SoundMedia new".	zoom := 1.0.	hPan := 0.	vPan := 0.	runningBlocks := OrderedCollection new.	inProcessStep := false.	sensorBoard := SensorBoardMorph new.	midiPortNum := -1.	notePlayerDict := Dictionary new.	obsoleteSavedState := nil.	sprites := OrderedCollection new.	showMotorBlocks := false.! !!ScratchStageMorph methodsFor: 'scratch processes/events'!startProcessFor: topBlock 	"Start a process to run the given block or stack of blocks. Return the  	new process."	| sequence proc frame mpboard |	sequence := topBlock blockSequence.	sequence first isHatBlock ifTrue: [sequence := sequence allButFirst].	"skip hat block"	topBlock scratchProc ifNotNil: [topBlock stop].	(frame := self ownerThatIsA: ScratchFrameMorph) ifNil: [^ self].	mpboard := frame mpboard.	proc := mpboard isConnecting				ifTrue: [MPBoardProcess new mpboard: mpboard]				ifFalse: [ScratchProcess new].	proc topBlock: topBlock;	 expression: sequence.	topBlock scratchProc: proc.	(runningBlocks includes: topBlock)		ifFalse: [runningBlocks addLast: topBlock].	^ proc! !!ScratchStageMorph methodsFor: 'menus'!rightButtonMenu	"Present the right button menu."	| menu |	menu := CustomMenu new.	menu add: 'new micro:bit sprite' action: #createNewMicrobitSprite.	menu addLine.	menu add: 'save picture of stage...' action: #stageShot.	menu localize; invokeOn: self.! !!ScratchStageMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!createNewMicrobitSprite	| frame morph |	(frame := self ownerThatIsA: ScratchFrameMorph) ifNil: [^ self].	morph := MicrobitSpriteMorph new addMediaItem: (ImageMedia new mediaName: 'costume' localized , '1';				 form: (ScratchFrameMorph skinAt: #defaultSpriteCostume)).	frame addAndView: morph! !!ScriptableScratchMorph class methodsFor: 'block specs'!blockColorFor: aCategory	"Answer the block color for the given category."	'control' = aCategory ifTrue: [^ (Color h: 41 s: 0.85 v: 0.9)].	'io' = aCategory ifTrue: [^ (Color h: 225 s: 0.65 v: 0.83)].	'neoPixel' = aCategory ifTrue: [^ (Color h: 210 s: 0.6 v: 0.9)].	'motor' = aCategory ifTrue: [^ (Color h: 220 s: 0.85 v: 0.725)].	'led' = aCategory ifTrue: [^ (Color h: 264 s: 0.62 v: 0.89)].	'comm' = aCategory ifTrue: [^ (Color h: 165 s: 1 v: 0.63)].	'operators' = aCategory ifTrue: [^ (Color h: 93 s: 0.9 v: 0.76)].	'sound' = aCategory ifTrue: [^ (Color h: 296 s: 0.66 v: 0.85)].	'sensing' = aCategory ifTrue: [^ (Color h: 200 s: 0.98 v: 0.86)].	'variables' = aCategory ifTrue: [^ (Color h: 25 s: 0.88 v: 0.95)].	'list' = aCategory ifTrue: [^ ListBlockColor].	^ (Color h: 0 s: 0.81 v: 0.83)  "a shade of red"! !!ScriptableScratchMorph class methodsFor: 'block specs'!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	^ self controlBlocks, self operatorsBlocks, self variablesBlocks! !!ScriptableScratchMorph class methodsFor: 'other'!isSpriteSpecificTarget: anObject selector: selector	"I determine whether the given selector is specific to a particular Sprite. ."	| i |	true ifTrue: [^ true].	(anObject isKindOf: ScratchSpriteMorph) ifFalse: [^ false].	i := selector asString		findAnySubStr: #('answer' 'key' 'Loud' 'mouse' 'sensor' 'soundLevel' 'tempo' 'timer')		startingAt: 1.	^ i > selector asString size! !!ScriptableScratchMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!controlBlocks	^ #(		'control'			('when %m clicked'				S	-)			-			('forever'						c	doForever)			('repeat %n'					c	doRepeat 10)			('while %b'					c	doWhile)			('repeat until %b'		c	doUntil)			-			('break'						-	break)			('continue'					-	continue)			-			('if %b'							c	doIf)			('if %b'							c	doIfElse)			-			('call %e'						s	callSubroutine)			('subroutine %e'			E	-)	)! !!ScriptableScratchMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!operatorsBlocks	^ #(		'operators'			('%n + %n'						r	x:plusY: - -)			('%n - %n'						r	x:minusY: - -)			('%n * %n'						r	x:mulY: - -)			('%n / %n'						r	x:divY: - -)			('%n mod %n'					r	x:modY: - -)			-			('pick random %n to %n'		r	randomFrom:to: 1 10)			('set random seed to %n'		-	setRandomSeed: 1234)			-			('%s < %s'						b	less:than: '' '')			('%s = %s'						b	equal:to: '' '')			('%s > %s'						b	more:than: '' '')			('%s is None'				b	isNone:)			-			('%b and %b'				b	x:andY:)			('%b or %b'					b	x:orY:)			('not %b'						b	not:)			('true'							b	true)			('false'							b	false)			-			('string of %n'				r	stringOf:	0)			('number of %s'			r	numberOf: '123')			('join %s %s'				r	concatenate:with: 'hello ' 'world')			('letter %n of %s'			r	letter:of: 0 'world')			('length of %s'				r	stringLength: 'world')			('any of %s'					r	anyOf: )			-			('round %n'					r	rounded -)			('abs %n'						r	abs -)			('abs %n sign %n'			r	abs:sign:	- -)			-			('%f of %n'					r	computeFunction:of: 'sqrt' 10)	)! !!ScriptableScratchMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 8/28/2018 14:17'!variablesBlocks	^ #(		'list'			('add %s to %L'					-	append:toList: 'thing')			-			('delete %y of %L'				-	deleteLine:ofList: 0)			('insert %s at %i of %L'			-	insert:at:ofList: 'thing' 0)			('replace item %i of %L with %s'		-	setLine:ofList:to: 0 'list' 'thing')			('replace all items of %L with %s'		- replaceAllList:with: 'list' 'a b c')			-			('item %i of %L'					r	getLine:ofList: 0)			('length of %L'					r	lineCountOfList:)			('%L contains %s'				b	list:contains: 'list' 'thing')	)! !!ScratchSpriteMorph class methodsFor: 'block specs'!blockSpecs	^ super blockSpecs! !!ScratchStageMorph class methodsFor: 'block specs'!blockSpecs	^ super blockSpecs! !!SerialPort2 methodsFor: 'input/output'!nextPut: anInteger	"Send the given byte out this serial port. The port must be open."	^ self nextPutAll: (ByteArray with: anInteger).! !!SerialPort2 methodsFor: 'input/output'!nextPutAll: aStringOrByteArray	"Send the given bytes out this serial port. The port must be open."	self isOpen ifFalse: [^ self].	^ ScratchPlugin writePort: portNum data: aStringOrByteArray.! !!String methodsFor: 'microwitch' stamp: 'EiichiroIto 7/2/2018 21:11'!animateOn: aLed atInterval: anInteger	aLed animateString: self interval: anInteger.! !!String methodsFor: 'microwitch' stamp: 'EiichiroIto 6/19/2018 07:21'!isNumberString	| aStream d pointNumber digitAppears |	pointNumber := false.	digitAppears := false.	aStream := ReadStream on: self.	aStream peek = $- ifTrue: [aStream next].	[aStream atEnd]		whileFalse: 			[d := aStream next.			d = $.				ifTrue: 					[pointNumber ifTrue: [^ false].					pointNumber := true]				ifFalse: [(d < $0 or: [d > $9])						ifTrue: [^ false]						ifFalse: [digitAppears := true]]].	^ digitAppears! !!String class methodsFor: 'instance creation' stamp: 'EiichiroIto 6/13/2018 12:13'!lf	"Answer a string containing a linefeed."	^ self with: Character lf! !!VariableBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator variableArgString: self.! !!WriteStream methodsFor: 'character writing' stamp: 'EiichiroIto 6/13/2018 12:12'!lf	"Append linefeed characters to the receiver."	self nextPutAll: String lf.! !ScratchThread initialize!ScratchThread initialize.ObjStream initialize.ScratchFrameMorph readDefaultSprite.ScratchFrameMorph readMicrowitchLogo.ScratchFrameMorph createCategories.ScratchFrameMorph readMicrowitchButtons.ScriptableScratchMorph buildBlockSpecDictionary.MicrobitImage initialize.!
'From MIT Squeak 0.9.4 (June 1, 2003) [No updates present.] on 29 March 2021 at 3:39:01 pm'!!MicrobitCode methodsFor: 'code generator'!generateHeaderOf: aWorkpane 	stream nextPutAll: 'from microbit import *';	 nextPutAll: newlineString.	modules do: [:each | each generateHeaderOn: stream withNewline: newlineString].	stream nextPutAll: newlineString.	self generateInitVarsIn: aWorkpane vars.	self generateInitListsIn: aWorkpane lists.	self generateI2CInit.	self generateServoSettings! !!MicrobitCode methodsFor: 'code generator'!generateI2CInit	i2c ifTrue: [stream nextPutAll: 'i2c.init()';		 nextPutAll: newlineString].! !!MicrobitCode methodsFor: 'control blocks'!mwaitelapsedfrom: aMorph 	stream nextPutAll: (self unaryFunction: 'sleep' of: aMorph).! !!MicrobitCode methodsFor: 'control blocks'!panic: aMorph	stream nextPutAll: (self unaryFunction: 'panic' of: aMorph).! !!MicrobitCode methodsFor: 'control blocks'!waitMsec: aMorph	stream nextPutAll: (self unaryFunction: 'sleep' of: aMorph).! !!MicrobitCode methodsFor: 'io blocks'!i2cRead: aMorph 	self useI2C.	^ 'i2c.read(' , (aMorph blockArgs first argString: generator) , ',1)'! !!MicrobitCode methodsFor: 'io blocks'!i2cWritedata: aMorph 	| args |	self useI2C.	args := aMorph blockArgs.	stream nextPutAll: 'i2c.write(';	 nextPutAll: (args first argString: generator);	 nextPutAll: ',bytes([';	 nextPutAll: (args second argString: generator);	 nextPutAll: ']))'! !!MicrobitCode methodsFor: 'io blocks'!i2cWritedataand: aMorph 	| args |	self useI2C.	args := aMorph blockArgs.	stream nextPutAll: 'i2c.write(';	 nextPutAll: (args first argString: generator);	 nextPutAll: ',bytes([';	 nextPutAll: (args second argString: generator);	 nextPut: $,;	 nextPutAll: (args third argString: generator);	 nextPutAll: ']))'! !!MicrobitCode methodsFor: 'io blocks'!i2cWritedataandand: aMorph 	| args |	self useI2C.	args := aMorph blockArgs.	stream nextPutAll: 'i2c.write(';	 nextPutAll: (args first argString: generator);	 nextPutAll: ',bytes([';	 nextPutAll: (args second argString: generator);	 nextPut: $,;	 nextPutAll: (args third argString: generator);	 nextPut: $,;	 nextPutAll: (args fourth argString: generator);	 nextPutAll: ']))'! !!MicrobitCode methodsFor: 'io blocks'!i2cWritelist: aMorph 	| args str var |	self useI2C.	args := aMorph blockArgs.	str := args first argString: generator.	var := args second choice.	self useListVar: var.	stream nextPutAll: 'i2c.write('.	stream nextPutAll: str;	 nextPutAll: ',bytes('.	stream nextPutAll: var.	stream nextPutAll: '))'! !!MicrobitCode methodsFor: 'io blocks'!pinIsTouched: aMorph 	^ aMorph blockArgs first evaluate , '.is_touched()'! !!MicrobitCode methodsFor: 'led blocks'!animateAndWait: aMorph 	| str |	stream nextPutAll: 'display.show('.	str := aMorph blockArgs first argString: generator.	stream nextPutAll: str.	stream nextPutAll: ')'! !!MicrobitCode methodsFor: 'led blocks'!arrowImageAt: aMorph	| str |	str := aMorph blockArgs first argString: generator.	^ 'Image.ALL_ARROWS[', str, ']'! !!MicrobitCode methodsFor: 'led blocks'!clearPixels: aMorph	stream nextPutAll: 'display.clear()'.! !!MicrobitCode methodsFor: 'led blocks'!clockImageAt: aMorph	| str |	str := aMorph blockArgs first argString: generator.	^ 'Image.ALL_CLOCKS[', str, ']'! !!MicrobitCode methodsFor: 'led blocks'!getPixelAtxy: aMorph	^ self binaryFunction: 'display.get_pixel' of: aMorph! !!MicrobitCode methodsFor: 'led blocks'!imageOf: aMorph	^ self unaryFunction: 'Image' of: aMorph! !!MicrobitCode methodsFor: 'led blocks'!imageWidthheight: aMorph 	| args |	args := aMorph blockArgs.	^ 'Image(' , (args first argString: generator) , ',' , (args second argString: generator) , ')'! !!MicrobitCode methodsFor: 'led blocks'!isOnLed: aMorph	^ 'display.is_on()'! !!MicrobitCode methodsFor: 'led blocks'!offLed: aMorph	stream nextPutAll: 'display.off()'.! !!MicrobitCode methodsFor: 'led blocks'!onLed: aMorph	stream nextPutAll: 'display.on()'.! !!MicrobitCode methodsFor: 'led blocks'!scroll: aMorph 	| str |	stream nextPutAll: 'display.scroll(str('.	str := aMorph blockArgs first argString: generator.	stream nextPutAll: str.	stream nextPutAll: '), wait=False)'! !!MicrobitCode methodsFor: 'led blocks'!scrollAndWait: aMorph 	| str |	stream nextPutAll: 'display.scroll(str('.	str := aMorph blockArgs first argString: generator.	stream nextPutAll: str.	stream nextPutAll: '))'! !!MicrobitCode methodsFor: 'led blocks'!setPixelAtxyv: aMorph	| args x y v |	args := aMorph blockArgs.	stream nextPutAll: 'display.set_pixel('.	x := args first argString: generator.	y := args second argString: generator.	v := args third argString: generator.	stream nextPutAll: x.	stream nextPut: $,.	stream nextPutAll: y.	stream nextPut: $,.	stream nextPutAll: v.	stream nextPut: $).! !!MicrobitCode methodsFor: 'led blocks'!showChar: aMorph	stream nextPutAll: (self unaryFunction: 'display.show' of: aMorph).! !!MicrobitCode methodsFor: 'led blocks'!symbolImageOf: aMorph	^ 'Image.', (self class showSymbolAt: aMorph blockArgs first choice)! !!MicrobitCode methodsFor: 'private'!buttonString: aMorph	^ 'button_', aMorph choice! !!MicrobitCode methodsFor: 'private'!literalStringFrom: anObject 	(anObject isKindOf: MicrobitImage)		ifTrue: [^ 'Image("' , anObject asString , '")'].	((anObject isKindOf: String)		and: [anObject isNumberString not])		ifTrue: [^ self quotedString: anObject].	^ anObject asString! !!MicrobitCode methodsFor: 'private'!pinString: anInteger	^ 'pin', anInteger asString! !!MicrobitCode methodsFor: 'sensor blocks'!calibrateCompass: aMorph	stream nextPutAll: 'compass.calibrate()'.! !!MicrobitCode methodsFor: 'sensor blocks'!clearCalibration: aMorph	stream nextPutAll: 'compass.clear_calibration()'.! !!MicrobitCode methodsFor: 'sensor blocks'!currentGesture: aMorph	^ 'accelerometer.current_gesture()'! !!MicrobitCode methodsFor: 'sensor blocks'!fieldStrength: t1 	^ 'compass.get_field_strength()'! !!MicrobitCode methodsFor: 'sensor blocks'!gestures: aMorph	^ ''' ''.join(accelerometer.get_gestures())'! !!MicrobitCode methodsFor: 'sensor blocks'!headingCompass: aMorph	^ 'compass.heading()'.! !!MicrobitCode methodsFor: 'sensor blocks'!isCalibrated: aMorph	^ 'compass.is_calibrated()'! !!MicrobitCode methodsFor: 'sensor blocks'!isGesture: aMorph	^ 'accelerometer.is_gesture("', aMorph blockArgs first choice, '")'! !!MicrobitCode methodsFor: 'sensor blocks'!light: aMorph	^ 'display.read_light_level()'! !!MicrobitCode methodsFor: 'sensor blocks'!runningTime: aMorph	^ 'running_time()'! !!MicrobitCode methodsFor: 'sensor blocks'!temperature: aMorph	^ 'temperature()'! !!MicrobitCode methodsFor: 'sensor blocks'!wasGesture: aMorph	^ 'accelerometer.was_gesture("', aMorph blockArgs first choice, '")'! !!MicrobitCode methodsFor: 'neopixel blocks'!setupNeoPixelPin: pin number: number	self useNeoPixel: pin.	stream nextPutAll: '_np'.	stream nextPutAll: pin asString.	stream nextPutAll: ' = neopixel.NeoPixel(pin'.	stream nextPutAll: pin asString.	stream nextPutAll: ','.	stream nextPutAll: number asString.	stream nextPut: $).! !!MicrobitCode class methodsFor: 'initialization'!initializeSensorDict	SensorDict := Dictionary new.	SensorDict at: #accelX put: 'accelerometer.get_x()'.	SensorDict at: #accelY put: 'accelerometer.get_y()'.	SensorDict at: #accelZ put: 'accelerometer.get_z()'.	SensorDict at: #compassX put: 'compass.get_x()'.	SensorDict at: #compassY put: 'compass.get_y()'.	SensorDict at: #compassZ put: 'compass.get_z()'! !MicrobitCode initializeSensorDict!
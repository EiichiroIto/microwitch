'From MIT Squeak 0.9.4 (June 1, 2003) [No updates present.] on 27 June 2018 at 7:03:30 pm'!!ArgMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator argString: self.! !!BlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:09'!emitCode: aGenerator indent: indent	aGenerator emitBlock: self indent: indent.! !!BooleanArgMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator booleanArgString: self.! !!ByteArray methodsFor: 'microwitch' stamp: 'EiichiroIto 6/26/2018 07:01'!asHexString	| out |	out := WriteStream on: ''.	self do: [:each | out nextPutAll: each asHexString].	^ out contents! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'EiichiroIto 6/27/2018 19:00'!isStop	^ self stopBlocks includes: selector! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'EiichiroIto 6/27/2018 19:00'!coerceArgs: argList	"Answer an arugments array in which all arguments that should be numbers have been coerced to numbers if necessary."	| args specialCommands numFlags |	args := argList asArray.	specialCommands := #(		append:toList: deleteLine:ofList: getLine:ofList: insert:at:ofList: list:contains: setLine:ofList:to:		lookLike: showBackground:		playSound: doPlaySoundAndWait		setVar:to: scrollAndWait).	(specialCommands includes: selector) ifFalse: [		"ensure args are numbers where numbers are expected"		numFlags := self numberArgFlags.		1 to: args size do: [:i |			(numFlags at: i) ifTrue: [args at: i put: (args at: i) asNumberNoError]]].	^ args! !!CommandBlockMorph methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!uncoloredArgMorphFor: specString	"Answer an argument morph for the given argument specification string."	| code |	code := specString at: 2.	$a = code ifTrue: [^ AttributeArgMorph new choice: 'volume'].	$b = code ifTrue: [^ BooleanArgMorph new].	$c = code ifTrue: [^ ColorArgMorph new showPalette: true].	$C = code ifTrue: [^ ColorArgMorph new showPalette: false].  "don't use palette; pick from screen"	$d = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #directionMenu].	$D = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledClockNames].	$e = code ifTrue: [^ EventTitleMorph new].	$f = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #mathFunctionNames; choice: 'sqrt'].	$g = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledSymbolNames].	$H = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #sensorNames].	$h = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #hookupBooleanSensorNames].	$I = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledArrowNames].	$i = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #listIndexMenu].	$k = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #keyNames; choice: 'space'].	$L = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #listVarMenu].	$l = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledCharacterNames].	$m = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #gestureNames].	$M = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #buttonNames].	$n = code ifTrue: [^ ExpressionArgMorph new numExpression: '10'].	$N = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #musicNames].	$s = code ifTrue: [^ ExpressionArgMorph new stringExpression: ''].	$S = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledShapeNames].	$v = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #varNamesMenu; choice: ''].	$W = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #motorDirection].	$x = code ifTrue: [^ ChoiceOrExpressionArgMorph new getOptionsSelector: #sceneNames; choice: ''].	$y = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #listIndexForDeleteMenu].	^ ExpressionArgMorph new numExpression: '10'! !!CommandBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/23/2018 17:08'!blockArgs	^ submorphs select: [:m | (m isKindOf: ArgMorph) or: [m isKindOf: ReporterBlockMorph] ]! !!CommandBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/16/2018 11:33'!stopBlocks	^ #(break continue panic:)! !!CBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:12'!emitCode: aGenerator indent: indent	aGenerator emitCBlock: self indent: indent.! !!CBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:12'!nestedBlock	^ nestedBlock! !!ExpressionArgMorphWithMenu methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator expressionArgWithMenuString: self.! !!ExpressionArgMorphWithMenu methodsFor: 'microwitch' stamp: 'EiichiroIto 6/17/2018 16:31'!ownerSelector	^ owner selector! !!ExpressionArgMorphWithMenu methodsFor: 'microwitch' stamp: 'EiichiroIto 6/17/2018 16:09'!specialValue	^ specialValue! !!HatBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:24'!emitCode: aGenerator indent: indent	aGenerator emitHatBlock: self indent: indent.! !!IfElseBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:38'!emitCode: aGenerator indent: indent	aGenerator emitIfElseBlock: self indent: indent.! !!IfElseBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:36'!falseBlock	^ falseBlock! !!IfElseBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:35'!trueBlock	^ trueBlock! !!Integer methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!asHexString	^ String with: (self // 16) asHexDigit with: (self \\ 16) asHexDigit! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!getButton: anObject id: classID 	| count on |	firstPass		ifTrue: 			[count := self readField.			on := self readField.			^ MicrobitButton new privCount: count;			 privOn: on].	anObject privCount: (self targetObjectFor: anObject privCount);	 privOn: (self targetObjectFor: anObject privOn)! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!getLed: anObject id: classID 	| matrix active |	firstPass		ifTrue: 			[matrix := self readField.			active := self readField.			^ MicrobitLed new privMatrix: matrix;			 active: active].	anObject privMatrix: (self targetObjectFor: anObject matrix).	anObject active: (self targetObjectFor: anObject active)! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!putButton: anObject id: classID 	firstPass ifFalse: [stream nextPut: classID].	self putField: anObject privCount.	self putField: anObject privOn.! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!putIOPin: anObject id: classID 	firstPass ifFalse: [stream nextPut: classID].	self putField: anObject mode.	self putField: anObject status.! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!putLed: anObject id: classID 	firstPass ifFalse: [stream nextPut: classID].	self putField: anObject matrix.	self putField: anObject active.! !!ObjStream class methodsFor: 'class initialization' stamp: 'EiichiroIto 6/27/2018 19:00'!fixedFormatClasses	"Answer an array of records for fixed-format classes."	^ #(		"id	class					read selector		write selector"		(1	UndefinedObject			getConst:id:			putConst:id:)		(2	True					getConst:id:			putConst:id:)		(3	False					getConst:id:			putConst:id:)		(4	SmallInteger			getSmallInt:id:		putSmallInt:id:)		(5	SmallInteger16			getSmallInt:id:		putSmallInt:id:)  "optimization for ints that fit into 16 bits"		(6	LargePositiveInteger		getBigInt:id:			putBigInt:id:)		(7	LargeNegativeInteger	getBigInt:id:			putBigInt:id:)		(8	Float					getFloat:id:			putFloat:id:)		(9	String					getBytes:id:			putBytes:id:)		(10	Symbol					getBytes:id:			putBytes:id:)		(11	ByteArray				getBytes:id:			putBytes:id:)		(12	SoundBuffer			getSoundBuf:id:		putSoundBuf:id:)		(13	Bitmap					getBitmap:id:		putBitmap:id:)		(14	UTF8					getBytes:id:			putBytes:id:)	"12-19 reserved for additional non-pointer objects"		(20	Array					getArray:id:			putArray:id:)		(21	OrderedCollection		getCollection:id:		putCollection:id:)		(22	Set						getCollection:id:		putCollection:id:)		(23	IdentitySet				getCollection:id:		putCollection:id:)		(24	Dictionary				getDict:id:			putDict:id:)		(25	IdentityDictionary		getDict:id:			putDict:id:)	"26-29 reserved for additional collections"		(30	Color					getColor:id:			putColor:id:)		(31	TranslucentColor		getColor:id:			putColor:id:)		(32	Point					getPoint:id:			putPoint:id:)		(33	Rectangle				getRect:id:			putRect:id:)		(34	Form					getForm:id:			putForm:id:)		(35	ColorForm				getForm:id:			putForm:id:)		(36	MicrobitIOPin		getIOPin:id:			putIOPin:id:)		(37	MicrobitLed			getLed:id:				putLed:id:)		(38	MicrobitButton	getButton:id:		putButton:id:)	"99 reserved for object references"	"100-255 reserved for user-defined classes"	)! !!ObjStream class methodsFor: 'class initialization' stamp: 'EiichiroIto 6/27/2018 19:00'!userClasses	"Answer an array of (<class id>, <class name>) records for all version numbered user classes."	"The following finds obsolete user classes:"	"self initialize. self userClasses reject: [:rec | Smalltalk includesKey: rec second]"	^ #(		"id		class"		(100		Morph)		(101		BorderedMorph)		(102		RectangleMorph)		(103		EllipseMorph)		(104		AlignmentMorph)		(105		StringMorph)		(106		UpdatingStringMorph)		(107		SimpleSliderMorph)		(108		SimpleButtonMorph)		(109		SampledSound)		(110		ImageMorph)		(111		SketchMorph)		"(120	SpriteMorph)"		"(121		SoundMorph)"		"(122	ImageBoxMorph)"		(123		SensorBoardMorph)		(124		ScratchSpriteMorph)		(125		ScratchStageMorph)		(126		MicrobitSpriteMorph)		(127		MicrobitLedMorph)		(128		MicrobitButtonMorph)		(140		ChoiceArgMorph)		(141		ColorArgMorph)		(142		ExpressionArgMorph)		"(143	ParameterReferenceMorph)"		"(144	PositionArgMorph)"		(145		SpriteArgMorph)		"(146	VariableArgMorph)"		(147		BlockMorph)		(148		CommandBlockMorph)		(149		CBlockMorph)		"(150	MethodCallBlockMorph)"		(151		HatBlockMorph)		"(152	ScratchButtonMorph)"		(153		ScratchScriptsMorph)		(154		ScratchSliderMorph)		(155		WatcherMorph)		"(156	ParameterMorph)"		(157		SetterBlockMorph)		(158		EventHatMorph)		"(159	EventArgMorph)"		(160		VariableBlockMorph)		"(161		IACTHatBlock)"		(162		ImageMedia)		(163		MovieMedia)		(164		SoundMedia)		(165		KeyEventHatMorph)		(166		BooleanArgMorph)		(167		EventTitleMorph)		(168		MouseClickEventHatMorph)		(169		ExpressionArgMorphWithMenu)		(170		ReporterBlockMorph)		(171		MultilineStringMorph)		(172		ToggleButton)		(173		WatcherReadoutFrameMorph)		(174		WatcherSliderMorph)		(175		ScratchListMorph)		(176		ScrollingStringMorph)	)! !!ReporterBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator reporterArgString: self.! !!ReporterBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/16/2018 08:58'!canBecomeWatcher	^ false! !!ScratchFrameMorph methodsFor: 'intialization' stamp: 'EiichiroIto 6/27/2018 19:00'!createMenuPanel	"Create and add a panel containing the menus and close button."	| menuSpecs m |	"create panel"	menuPanel := AlignmentMorph new		color: Color transparent;		centering: #center;		inset: 0;		height: 0.	"will grow as needed"	self addShortcutButtonsTo: menuPanel.	"menuSpecs defines the menus"	menuSpecs := #(		"name			selector"		(File			fileMenu:)		(Edit			editMenu:)		(Microbit		microbitMenu:)	).	menuSpecs do: [:spec |		m := ScratchMenuTitleMorph new			contents: (spec at: 1) localized;			target: self selector: (spec at: 2).		menuPanel addMorphBack: m.		#helpMenu: = (spec at: 2) ifFalse: [			menuPanel addMorphBack: (Morph new color: Color transparent; extent: 12@5)]].	topPane addMorph: menuPanel.! !!ScratchFrameMorph methodsFor: 'intialization' stamp: 'EiichiroIto 6/27/2018 19:00'!createReadoutPane	"Create and add my presentation mode button, new sprite buttongs, and mouse readout pane."	| xyReadout |	readoutPane := ImageFrameMorph new initFromForm: (ScratchFrameMorph skinAt: #mouseReadoutPane).	xyReadout := self makeXYReadout.	readoutPane	 addMorph: xyReadout.	"make pane sticky so clicking on it doesn't pick up entire frame"	"self addMorph: (readoutPane isSticky: true)."! !!ScratchFrameMorph methodsFor: 'intialization' stamp: 'EiichiroIto 6/27/2018 19:00'!createToolbar	"Create and add the toolbar."	| buttonSpecs bName button |	toolbarPanel := AlignmentMorph new		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent.			buttonSpecs := #(		"name			selector"			"tooltip"		(copy			copyTool		'Duplicate')		(delete			cutTool			'Delete')		(zoomIn 		zoomInTool		'Grow sprite')		(zoomOut 		zoomOutTool		'Shrink sprite')	).	buttonSpecs do: [:spec |		bName := spec at: 1.		button := ToggleButton			onForm: (ScratchFrameMorph skinAt: (bName, 'ButtonPressed') asSymbol)			offForm: (ScratchFrameMorph skinAt: (bName, 'Button') asSymbol)			overForm: (ScratchFrameMorph skinAt: (bName, 'ButtonOver') asSymbol).		button			target: self;			actionSelector: (spec at: 2);			isMomentary: true;			setProperty: #balloonText toValue: (spec at: 3) localized.		toolbarPanel addMorphBack: button].	"self addMorph: toolbarPanel."! !!ScratchFrameMorph methodsFor: 'menu/button actions' stamp: 'EiichiroIto 6/27/2018 19:00'!editMenu: aMenuTitleMorph	| menu |	menu := CustomMenu new.	menu add: 'Undelete' action: #undoTool.	menu addLine.	ScratchProcess blockHighlightMSecs <= 1		ifTrue: [menu add: 'Start Single Stepping' action: #toggleSingleStepping]		ifFalse: [menu add: 'Stop Single Stepping' action: #toggleSingleStepping].	menu add: 'Set Single Stepping' action: #setSingleStepping.	menu addLine.	menu add: 'Compress Sounds' action: #compressSounds.	menu add: 'Compress Images' action: #compressImages.	menu localize.	#(3 4 5) do: [:n |		menu labels at: n put:			((menu labels at: n) copyFrom: 1 to: (menu labels at: n) size - 1), ScratchTranslator ellipsesSuffix].	menu invokeOn: self at: aMenuTitleMorph bottomLeft + (0@10).! !!ScratchFrameMorph methodsFor: 'startup' stamp: 'EiichiroIto 6/27/2018 19:00'!startup	| startupFileNames fileName arg presentationMode |	HostSystemMenus startUp.	HostSystemMenus menuBarControler reviseHostMenus.	ScriptableScratchMorph randomInit.	ScratchTranslator detectRenderPlugin.	ScratchTranslator importLanguagesList.	self processSettingsFile.	self readDefaultNotes.	self updateProjectName.	shuffledCostumeNames := nil.	author := ''.	loginName := ''.	loginPassword := ''.	justSaved := true.	presentationMode := false.	startupFileNames := InputSensor startupFileNames asOrderedCollection.	2 to: 10 do: [:i |		arg := Smalltalk getSystemAttribute: i.		(arg notNil and: [arg size > 0]) ifTrue: [			startupFileNames addLast: (ScratchPlugin primShortToLongPath: arg)]].	startupFileNames do: [:n |		(n asLowercase = 'presentation') ifTrue: [presentationMode := true].		(n asLowercase = 'fullscreen') ifTrue: [TakeOverScreen := true]].	TakeOverScreen ifTrue: [		Smalltalk fullScreenMode: true.		World restoreDisplay].	self enterQuarterModeIfSmallScreen.	fileName := startupFileNames		detect: [:fn |			(fn asLowercase endsWith: '.sb') or: [fn asLowercase endsWith: '.scratch']]		ifNone: [nil].	fileName ifNotNil: [		presentationMode ifTrue: [Display fillColor: Color black].		self openScratchProjectNamed: fileName.		presentationMode ifTrue: [self enterPresentationMode; shoutGo].		^ self].	viewerPane currentCategory: 'io'.	self setDefaultSprite.	self newScratchProject.	fileName := startupFileNames		detect: [:fn | fn asLowercase endsWith: '.sprite']		ifNone: [^ self].	"open a .sprite file"	workPane submorphs do: [:m | (m isKindOf: ScratchSpriteMorph) ifTrue: [m deleteSprite]].	self importSpriteOrProject: fileName.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!addMicrobitCommandsTo: menu	"Add micro:bit commands to the given menu."	menu addLine.	menu add: 'Send to micro:bit' action: #sendMicrobit.	menu add: 'Write python program' action: #writePythonProgram.	menu add: 'Write hex program' action: #writeHexCode.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!currentHatBlocks	^ self scriptsPane target hatBlocks! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!hexCodePath	| path |	path := self hexCodePathByPlugin.	path ifNotNil: [^ path].	^ self hexCodePathByUser! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 07:20'!hexCodePathByPlugin	| dir |	dir := MicrowitchPlugin microbitDevice.	^ dir ifNotNil: [dir , FileDirectory pathNameDelimiter asString , 'firmware.hex']! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 07:21'!hexCodePathByUser	| path |	path := ScratchFileChooserDialog				chooseNewFileDefault: 'firmware.hex'				title: 'write hex code'				type: #hexCode.	^ path = #cancelled ifFalse: [path]! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/13/2018 11:09'!microbitMenu: aMenuTitleMorph 	| menu |	menu := CustomMenu new.	self addMicrobitCommandsTo: menu.	menu localize.	menu invokeOn: self at: aMenuTitleMorph bottomLeft + (0 @ 10)! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 12:39'!programPathByUser	| path |	path := ScratchFileChooserDialog				chooseNewFileDefault: 'microwitch.py'				title: 'write python program'				type: #python.	^ path = #cancelled ifFalse: [path]! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!sendMicrobit	| path |	path := self hexCodePath.	path ifNil: [^ self].	self writeHexCodeAs: path.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writeHexCode	| path |	path := self hexCodePathByUser.	path ifNil: [^ self].	self writeHexCodeAs: path.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writeHexCodeAs: pathName 	| code |	code := MicrobitCode new hexCodeFrom: self currentHatBlocks stageMorph: workPane.	self stopAll.	self writeString: code as: pathName.	Delay waitMSecs: 500.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writePythonProgram	| path |	path := self programPathByUser.	path ifNil: [^ self].	self writePythonProgramAs: path.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writePythonProgramAs: pathName 	| script |	script := MicrobitCode new pythonScriptFrom: self currentHatBlocks stageMorph: workPane.	self stopAll.	self writeString: script as: pathName.	Delay waitMSecs: 500.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 12:42'!writeString: aString as: pathName 	| f dir fName |	dir := FileDirectory default.	FileDirectory splitName: pathName		to: 			[:dir2 :name | 			fName := name.			dir2 isEmpty ifFalse: [dir := FileDirectory on: dir2]].	(dir fileExists: fName)		ifTrue: [dir deleteFileNamed: fName].	f := StandardFileStream fileNamed: pathName.	f ifNil: [^ self].	f nextPutAll: aString.	f close! !!ScratchFrameMorph methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!fixLayout	| stageExtent xyReadout w |	stageExtent :=		workPane isQuarterSize			ifTrue: [workPane extent // 2]			ifFalse: [workPane extent].	topPane		position: self topLeft;		width: self width;		height: (menuPanel height + 0 max: logoMorph height + 10).	stageFrame		extent: stageExtent + (14@42);		top: topPane bottom;		right: self right.	workPane position: stageFrame topLeft + (4@37).	titlePane		position: stageFrame topLeft + (0@1);		width: stageFrame width - 6;		height: 36.	self fixProjectTitleMorphLayout.	scriptsPane fixLayout.	w := (viewerPane catButtonsExtent x + 17)		within: 40		and: (self width - (scriptsPane bareMinimumWidth + stageFrame width)).	viewerPane position: topPane bottomLeft;		width: w;		height: self bottom - topPane bottom.	scriptsPane		position: viewerPane topRight;		width: self width - (stageFrame width + viewerPane width);		height: self bottom - topPane bottom;		fixLayout.	libraryPane position: stageFrame bottomLeft;		width: (self right - scriptsPane right);		height: self bottom - libraryPane top.	menuPanel		left: logoMorph right + 18;		top: topPane top + ((topPane height - menuPanel height) // 2) + 2.	viewModeButtonsPanel		right: stageFrame right - 8;		top: self top + 7.	stageButtonsPanel		position: (stageFrame left + 10)@(topPane bottom + 5);		width: stageFrame width - 28;		height: (workPane top - stageFrame top) - 8.	xyReadout := readoutPane submorphs at: 1.	readoutPane		width: xyReadout width + 23;		height: xyReadout height + 15;		position: stageFrame bottomRight - ((readoutPane width + 6)@3).	xyReadout position: readoutPane position + (18@5).	toolbarPanel		left: (stageFrame left - 4 max: menuPanel right);		top: self top + ((topPane height - toolbarPanel height) // 2) + 3."	((toolbarPanel right - 5) > viewModeButtonsPanel left)		ifTrue: [toolbarPanel delete]		ifFalse: [			(toolbarPanel owner = self) ifFalse: [				self addMorphFront: toolbarPanel]]."! !!ScratchFrameMorph class methodsFor: 'utilities' stamp: 'EiichiroIto 6/27/2018 19:00'!defaultSprite	"Return the default sprite if one was set, or the cat otherwise"	DefaultSprite		ifNotNil: [^ DefaultSprite]		ifNil: [^ MicrobitSpriteMorph new			addMediaItem: (ImageMedia new				mediaName: ('costume' localized, '1');				form: (ScratchFrameMorph skinAt: #defaultSpriteCostume))].! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 16:55'!createCategories	"ScratchFrameMorph createCategories."	self skinAt: #io put: (self skinAt: #motion).	self skinAt: #ioPressed put: (self skinAt: #motionPressed).	self skinAt: #ioOver put: (self skinAt: #motionOver).	self skinAt: #led put: (self skinAt: #looks).	self skinAt: #ledPressed put: (self skinAt: #looksPressed).	self skinAt: #ledOver put: (self skinAt: #looksOver).	self skinAt: #comm put: (self skinAt: #pen).	self skinAt: #commPressed put: (self skinAt: #penPressed).	self skinAt: #commOver put: (self skinAt: #penOver).! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!readDefaultSprite	"ScratchFrameMorph readDefaultSprite."	DefaultSprite := nil.	self readSkinAt: #defaultSpriteCostume from: 'images/sprite1-small.gif'.! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!readMicrowitchLogo	"ScratchFrameMorph readMicrowitchLogo"	ScratchFrameMorph readSkinAt: #scratchLogo from: 'images/logo2.gif'.! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 12:14'!readSkinAt: aSymbol from: aString    self skinAt: aSymbol put: (Form fromFileNamed: aString)! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 12:13'!skinAt: aSymbol put: aForm    ScratchSkin at: aSymbol put: aForm! !!ScratchLibraryMorph methodsFor: 'initialization' stamp: 'EiichiroIto 6/27/2018 19:00'!buildPanes	"Build my scroll pane."	| bin |	stagePane := Morph new		color: Color transparent;		position: self position + (7@0).	bin := ScratchSpriteLibraryMorph new		color: Color transparent;		borderWidth: 0.	scrollPane := ScrollFrameMorph2 new		color: Color transparent;		contents: bin;		showHorizontalScrollbar: false.	spritePane := Morph new		color: Color gray;		position: self position.	spriteLabel := self buildSpriteLabel.	buttonPane := self makeNewSpriteButtons: (self ownerThatIsA: ScratchFrameMorph).	self addMorph: spritePane.	"self addMorph: spriteLabel."	"self addMorph: buttonPane."	self addMorph: scrollPane.	self addMorph: stagePane.! !!ScratchLibraryMorph methodsFor: 'initialization' stamp: 'EiichiroIto 6/27/2018 19:00'!clearLibrary	"Remove all library items. My step method will re-add items for existing objects."	| sFrame |	stagePane removeAllMorphs.	scrollPane contents removeAllMorphs.	scrollPane vScrollRelative: 0.	spriteLabel delete.	spriteLabel := self buildSpriteLabel.	sFrame := self ownerThatIsA: ScratchFrameMorph.	"(sFrame isNil or:	 [sFrame viewMode = #normal]) ifTrue: [		self addMorph: spriteLabel]."	buttonPane delete.	buttonPane := self makeNewSpriteButtons: sFrame.	"self addMorph: buttonPane."	topSectionHeight := ((spriteLabel height + 10) max: 40).	self fixLayout.! !!ScratchListMorph methodsFor: 'list ops' stamp: 'EiichiroIto 6/27/2018 19:00'!deleteLineAt: aNumber	| index |	index := aNumber asInteger + 1.	(index > 0 and: [index <= cellMorphs size]) ifFalse: [		lastActivityError := true.		^ self].	index = numberMorphs size ifTrue: [		numberMorphs last delete.		numberMorphs := numberMorphs copyFrom: 1 to: numberMorphs size - 1].	(cellMorphs removeAt: index) delete.	self noteChangeAtIndex: index.! !!ScratchListMorph methodsFor: 'list ops' stamp: 'EiichiroIto 6/27/2018 19:00'!insertLine: aString at: aNumber	| index newCell |	index := aNumber asInteger + 1.	(index > 0 and: [index <= (cellMorphs size + 1)]) ifFalse: [		lastActivityError := true.		^ self].	newCell := self createCell: aString.	index = 1		ifTrue: [cellMorphs addFirst: newCell]		ifFalse: [			index > cellMorphs size				ifTrue: [cellMorphs addLast: newCell]				ifFalse: [cellMorphs add: newCell afterIndex: index - 1]].	self noteChangeAtIndex: index.	^ newCell! !!ScratchListMorph methodsFor: 'list ops' stamp: 'EiichiroIto 6/27/2018 19:00'!lineAt: aNumber	| index |	index := aNumber asInteger + 1.	(index > 0 and: [index <= cellMorphs size])		ifTrue: [			self noteChangeAtIndex: index.			^ (cellMorphs at: index) firstSubmorph contents asUTF8]		ifFalse: [			lastActivityError := true.			^ ''].! !!ScratchListMorph methodsFor: 'list ops' stamp: 'EiichiroIto 6/27/2018 19:00'!setLineAt: aNumber to: newContents	| index |	index := aNumber asInteger + 1.	(index > 0 and: [index <= cellMorphs size]) ifFalse: [		lastActivityError := true.		^ self].	(cellMorphs at: index) firstSubmorph contents: newContents asString.	self noteChangeAtIndex: index.! !!ScratchListMorph methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!updateIndices: rightX	| s newNumbers page num cell |	numberMorphs size > cellMorphs size ifTrue: [		cellMorphs size + 1 to: numberMorphs size do: [:i | (numberMorphs at: i) delete].		numberMorphs := numberMorphs copyFrom: 1 to: cellMorphs size].	newNumbers := #().	numberMorphs size < cellMorphs size ifTrue: [		page := scrollPane contents.		s := StringMorph new			color: self indexColor;			font: (ScratchFrameMorph getFont: #Label).		newNumbers := (numberMorphs size + 1 to: cellMorphs size)			collect: [:i | s fullCopy contents: (i - 1) printString].		newNumbers do: [:m | page addMorph: m].		numberMorphs := numberMorphs, newNumbers].	1 to: cellMorphs size do: [:i |		num := numberMorphs at: i.		cell := cellMorphs at: i.		num position: (rightX - num width) @ (cell top + ((cell height - num height) // 2))].! !!ScratchProcess methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!scrollAndWait	"Scroll message and block until it has finished scrolling."	| block args message ubit |	block := stackFrame expression.	args := stackFrame arguments.	"first time: send the event and collect a list of processes"	args size = 0		ifTrue: [			message := block args first.			ubit := block receiver.			ubit scroll: message]		ifFalse: [			ubit := args first].	"if sound has stopped, pop this frame and we're done"	ubit isScrolling ifFalse: [^ self popStackFrame].	"Set up the wait loop. We need to:		1.  yield to another process		2.  evaluate our termination condition again	Push these onto stack in reverse order."	"2.  evaluate this block again"	"(Remove the current frame and replace it with one that will force the termination condition to be re-evaluated.)"	self popStackFrameNoUnhightlight.	self pushStackFrame: (ScratchStackFrame new		expression: block;		addArgument: ubit).	"1.  yield to another process"	self pushStackFrame: (ScratchStackFrame new shouldYield: true).! !!ScratchThread class methodsFor: 'class initialization' stamp: 'EiichiroIto 6/27/2018 19:00'!initialize	"self initialize"	SystemCommands := IdentitySet new.	SystemCommands addAll: #(		doForever doForeverIf doIf doRepeat doReturn		doBroadcastAndWait doPlaySoundAndWait doWaitUntil scrollAndWait).! !!ScratchViewerMorph methodsFor: 'initialization' stamp: 'EiichiroIto 6/27/2018 19:00'!rebuildCategorySelectors	| catList maxExtent buttons label offForm onForm overForm b pad leftColumnX rightColumnX x y |	catList := #(		io				control		led			sensing		sound		operators		comm		variables).	"First, delete the old category buttons"	submorphs do: [:m | (m isKindOf: ResizableToggleButton2) ifTrue: [m delete]].	"Create new buttons, keeping track of the maximum extent."	maxExtent := 75@0.	buttons := catList collect: [:cat |		label := (ScratchTranslator translationFor: cat asString) capitalized.		offForm := (ScratchFrameMorph skinAt: cat).		onForm := (ScratchFrameMorph skinAt: (cat, 'Pressed')).		overForm := (ScratchFrameMorph skinAt: (cat, 'Over')).		ScratchTranslator isRTL			ifTrue:[				b := ResizableToggleButton2 new					offForm:	(offForm flipBy: #horizontal centerAt: offForm center)					onForm:		(onForm flipBy: #horizontal centerAt: onForm center)					overForm:	(overForm flipBy: #horizontal centerAt: overForm center)]			ifFalse:[				b := ResizableToggleButton2 new					offForm:	offForm					onForm:		onForm					overForm:	overForm].		b			label: label font: (ScratchFrameMorph getFont: #Category);			setLabelColor: Color white;			target: self;			actionSelector: #currentCategory:;			arguments: (Array with: cat);			toggleButtonMode: true;			toggleMode: false.		ScratchTranslator isRTL			ifTrue:[b rightJustifyInset: 10]			ifFalse:[b leftJustifyInset: 10].		maxExtent := maxExtent max: (b extent + (3 @ -6)).		b].	"calculate catButtonsExtent"	pad := 15. "padding on left, right, and betwen the button columns"	catButtonsExtent := ((2 * maxExtent x) + (3 * pad)) @ (((catList size // 2) * (maxExtent y + 6)) + 25).	"place the buttons"	leftColumnX := self left + 12 + pad.	rightColumnX := leftColumnX + maxExtent x + pad.	x := leftColumnX.	y := self top + 17.	1 to: buttons size do: [:i |		b := buttons at: i.		b extent: maxExtent.		self addMorph: (b position: x@y).		i even			ifTrue: [x := leftColumnX. y := y + b height + 6]			ifFalse: [x := rightColumnX]].	self width: catButtonsExtent x.	pageViewer position: self position + (0@catButtonsExtent y).	topSectionHeight := catButtonsExtent y - 4.! !!ScriptableScratchMorph methodsFor: 'list ops' stamp: 'EiichiroIto 6/27/2018 19:00'!append: anObject toList: listName	| list |	list := self listNamed: listName ifNone: [^ 0].	list insertLine: (self asListElement: anObject) at: list lineCount.! !!ScriptableScratchMorph methodsFor: 'list ops' stamp: 'EiichiroIto 6/27/2018 19:00'!lineNum: lineNum forList: list	| s |	lineNum isNumber ifTrue: [^ lineNum asInteger].	s := lineNum.	s isUnicode ifTrue: [s := String withAll: lineNum].	(s isKindOf: String) ifTrue: [		#first = s ifTrue: [^ 0].		#last = s ifTrue: [^ list lineCount - 1].		#any = s ifTrue: [			list lineCount = 0 ifTrue: [^ 0].			^ (0 to: list lineCount - 1) atRandom].		^ s asNumberNoError].	^ -1! !!ScriptableScratchMorph methodsFor: 'list ops' stamp: 'EiichiroIto 6/27/2018 19:00'!listIndexForDeleteMenu	| menu |	menu := CustomMenu new.	#('0' last) do: [:s | menu add: s action: s].	menu addLine.	menu add: #all action: #all.	menu localize.	^ menu! !!ScriptableScratchMorph methodsFor: 'list ops' stamp: 'EiichiroIto 6/27/2018 19:00'!listIndexMenu	| menu |	menu := CustomMenu new.	#('0' any last) do: [:s | menu add: s action: s].	menu localize.	^ menu! !!ScriptableScratchMorph methodsFor: 'other ops' stamp: 'EiichiroIto 6/27/2018 19:00'!mathFunctionNames	"Answer a collection of math function names."	^ #(		'sqrt'		'sin'		'cos'		'tan'		'asin'		'acos'		'atan'		'log'	)! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!blockFromSpec: spec color: blockColor	"Create a block from the given block specification. Answer nil if I don't implement the block spec selector."	| blockLabelSpec blockType selector defaultArgs block rcvr argPermutation c |	c := blockColor.	blockLabelSpec := ScratchTranslator translationFor: (spec at: 1).	argPermutation := CommandBlockMorph argPermutationForSpec: (spec at: 1) withTranslation: blockLabelSpec.	blockType := spec at: 2.	selector := (spec at: 3) asSymbol.	defaultArgs := self defaultArgsFor: spec.	(#(E K M S W) includes: blockType) ifTrue: [		^ (self hatBlockType: blockType) color: blockColor].	"basic block type: normal or C-shaped"	(blockType includes: $c)		ifTrue:	[			selector = #doIfElse				ifTrue: [block := IfElseBlockMorph new isSpecialForm: true]				ifFalse: [block := CBlockMorph new isSpecialForm: true]]		ifFalse:	[			(blockType includes: $r) | (blockType includes: $b)				ifTrue: [block := ReporterBlockMorph new. c := c darker]				ifFalse: [block := CommandBlockMorph new]].	(blockType includes: $b) ifTrue: [block isBoolean: true].	(blockType includes: $s) ifTrue: [block isSpecialForm: true].	(blockType includes: $t) ifTrue: [block isTimed: true].	(ScriptableScratchMorph isSpriteSpecificTarget: self selector: selector)		ifTrue: [rcvr := self]		ifFalse: [rcvr := self ownerThatIsA: ScratchStageMorph].	^ block		argPermutation: argPermutation;		color: c;		selector: selector;		commandSpec: blockLabelSpec;		defaultArgs: defaultArgs;		receiver: rcvr! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!defaultArgsFor: blockSpec	"Answer the default argument for the given block specification."	| defaultArgs stage sel currentSize list |	defaultArgs := blockSpec copyFrom: 4 to: blockSpec size.  "may be empty"	stage := self ownerThatIsA: ScratchStageMorph.	sel := (blockSpec at: 3) asSymbol.	#gotoX:y: = sel ifTrue: [		defaultArgs := Array			with: self referencePosition x rounded			with: self referencePosition y rounded].	#glideSecs:toX:y:elapsed:from: = sel ifTrue: [		defaultArgs := Array			with: 1			with: self referencePosition x rounded			with: self referencePosition y rounded].	#motor:direction: = self ifTrue: [		defaultArgs := Array with: 'reverse' localized with: 'this way' localized with: 'that way'].	#setSizeTo: = sel ifTrue: [		currentSize := (100.0 * (self scalePoint x max: self scalePoint y)) rounded.		defaultArgs := Array with: currentSize].	#getAttribute:of: = sel ifTrue: [		(stage := self ownerThatIsA: ScratchStageMorph) ifNotNil: [			list := stage submorphs select: [:m | m isKindOf: ScratchSpriteMorph].			list sort: [:s1 :s2 | s1 objName asLowercase < s2 objName asLowercase].			list size > 0				ifTrue: [defaultArgs := Array with: 'x position' with: list first]				ifFalse: [defaultArgs := Array with: 'background #' with: stage]]		ifNil:[defaultArgs := Array with: 'x position' with: self]].	#concatenate:with: = sel ifTrue: [		defaultArgs := Array with: 'hello ' localized with: 'world' localized].	#doAsk = sel ifTrue: [		defaultArgs := Array with: 'What''s your name?' localized].	#letter:of: = sel ifTrue: [		defaultArgs := Array with: 1 with: 'world' localized].	#stringLength: = sel ifTrue: [		defaultArgs := Array with: 'world' localized].	#say:duration:elapsed:from: = sel ifTrue: [		defaultArgs := Array with: 'Hello!!' localized with: 2].	#say: = sel ifTrue: [		defaultArgs := Array with: 'Hello!!' localized].	#think:duration:elapsed:from: = sel ifTrue: [		defaultArgs := Array with: 'Hmm...' localized with: 2].	#think: = sel ifTrue: [		defaultArgs := Array with: 'Hmm...' localized].	(#(lookLike: showBackground:) includes: sel) ifTrue: [		defaultArgs := Array with: self costumeNames last].	(#(playSound: doPlaySoundAndWait) includes: sel) ifTrue: [		list := self soundNames.		defaultArgs := list size <= 2			ifTrue: [Array with: '']			ifFalse: [Array with: (list at: (list size - 2))]].	(#(broadcast: doBroadcastAndWait) includes: sel) ifTrue: [		stage ifNotNil: [defaultArgs := Array with: stage defaultEventName]].	(#(append:toList: deleteLine:ofList: insert:at:ofList:) includes: sel) ifTrue: [		defaultArgs size >= 1 ifTrue: [			defaultArgs at: 1 put: (defaultArgs at: 1) localized]].	(#(append:toList: deleteLine:ofList: getLine:ofList: insert:at:ofList: lineCountOfList:)		includes: sel) ifTrue: [			defaultArgs := defaultArgs copyWith: self defaultListName].	#setLine:ofList:to: = sel ifTrue: [		defaultArgs size >= 3 ifTrue: [			defaultArgs at: 2 put: self defaultListName.			defaultArgs at: 3 put: (defaultArgs at: 3) localized]].	#appendLettersOf:toList: = sel ifTrue: [		defaultArgs size >= 2 ifTrue: [			defaultArgs at: 1 put: (defaultArgs at: 1) localized.			defaultArgs at: 2 put: self defaultListName]].	#list:contains: = sel ifTrue: [		defaultArgs size >= 2 ifTrue: [			defaultArgs at: 1 put: self defaultListName.			defaultArgs at: 2 put: (defaultArgs at: 2) localized]].	#scrollAndWait = sel ifTrue: [		defaultArgs := Array with: 'Hello!!'].	^ defaultArgs! !!ScriptableScratchMorph methodsFor: 'private' stamp: 'EiichiroIto 9/7/2017 12:03'!hatBlocks	^ blocksBin submorphs select: [:m | m isKindOf: HatBlockMorph]! !!ScriptableScratchMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/19/2018 07:59'!vars	^ vars! !!ScratchStageMorph methodsFor: 'menus' stamp: 'EiichiroIto 6/27/2018 19:00'!rightButtonMenu	"Present the right button menu."	| menu |	menu := CustomMenu new.	menu add: 'new microbit sprite' action: #createNewMicrobitSprite.	menu addLine.	menu add: 'save picture of stage...' action: #stageShot.	menu localize; invokeOn: self.! !!ScratchStageMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!createNewMicrobitSprite	| frame morph |	(frame := self ownerThatIsA: ScratchFrameMorph) ifNil: [^ self].	morph := MicrobitSpriteMorph new addMediaItem: (ImageMedia new mediaName: 'costume' localized , '1';				 form: (ScratchFrameMorph skinAt: #defaultSpriteCostume)).	frame addAndView: morph! !!ScriptableScratchMorph class methodsFor: 'block specs' stamp: 'EiichiroIto 6/27/2018 19:00'!blockColorFor: aCategory	"Answer the block color for the given category."	'control' = aCategory ifTrue: [^ (Color h: 41 s: 0.85 v: 0.9)].	'io' = aCategory ifTrue: [^ (Color h: 225 s: 0.65 v: 0.83)].	'motor' = aCategory ifTrue: [^ (Color h: 220 s: 0.85 v: 0.725)].	'led' = aCategory ifTrue: [^ (Color h: 264 s: 0.62 v: 0.89)].	'comm' = aCategory ifTrue: [^ (Color h: 165 s: 1 v: 0.63)].	'operators' = aCategory ifTrue: [^ (Color h: 93 s: 0.9 v: 0.76)].	'sound' = aCategory ifTrue: [^ (Color h: 296 s: 0.66 v: 0.85)].	'sensing' = aCategory ifTrue: [^ (Color h: 200 s: 0.98 v: 0.86)].	'variables' = aCategory ifTrue: [^ (Color h: 25 s: 0.88 v: 0.95)].	'list' = aCategory ifTrue: [^ ListBlockColor].	^ (Color h: 0 s: 0.81 v: 0.83)  "a shade of red"! !!ScriptableScratchMorph class methodsFor: 'block specs' stamp: 'EiichiroIto 6/27/2018 19:00'!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	^ self controlBlocks, self operatorsBlocks, self variablesBlocks! !!ScriptableScratchMorph class methodsFor: 'other' stamp: 'EiichiroIto 6/27/2018 19:00'!isSpriteSpecificTarget: anObject selector: selector	"I determine whether the given selector is specific to a particular Sprite. ."	| i |	true ifTrue: [^ true].	(anObject isKindOf: ScratchSpriteMorph) ifFalse: [^ false].	i := selector asString		findAnySubStr: #('answer' 'key' 'Loud' 'mouse' 'sensor' 'soundLevel' 'tempo' 'timer')		startingAt: 1.	^ i > selector asString size! !!ScriptableScratchMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!controlBlocks	^ #(		'control'			('when %m clicked'				S	-)			-			('forever'						c	doForever)			('repeat %n'					c	doRepeat 10)			('while %b'					c	doWhile)			('repeat until %b'		c	doUntil)			-			('break'						-	break)			('continue'					-	continue)			-			('if %b'							c	doIf)			('if %b'							c	doIfElse)	)! !!ScriptableScratchMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!operatorsBlocks	^ #(		'operators'			('%n + %n'						r	x:plusY: - -)			('%n - %n'						r	x:minusY: - -)			('%n * %n'						r	x:mulY: - -)			('%n / %n'						r	x:divY: - -)			('%n mod %n'					r	x:modY: - -)			-			('pick random %n to %n'		r	randomFrom:to: 1 10)			('set random seed to %n'		-	setRandomSeed: 1234)			-			('%s < %s'						b	less:than: '' '')			('%s = %s'						b	equal:to: '' '')			('%s > %s'						b	more:than: '' '')			-			('%b and %b'				b	x:andY:)			('%b or %b'					b	x:orY:)			('not %b'						b	not:)			('true'							b	true)			('false'							b	false)			-			('string of %n'				r	stringOf:	0)			('join %s %s'				r	concatenate:with: 'hello ' 'world')			('letter %n of %s'			r	letter:of: 0 'world')			('length of %s'				r	stringLength: 'world')			('any of %s'					r	anyOf: )			-			('round %n'					r	rounded -)			('abs %n'						r	abs -)			('abs %n sign %n'			r	abs:sign:	- -)			-			('%f of %n'					r	computeFunction:of: 'sqrt' 10)	)! !!ScriptableScratchMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!variablesBlocks	^ #(		'list'			('add %s to %L'					-	append:toList: 'thing')			-			('delete %y of %L'				-	deleteLine:ofList: 0)			('insert %s at %n of %L'			-	insert:at:ofList: 'thing' 0)			('replace item %i of %L with %s'		-	setLine:ofList:to: 0 'list' 'thing')			-			('item %i of %L'					r	getLine:ofList: 0)			('length of %L'					r	lineCountOfList:)			('%L contains %s'				b	list:contains: 'list' 'thing')	)! !!ScratchSpriteMorph class methodsFor: 'block specs' stamp: 'EiichiroIto 6/17/2018 16:17'!origBlockSpecs	| blocks |	blocks := #(		'motion'			('move %n steps'				-	forward:)			('turn %n degrees'				-	turnRight: 15)	"icon shows turn direction"			('turn %n degrees'				-	turnLeft: 15)	"icon shows turn direction"			-			('point in direction %d'			-	heading: 90)			('point towards %m'				-	pointTowards:)			-			('go to x:%n y:%n'				-	gotoX:y: 0 0)			('go to %m'						-	gotoSpriteOrMouse:)			('glide %n secs to x:%n y:%n'	t	glideSecs:toX:y:elapsed:from: 1 50 50)			-			('change x by %n'				-	changeXposBy: 10)			('set x to %n'					-	xpos: 0)			('change y by %n'				-	changeYposBy: 10)			('set y to %n'					-	ypos: 0)			-			('if on edge, bounce'			-	bounceOffEdge)			-			('x position'						r	xpos)			('y position'						r	ypos)			('direction'						r	heading)		'pen'			('clear'							-	clearPenTrails)			-			('pen down'						-	putPenDown)			('pen up'						-	putPenUp)			-			('set pen color to %c'			-	penColor:)			('change pen color by %n'		-	changePenHueBy:)			('set pen color to %n'			-	setPenHueTo: 0)			-			('change pen shade by %n'		-	changePenShadeBy:)			('set pen shade to %n'			-	setPenShadeTo: 50)			-			('change pen size by %n'		-	changePenSizeBy: 1)			('set pen size to %n'				-	penSize: 1)			-			('stamp'							-	stampCostume)	).	blocks := blocks, #(		'looks'			('switch to costume %l'			-	lookLike:)			('next costume'					-	nextCostume)			('costume #'						r	costumeIndex)			-			('say %s for %n secs'			t	say:duration:elapsed:from: 'Hello!!' 2)			('say %s'						-	say: 'Hello!!')			('think %s for %n secs'			t	think:duration:elapsed:from: 'Hmm...' 2)			('think %s'						-	think: 'Hmm...')			-			('change %g effect by %n'		-	changeGraphicEffect:by: 'color' 25)			('set %g effect to %n'			-	setGraphicEffect:to: 'color' 0)			('clear graphic effects'			-	filterReset)			-			('change size by %n'			-	changeSizeBy:)			('set size to %n%'				-	setSizeTo: 100)			('size'							r	scale)			-			('show'							-	show)			('hide'							-	hide)			-			('go to front'					-	comeToFront)			('go back %n layers'			-	goBackByLayers: 1)		).	^ blocks, super blockSpecs! !!ScratchStageMorph class methodsFor: 'block specs' stamp: 'EiichiroIto 6/17/2018 16:17'!origBlockSpecs	| blocks |	blocks := #(		'sensing'			('ask %s and wait'			s	doAsk 'What''s your name?')			('answer'					r	answer)			-			('mouse x'					r	mouseX)			('mouse y'					r	mouseY)			('mouse down?'				b	mousePressed)			-			('key %k pressed?'			b	keyPressed: 'space')			-			('reset timer'				-	timerReset)			('timer'						r	timer)			-			('%a of %m'					r	getAttribute:of:)			-			('loudness'					r	soundLevel)			('loud?'						b	isLoud)			~			('%H sensor value'			r	sensor: 'slider')			('sensor %h?'				b	sensorPressed: 'button pressed')		'looks'			('switch to background %l'	-	showBackground: 'background1')			('next background'			-	nextBackground)			('background #'				r	backgroundIndex)			-			('change %g effect by %n'	-	changeGraphicEffect:by: 'color' 25)			('set %g effect to %n'		-	setGraphicEffect:to: 'color' 0)			('clear graphic effects'		-	filterReset)			-"xxx			('place sprites for scene %x'	-	showScene:) "		'pen'			('clear'						-	clearPenTrails)	).	^ blocks, super blockSpecs! !!String methodsFor: 'microwitch' stamp: 'EiichiroIto 6/19/2018 07:21'!isNumberString	| aStream d pointNumber digitAppears |	pointNumber := false.	digitAppears := false.	aStream := ReadStream on: self.	aStream peek = $- ifTrue: [aStream next].	[aStream atEnd]		whileFalse: 			[d := aStream next.			d = $.				ifTrue: 					[pointNumber ifTrue: [^ false].					pointNumber := true]				ifFalse: [(d < $0 or: [d > $9])						ifTrue: [^ false]						ifFalse: [digitAppears := true]]].	^ digitAppears! !!String class methodsFor: 'instance creation' stamp: 'EiichiroIto 6/13/2018 12:13'!lf	"Answer a string containing a linefeed."	^ self with: Character lf! !!VariableBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator variableArgString: self.! !!WriteStream methodsFor: 'character writing' stamp: 'EiichiroIto 6/13/2018 12:12'!lf	"Append linefeed characters to the receiver."	self nextPutAll: String lf.! !ScratchThread initialize.ObjStream initialize.ScratchFrameMorph readDefaultSprite.ScratchFrameMorph readMicrowitchLogo.ScratchFrameMorph createCategories.
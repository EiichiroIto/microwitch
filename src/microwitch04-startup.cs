'From MIT Squeak 0.9.4 (June 1, 2003) [No updates present.] on 4 July 2018 at 1:33:01 pm'!!ArgMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator argString: self.! !!Array methodsFor: 'microwitch'!animateOn: aLed atInterval: anInteger 	aLed animateImages: self interval: anInteger.! !!BlockMorph methodsFor: 'event handling'!rightButtonMenu	| menu |	menu _ CustomMenu new.	"menu add: 'help' action: #presentHelpScreen.	(owner isKindOf: ScratchBlockPaletteMorph) ifFalse: [		menu addLine.		menu add: 'duplicate' action: #duplicate.			(self owner isKindOf: BlockMorph) ifFalse: [			menu add: 'delete' action: #delete]]."	DebugMenu ifTrue: [		menu addLine.		menu add: 'show tuples' action: #showTuples].		menu localize; invokeOn: self.! !!BlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:09'!emitCode: aGenerator indent: indent	aGenerator emitBlock: self indent: indent.! !!BooleanArgMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator booleanArgString: self.! !!ByteArray methodsFor: 'microwitch' stamp: 'EiichiroIto 6/26/2018 07:01'!asHexString	| out |	out := WriteStream on: ''.	self do: [:each | out nextPutAll: each asHexString].	^ out contents! !!CommandBlockMorph methodsFor: 'accessing'!isStop	^ self stopBlocks includes: selector! !!CommandBlockMorph methodsFor: 'evaluation'!coerceArgs: argList	"Answer an arugments array in which all arguments that should be numbers have been coerced to numbers if necessary."	| args specialCommands numFlags |	args := argList asArray.	specialCommands := #(		append:toList: deleteLine:ofList: getLine:ofList: insert:at:ofList: list:contains: setLine:ofList:to:		lookLike: showBackground:		playSound: doPlaySoundAndWait		setVar:to: scrollAndWait animateAndWait).	(specialCommands includes: selector) ifFalse: [		"ensure args are numbers where numbers are expected"		numFlags := self numberArgFlags.		1 to: args size do: [:i |			(numFlags at: i) ifTrue: [args at: i put: (args at: i) asNumberNoError]]].	^ args! !!CommandBlockMorph methodsFor: 'menus'!rightButtonMenu	| menu sFrame choice spec |	menu _ CustomMenu new.	"menu add: 'help' action: #presentHelpScreen."	(owner isKindOf: ScratchBlockPaletteMorph) ifFalse: [		menu addLine.		(#(+ - * / \\) includes: selector) ifTrue: [			#(+ - * / mod) with: #(+ - * / \\) do: [:s :op | menu add: s action: op]].		(#(< = >) includes: selector) ifTrue: [			#(< = >) do: [:op | menu add: op action: op]].		(#(& |) includes: selector) ifTrue: [			#(and or) with: #(& |) do: [:s :op | menu add: s action: op]].		menu addLine.		menu add: 'duplicate' action: #duplicate.		(self owner isKindOf: BlockMorph) ifFalse: [  "can't yet delete a blocks inside a script"			menu add: 'delete' action: #delete]].	sFrame _ self ownerThatIsA: ScratchFrameMorph.	(sFrame notNil and: [#(sensor: sensorPressed:) includes: selector]) ifTrue: [		menu addLine.		menu add: 'show ScratchBoard watcher' action: #showSensorBoard.		sFrame workPane scratchServer			ifNil: [menu add: 'enable remote sensor connections' action: #enableRemoteSensors]			ifNotNil: [menu add: 'disable remote sensor connections' action: #exitScratchSession]].	DebugMenu ifTrue: [		menu addLine.		menu add: 'show tuples' action: #showTuples].		(choice _ menu localize; startUp) ifNil: [^ self].	(#(presentHelpScreen duplicate delete) includes: choice) ifTrue: [^ self perform: choice].	choice = #showSensorBoard ifTrue: [sFrame showSensorBoard. ^ self].	choice = #enableRemoteSensors ifTrue: [sFrame enableRemoteSensors. ^ self].	choice = #exitScratchSession ifTrue: [sFrame exitScratchSession. ^ self].	choice = #showTuples ifTrue: [^ self showTuples].	"change operator"	spec _ '%n ', choice, ' %n'.	'\\' = choice	ifTrue: [spec _ ScratchTranslator translationFor: '%n mod %n'].	'&' = choice	ifTrue: [spec _ ScratchTranslator translationFor: '%b and %b'].	'|' = choice	ifTrue: [spec _ ScratchTranslator translationFor: '%b or %b'].	self commandSpec: spec.	self selector: choice.! !!CommandBlockMorph methodsFor: 'private'!uncoloredArgMorphFor: specString	"Answer an argument morph for the given argument specification string."	| code |	code := specString at: 2.	$a = code ifTrue: [^ AttributeArgMorph new choice: 'volume'].	$b = code ifTrue: [^ BooleanArgMorph new].	$c = code ifTrue: [^ ColorArgMorph new showPalette: true].	$C = code ifTrue: [^ LedArgMorph new image: ''].	$d = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #directionMenu].	$D = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledClockNames].	$e = code ifTrue: [^ EventTitleMorph new].	$f = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #mathFunctionNames; choice: 'sqrt'].	$g = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledSymbolNames].	$H = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #sensorNames].	$h = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #hookupBooleanSensorNames].	$I = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledArrowNames].	$i = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #listIndexMenu].	$k = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #keyNames; choice: 'space'].	$L = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #listVarMenu].	$l = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledCharacterNames].	$m = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #gestureNames].	$M = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #buttonNames].	$n = code ifTrue: [^ ExpressionArgMorph new numExpression: '10'].	$N = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #musicNames].	$s = code ifTrue: [^ ExpressionArgMorph new stringExpression: ''].	$S = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #ledShapeNames].	$v = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #varNamesMenu; choice: ''].	$W = code ifTrue: [^ ChoiceArgMorph new getOptionsSelector: #motorDirection].	$x = code ifTrue: [^ ChoiceOrExpressionArgMorph new getOptionsSelector: #sceneNames; choice: ''].	$y = code ifTrue: [^ ExpressionArgMorphWithMenu new numExpression: '0'; menuSelector: #listIndexForDeleteMenu].	^ ExpressionArgMorph new numExpression: '10'! !!CommandBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/23/2018 17:08'!blockArgs	^ submorphs select: [:m | (m isKindOf: ArgMorph) or: [m isKindOf: ReporterBlockMorph] ]! !!CommandBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/16/2018 11:33'!stopBlocks	^ #(break continue panic:)! !!CBlockMorph methodsFor: 'private'!addCommandIcons	"Add additional icons to certain blocks. Do nothing if this isn't one of those blocks."	| f |	super addCommandIcons.	(#(doForever doForeverIf doRepeat doUntil doWhile) includes: selector) ifTrue: [		f _ ScratchFrameMorph skinAt: #loopIcon ifAbsent: [^ self].		loopMorph _ ImageMorph new form: f.		self addMorphBack: loopMorph].! !!CBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:12'!emitCode: aGenerator indent: indent	aGenerator emitCBlock: self indent: indent.! !!CBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:12'!nestedBlock	^ nestedBlock! !!ExpressionArgMorphWithMenu methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator expressionArgWithMenuString: self.! !!ExpressionArgMorphWithMenu methodsFor: 'microwitch' stamp: 'EiichiroIto 6/17/2018 16:31'!ownerSelector	^ owner selector! !!ExpressionArgMorphWithMenu methodsFor: 'microwitch' stamp: 'EiichiroIto 6/17/2018 16:09'!specialValue	^ specialValue! !!HandMorph methodsFor: 'world menu'!openMenu	"Build the open window menu for the world."	| menu |	menu _ (MenuMorph entitled: 'open...') defaultTarget: self.	menu addStayUpItem.	menu add: 'browser' action: #openBrowser.	menu add: 'workspace' action: #openWorkspace.	menu add: 'file list' action: #openFileList.	menu add: 'transcript' action: #openTranscript.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	menu add: 'mvc project' action: #openMVCProject.	menu add: 'morphic project' action: #openMorphicProject.	menu addLine.	menu add: 'micro:witch' action: #openScratchFrame.	^ menu! !!HatBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:24'!emitCode: aGenerator indent: indent	aGenerator emitHatBlock: self indent: indent.! !!IfElseBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:38'!emitCode: aGenerator indent: indent	aGenerator emitIfElseBlock: self indent: indent.! !!IfElseBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:36'!falseBlock	^ falseBlock! !!IfElseBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 07:35'!trueBlock	^ trueBlock! !!Integer methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!asHexString	^ String with: (self // 16) asHexDigit with: (self \\ 16) asHexDigit! !!LibraryItemMorph methodsFor: 'right button menu'!rightButtonMenu	"Present the right button menu."	| menu |	menu _ CustomMenu new.	menu add: 'show' action: #makeVisible.	"menu add: 'export this sprite' action: #exportObject."	menu addLine.	menu add: 'duplicate' action: #duplicateNoAttach.	menu add: 'delete' action: #undoableDeleteSprite.	menu localize; invokeOn: self target.! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!getButton: anObject id: classID 	| count on |	firstPass		ifTrue: 			[count := self readField.			on := self readField.			^ MicrobitButton new privCount: count;			 privOn: on].	anObject privCount: (self targetObjectFor: anObject privCount);	 privOn: (self targetObjectFor: anObject privOn)! !!ObjStream methodsFor: 'microwitch'!getLed: anObject id: classID 	| matrix active |	firstPass		ifTrue: 			[matrix := self readField.			active := self readField.			^ MicrobitLed new privMatrix: matrix;			 active: active].	anObject privMatrix: (self targetObjectFor: anObject privMatrix).	anObject active: (self targetObjectFor: anObject active)! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!putButton: anObject id: classID 	firstPass ifFalse: [stream nextPut: classID].	self putField: anObject privCount.	self putField: anObject privOn.! !!ObjStream methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!putIOPin: anObject id: classID 	firstPass ifFalse: [stream nextPut: classID].	self putField: anObject mode.	self putField: anObject status.! !!ObjStream methodsFor: 'microwitch'!putLed: anObject id: classID 	firstPass ifFalse: [stream nextPut: classID].	self putField: anObject matrix.	self putField: anObject active.! !!ObjStream class methodsFor: 'class initialization'!fixedFormatClasses	"Answer an array of records for fixed-format classes."	^ #(		"id	class					read selector		write selector"		(1	UndefinedObject			getConst:id:			putConst:id:)		(2	True					getConst:id:			putConst:id:)		(3	False					getConst:id:			putConst:id:)		(4	SmallInteger			getSmallInt:id:		putSmallInt:id:)		(5	SmallInteger16			getSmallInt:id:		putSmallInt:id:)  "optimization for ints that fit into 16 bits"		(6	LargePositiveInteger		getBigInt:id:			putBigInt:id:)		(7	LargeNegativeInteger	getBigInt:id:			putBigInt:id:)		(8	Float					getFloat:id:			putFloat:id:)		(9	String					getBytes:id:			putBytes:id:)		(10	Symbol					getBytes:id:			putBytes:id:)		(11	ByteArray				getBytes:id:			putBytes:id:)		(12	SoundBuffer			getSoundBuf:id:		putSoundBuf:id:)		(13	Bitmap					getBitmap:id:		putBitmap:id:)		(14	UTF8					getBytes:id:			putBytes:id:)	"12-19 reserved for additional non-pointer objects"		(20	Array					getArray:id:			putArray:id:)		(21	OrderedCollection		getCollection:id:		putCollection:id:)		(22	Set						getCollection:id:		putCollection:id:)		(23	IdentitySet				getCollection:id:		putCollection:id:)		(24	Dictionary				getDict:id:			putDict:id:)		(25	IdentityDictionary		getDict:id:			putDict:id:)	"26-29 reserved for additional collections"		(30	Color					getColor:id:			putColor:id:)		(31	TranslucentColor		getColor:id:			putColor:id:)		(32	Point					getPoint:id:			putPoint:id:)		(33	Rectangle				getRect:id:			putRect:id:)		(34	Form					getForm:id:			putForm:id:)		(35	ColorForm				getForm:id:			putForm:id:)		(36	MicrobitIOPin		getIOPin:id:			putIOPin:id:)		(37	MicrobitLed			getLed:id:				putLed:id:)		(38	MicrobitButton	getButton:id:		putButton:id:)	"99 reserved for object references"	"100-255 reserved for user-defined classes"	)! !!ObjStream class methodsFor: 'class initialization'!userClasses	"Answer an array of (<class id>, <class name>) records for all version numbered user classes."	"The following finds obsolete user classes:"	"self initialize. self userClasses reject: [:rec | Smalltalk includesKey: rec second]"	^ #(		"id		class"		(100		Morph)		(101		BorderedMorph)		(102		RectangleMorph)		(103		EllipseMorph)		(104		AlignmentMorph)		(105		StringMorph)		(106		UpdatingStringMorph)		(107		SimpleSliderMorph)		(108		SimpleButtonMorph)		(109		SampledSound)		(110		ImageMorph)		(111		SketchMorph)		"(120	SpriteMorph)"		"(121		SoundMorph)"		"(122	ImageBoxMorph)"		(123		SensorBoardMorph)		(124		ScratchSpriteMorph)		(125		ScratchStageMorph)		(126		MicrobitSpriteMorph)		(127		MicrobitLedMorph)		(128		MicrobitButtonMorph)		(140		ChoiceArgMorph)		(141		ColorArgMorph)		(142		ExpressionArgMorph)		"(143	ParameterReferenceMorph)"		"(144	PositionArgMorph)"		(145		SpriteArgMorph)		"(146	VariableArgMorph)"		(147		BlockMorph)		(148		CommandBlockMorph)		(149		CBlockMorph)		"(150	MethodCallBlockMorph)"		(151		HatBlockMorph)		"(152	ScratchButtonMorph)"		(153		ScratchScriptsMorph)		(154		ScratchSliderMorph)		(155		WatcherMorph)		"(156	ParameterMorph)"		(157		SetterBlockMorph)		(158		EventHatMorph)		"(159	EventArgMorph)"		(160		VariableBlockMorph)		"(161		IACTHatBlock)"		(162		ImageMedia)		(163		MovieMedia)		(164		SoundMedia)		(165		KeyEventHatMorph)		(166		BooleanArgMorph)		(167		EventTitleMorph)		(168		MouseClickEventHatMorph)		(169		ExpressionArgMorphWithMenu)		(170		ReporterBlockMorph)		(171		MultilineStringMorph)		(172		ToggleButton)		(173		WatcherReadoutFrameMorph)		(174		WatcherSliderMorph)		(175		ScratchListMorph)		(176		ScrollingStringMorph)	)! !!ReporterBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator reporterArgString: self.! !!ReporterBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/16/2018 08:58'!canBecomeWatcher	^ false! !!ScratchCodeGenerator methodsFor: 'arg generator'!imageString: aLedArgMorph 	^ target imageString: aLedArgMorph.! !!ScratchFrameMorph methodsFor: 'intialization'!createMenuPanel	"Create and add a panel containing the menus and close button."	| menuSpecs m |	"create panel"	menuPanel := AlignmentMorph new		color: Color transparent;		centering: #center;		inset: 0;		height: 0.	"will grow as needed"	self addShortcutButtonsTo: menuPanel.	"menuSpecs defines the menus"	menuSpecs := #(		"name			selector"		(File			fileMenu:)		(Edit			editMenu:)		(Device		microbitMenu:)	).	menuSpecs do: [:spec |		m := ScratchMenuTitleMorph new			contents: (spec at: 1) localized;			target: self selector: (spec at: 2).		menuPanel addMorphBack: m.		#helpMenu: = (spec at: 2) ifFalse: [			menuPanel addMorphBack: (Morph new color: Color transparent; extent: 12@5)]].	topPane addMorph: menuPanel.! !!ScratchFrameMorph methodsFor: 'intialization'!createReadoutPane	"Create and add my presentation mode button, new sprite buttongs, and mouse readout pane."	| xyReadout |	readoutPane := ImageFrameMorph new initFromForm: (ScratchFrameMorph skinAt: #mouseReadoutPane).	xyReadout := self makeXYReadout.	readoutPane	 addMorph: xyReadout.	"make pane sticky so clicking on it doesn't pick up entire frame"	"self addMorph: (readoutPane isSticky: true)."! !!ScratchFrameMorph methodsFor: 'intialization'!createToolbar	"Create and add the toolbar."	| buttonSpecs bName button |	toolbarPanel := AlignmentMorph new		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent.			buttonSpecs := #(		"name			selector"			"tooltip"		(copy			copyTool		'Duplicate')		(delete			cutTool			'Delete')		(zoomIn 		zoomInTool		'Grow sprite')		(zoomOut 		zoomOutTool		'Shrink sprite')	).	buttonSpecs do: [:spec |		bName := spec at: 1.		button := ToggleButton			onForm: (ScratchFrameMorph skinAt: (bName, 'ButtonPressed') asSymbol)			offForm: (ScratchFrameMorph skinAt: (bName, 'Button') asSymbol)			overForm: (ScratchFrameMorph skinAt: (bName, 'ButtonOver') asSymbol).		button			target: self;			actionSelector: (spec at: 2);			isMomentary: true;			setProperty: #balloonText toValue: (spec at: 3) localized.		toolbarPanel addMorphBack: button].	"self addMorph: toolbarPanel."! !!ScratchFrameMorph methodsFor: 'intialization'!createViewModeButtonsPanel	| specs bName button |	viewModeButtonsPanel _ AlignmentMorph newRow		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color transparent.	viewModeButtons _ OrderedCollection new.	specs _ OrderedCollection new.	specs add: #(quarter			enterQuarterMode		'Switch to small stage').	specs add: #(normal			enterNormalMode		'Switch to full stage').	"specs add: #(presentation	enterPresentationMode	'Switch to presentation mode')."	specs do: [:spec |		bName _ spec first.		button _ ToggleButton new			onForm: (ScratchFrameMorph skinAt: bName, 'ViewModeOn')			offForm: (ScratchFrameMorph skinAt: bName, 'ViewMode')			overForm: (ScratchFrameMorph skinAt: bName, 'ViewModeOver').		button			target: self;			actionSelector: (spec at: 2);			alphaOn: true;			setProperty: #balloonText toValue: (spec at: 3) localized.		viewModeButtonsPanel			addMorphBack: button;			addMorphBack: (Morph new extent: 1@5; color: Color transparent).		viewModeButtons add: button].	self addMorph: viewModeButtonsPanel.! !!ScratchFrameMorph methodsFor: 'menu/button actions'!aboutScratch	| dialogBox |	dialogBox _ DialogBoxMorph new		title: 'About micro:witch';		withButtonsForYes: false no: false okay: true cancel: false.	dialogBox		message: 'micro:witch version 0.3Copyright 2018 Eiichiro Ito.All rights reserved.https://github.com/EiichiroIto/microwitchBased on Scratch from the MIT Media Lab, v', Version, 'Copyright © 2009 Massachusetts Institute of Technology.All rights reserved.http://info.scratch.mit.edu/Source_Code'		font: (ScratchFrameMorph getFont: #AboutScratch).	dialogBox getUserResponse.! !!ScratchFrameMorph methodsFor: 'menu/button actions'!editMenu: aMenuTitleMorph	| menu |	menu := CustomMenu new.	menu add: 'Undelete' action: #undoTool.	"menu addLine.	ScratchProcess blockHighlightMSecs <= 1		ifTrue: [menu add: 'Start Single Stepping' action: #toggleSingleStepping]		ifFalse: [menu add: 'Stop Single Stepping' action: #toggleSingleStepping].	menu add: 'Set Single Stepping' action: #setSingleStepping.	menu addLine.	menu add: 'Compress Sounds' action: #compressSounds.	menu add: 'Compress Images' action: #compressImages."	menu localize.	"#(3 4 5) do: [:n |		menu labels at: n put:			((menu labels at: n) copyFrom: 1 to: (menu labels at: n) size - 1), ScratchTranslator ellipsesSuffix]."	menu invokeOn: self at: aMenuTitleMorph bottomLeft + (0@10).! !!ScratchFrameMorph methodsFor: 'menu/button actions'!fileMenu: aMenuTitleMorph	| menu |	menu _ CustomMenu new.	menu add: 'New' action: #newScratchProject.	menu add: 'Open' action: #openScratchProject.	menu add: 'Save' action: #saveScratchProjectNoDialog.	menu add: 'Save As' action: #saveScratchProject.	"menu addLine.	menu add: 'Import Project' action: #importScratchProject.	menu add: 'Export Sprite' action: #exportSprite.	menu addLine.	menu add: 'Project Notes' action: #editNotes."	Sensor shiftPressed ifTrue: [  "developer menu"		"menu addLine.		menu add: 'Write Project Summary' action: #writeSummaryFile.		menu add: 'Write Multiple Project Summaries' action: #writeMultipleSummaries."		menu addLine.		fillScreenFlag			ifTrue: [				menu add: 'Exit User Mode' action: #fillScreenOff]			ifFalse: [				menu add: 'Enter User Mode' action: #fillScreenOn.				menu add: 'Save Image in User Mode' action: #saveImageForEndUser]].	menu addLine.	menu add: 'Quit' action: #quitScratch.	menu localize.		#(2 4 "5 6 7") do: [:n |		menu labels at: n put:			((menu labels at: n) copyFrom: 1 to: (menu labels at: n) size - 1), ScratchTranslator ellipsesSuffix].	menu invokeOn: self at: aMenuTitleMorph bottomLeft + (0@10).! !!ScratchFrameMorph methodsFor: 'startup'!startup	| startupFileNames fileName arg presentationMode |	HostSystemMenus startUp.	HostSystemMenus menuBarControler reviseHostMenus.	ScriptableScratchMorph randomInit.	ScratchTranslator detectRenderPlugin.	ScratchTranslator importLanguagesList.	self processSettingsFile.	self readDefaultNotes.	self updateProjectName.	shuffledCostumeNames := nil.	author := ''.	loginName := ''.	loginPassword := ''.	justSaved := true.	presentationMode := false.	startupFileNames := InputSensor startupFileNames asOrderedCollection.	2 to: 10 do: [:i |		arg := Smalltalk getSystemAttribute: i.		(arg notNil and: [arg size > 0]) ifTrue: [			startupFileNames addLast: (ScratchPlugin primShortToLongPath: arg)]].	startupFileNames do: [:n |		(n asLowercase = 'presentation') ifTrue: [presentationMode := true].		(n asLowercase = 'fullscreen') ifTrue: [TakeOverScreen := true]].	TakeOverScreen ifTrue: [		Smalltalk fullScreenMode: true.		World restoreDisplay].	self enterQuarterModeIfSmallScreen.	fileName := startupFileNames		detect: [:fn |			(fn asLowercase endsWith: '.sb') or: [fn asLowercase endsWith: '.scratch']]		ifNone: [nil].	fileName ifNotNil: [		presentationMode ifTrue: [Display fillColor: Color black].		self openScratchProjectNamed: fileName.		presentationMode ifTrue: [self enterPresentationMode; shoutGo].		^ self].	viewerPane currentCategory: 'io'.	self setDefaultSprite.	self newScratchProject.	fileName := startupFileNames		detect: [:fn | fn asLowercase endsWith: '.sprite']		ifNone: [^ self].	"open a .sprite file"	workPane submorphs do: [:m | (m isKindOf: ScratchSpriteMorph) ifTrue: [m deleteSprite]].	self importSpriteOrProject: fileName.! !!ScratchFrameMorph methodsFor: 'private'!fixLayout	| stageExtent xyReadout w |	stageExtent :=		workPane isQuarterSize			ifTrue: [workPane extent // 2]			ifFalse: [workPane extent].	topPane		position: self topLeft;		width: self width;		height: (menuPanel height + 0 max: logoMorph height + 10).	stageFrame		extent: stageExtent + (14@42);		top: topPane bottom;		right: self right.	workPane position: stageFrame topLeft + (4@37).	titlePane		position: stageFrame topLeft + (0@1);		width: stageFrame width - 6;		height: 36.	self fixProjectTitleMorphLayout.	scriptsPane fixLayout.	w := (viewerPane catButtonsExtent x + 17)		within: 40		and: (self width - (scriptsPane bareMinimumWidth + stageFrame width)).	viewerPane position: topPane bottomLeft;		width: w;		height: self bottom - topPane bottom.	scriptsPane		position: viewerPane topRight;		width: self width - (stageFrame width + viewerPane width);		height: self bottom - topPane bottom;		fixLayout.	libraryPane position: stageFrame bottomLeft;		width: (self right - scriptsPane right);		height: self bottom - libraryPane top.	menuPanel		left: logoMorph right + 18;		top: topPane top + ((topPane height - menuPanel height) // 2) + 2.	viewModeButtonsPanel		right: stageFrame right - 8;		top: self top + 7.	stageButtonsPanel		position: (stageFrame left + 10)@(topPane bottom + 5);		width: stageFrame width - 28;		height: (workPane top - stageFrame top) - 8.	xyReadout := readoutPane submorphs at: 1.	readoutPane		width: xyReadout width + 23;		height: xyReadout height + 15;		position: stageFrame bottomRight - ((readoutPane width + 6)@3).	xyReadout position: readoutPane position + (18@5).	toolbarPanel		left: (stageFrame left - 4 max: menuPanel right);		top: self top + ((topPane height - toolbarPanel height) // 2) + 3."	((toolbarPanel right - 5) > viewModeButtonsPanel left)		ifTrue: [toolbarPanel delete]		ifFalse: [			(toolbarPanel owner = self) ifFalse: [				self addMorphFront: toolbarPanel]]."! !!ScratchFrameMorph methodsFor: 'private'!updateProjectName	"Update the project name display in the Scratch title bar."	| s |	projectName ifNil: [projectName _ ''].	projectTitleMorph contents: (self nameFromFileName: projectName).	projectTitleMorph contents size > 0		ifTrue: [s _ projectTitleMorph contents, '- micro:witch']		ifFalse: [s _ 'micro:witch ', Version].	ScratchPlugin primSetWindowTitle: s.	self fixLayout.! !!ScratchFrameMorph methodsFor: 'microwitch'!addMicrobitCommandsTo: menu 	"Add micro:bit commands to the given menu."	menu addLine.	menu add: 'Send to micro:bit' action: #sendMicrobit.	menu add: 'Write Python program' action: #writePythonProgram.	menu add: 'Write HEX program' action: #writeHexCode.	Sensor shiftPressed		ifTrue: 			[menu addLine.			menu add: 'update firmware' action: #updateFirmware].	menu addLine.	menu add: 'About micro:witch' action: #aboutScratch! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!currentHatBlocks	^ self scriptsPane target hatBlocks! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!hexCodePath	| path |	path := self hexCodePathByPlugin.	path ifNotNil: [^ path].	^ self hexCodePathByUser! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 07:20'!hexCodePathByPlugin	| dir |	dir := MicrowitchPlugin microbitDevice.	^ dir ifNotNil: [dir , FileDirectory pathNameDelimiter asString , 'firmware.hex']! !!ScratchFrameMorph methodsFor: 'microwitch'!hexCodePathByUser	| path |	path := ScratchFileChooserDialog				chooseNewFileDefault: 'firmware.hex'				title: 'Write HEX program'				type: #hexCode.	^ path = #cancelled ifFalse: [path]! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/13/2018 11:09'!microbitMenu: aMenuTitleMorph 	| menu |	menu := CustomMenu new.	self addMicrobitCommandsTo: menu.	menu localize.	menu invokeOn: self at: aMenuTitleMorph bottomLeft + (0 @ 10)! !!ScratchFrameMorph methodsFor: 'microwitch'!programPathByUser	| path |	path := ScratchFileChooserDialog				chooseNewFileDefault: 'microwitch.py'				title: 'Write Python program'				type: #python.	^ path = #cancelled ifFalse: [path]! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!sendMicrobit	| path |	path := self hexCodePath.	path ifNil: [^ self].	self writeHexCodeAs: path.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 7/4/2018 07:18'!updateFirmware	MicrobitCode readFirmware.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writeHexCode	| path |	path := self hexCodePathByUser.	path ifNil: [^ self].	self writeHexCodeAs: path.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writeHexCodeAs: pathName 	| code |	code := MicrobitCode new hexCodeFrom: self currentHatBlocks stageMorph: workPane.	self stopAll.	self writeString: code as: pathName.	Delay waitMSecs: 500.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writePythonProgram	| path |	path := self programPathByUser.	path ifNil: [^ self].	self writePythonProgramAs: path.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!writePythonProgramAs: pathName 	| script |	script := MicrobitCode new pythonScriptFrom: self currentHatBlocks stageMorph: workPane.	self stopAll.	self writeString: script as: pathName.	Delay waitMSecs: 500.! !!ScratchFrameMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 12:42'!writeString: aString as: pathName 	| f dir fName |	dir := FileDirectory default.	FileDirectory splitName: pathName		to: 			[:dir2 :name | 			fName := name.			dir2 isEmpty ifFalse: [dir := FileDirectory on: dir2]].	(dir fileExists: fName)		ifTrue: [dir deleteFileNamed: fName].	f := StandardFileStream fileNamed: pathName.	f ifNil: [^ self].	f nextPutAll: aString.	f close! !!ScratchFrameMorph class methodsFor: 'utilities'!defaultSprite	"Return the default sprite if one was set, or the cat otherwise"	DefaultSprite		ifNotNil: [^ DefaultSprite]		ifNil: [^ MicrobitSpriteMorph new			addMediaItem: (ImageMedia new				mediaName: ('costume' localized, '1');				form: (ScratchFrameMorph skinAt: #defaultSpriteCostume))].! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 16:55'!createCategories	"ScratchFrameMorph createCategories."	self skinAt: #io put: (self skinAt: #motion).	self skinAt: #ioPressed put: (self skinAt: #motionPressed).	self skinAt: #ioOver put: (self skinAt: #motionOver).	self skinAt: #led put: (self skinAt: #looks).	self skinAt: #ledPressed put: (self skinAt: #looksPressed).	self skinAt: #ledOver put: (self skinAt: #looksOver).	self skinAt: #comm put: (self skinAt: #pen).	self skinAt: #commPressed put: (self skinAt: #penPressed).	self skinAt: #commOver put: (self skinAt: #penOver).! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!readDefaultSprite	"ScratchFrameMorph readDefaultSprite."	DefaultSprite := nil.	self readSkinAt: #defaultSpriteCostume from: 'images/sprite1-small.gif'.! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!readMicrowitchLogo	"ScratchFrameMorph readMicrowitchLogo"	ScratchFrameMorph readSkinAt: #scratchLogo from: 'images/logo2.gif'.! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 12:14'!readSkinAt: aSymbol from: aString    self skinAt: aSymbol put: (Form fromFileNamed: aString)! !!ScratchFrameMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/15/2018 12:13'!skinAt: aSymbol put: aForm    ScratchSkin at: aSymbol put: aForm! !!ScratchLibraryMorph methodsFor: 'initialization'!buildPanes	"Build my scroll pane."	| bin |	stagePane := Morph new		color: Color transparent;		position: self position + (7@0).	bin := ScratchSpriteLibraryMorph new		color: Color transparent;		borderWidth: 0.	scrollPane := ScrollFrameMorph2 new		color: Color transparent;		contents: bin;		showHorizontalScrollbar: false.	spritePane := Morph new		color: Color gray;		position: self position.	spriteLabel := self buildSpriteLabel.	buttonPane := self makeNewSpriteButtons: (self ownerThatIsA: ScratchFrameMorph).	self addMorph: spritePane.	"self addMorph: spriteLabel."	"self addMorph: buttonPane."	self addMorph: scrollPane.	self addMorph: stagePane.! !!ScratchLibraryMorph methodsFor: 'initialization'!clearLibrary	"Remove all library items. My step method will re-add items for existing objects."	| sFrame |	stagePane removeAllMorphs.	scrollPane contents removeAllMorphs.	scrollPane vScrollRelative: 0.	spriteLabel delete.	spriteLabel := self buildSpriteLabel.	sFrame := self ownerThatIsA: ScratchFrameMorph.	"(sFrame isNil or:	 [sFrame viewMode = #normal]) ifTrue: [		self addMorph: spriteLabel]."	buttonPane delete.	buttonPane := self makeNewSpriteButtons: sFrame.	"self addMorph: buttonPane."	topSectionHeight := ((spriteLabel height + 10) max: 40).	self fixLayout.! !!ScratchListMorph methodsFor: 'list ops'!deleteLineAt: aNumber	| index |	index := aNumber asInteger + 1.	(index > 0 and: [index <= cellMorphs size]) ifFalse: [		lastActivityError := true.		^ self].	index = numberMorphs size ifTrue: [		numberMorphs last delete.		numberMorphs := numberMorphs copyFrom: 1 to: numberMorphs size - 1].	(cellMorphs removeAt: index) delete.	self noteChangeAtIndex: index.! !!ScratchListMorph methodsFor: 'list ops'!insertLine: aString at: aNumber	| index newCell |	index := aNumber asInteger + 1.	(index > 0 and: [index <= (cellMorphs size + 1)]) ifFalse: [		lastActivityError := true.		^ self].	newCell := self createCell: aString.	index = 1		ifTrue: [cellMorphs addFirst: newCell]		ifFalse: [			index > cellMorphs size				ifTrue: [cellMorphs addLast: newCell]				ifFalse: [cellMorphs add: newCell afterIndex: index - 1]].	self noteChangeAtIndex: index.	^ newCell! !!ScratchListMorph methodsFor: 'list ops'!lineAt: aNumber	| index |	index := aNumber asInteger + 1.	(index > 0 and: [index <= cellMorphs size])		ifTrue: [			self noteChangeAtIndex: index.			^ (cellMorphs at: index) firstSubmorph contents asUTF8]		ifFalse: [			lastActivityError := true.			^ ''].! !!ScratchListMorph methodsFor: 'list ops'!setLineAt: aNumber to: newContents	| index |	index := aNumber asInteger + 1.	(index > 0 and: [index <= cellMorphs size]) ifFalse: [		lastActivityError := true.		^ self].	(cellMorphs at: index) firstSubmorph contents: newContents asString.	self noteChangeAtIndex: index.! !!ScratchListMorph methodsFor: 'private'!updateIndices: rightX	| s newNumbers page num cell |	numberMorphs size > cellMorphs size ifTrue: [		cellMorphs size + 1 to: numberMorphs size do: [:i | (numberMorphs at: i) delete].		numberMorphs := numberMorphs copyFrom: 1 to: cellMorphs size].	newNumbers := #().	numberMorphs size < cellMorphs size ifTrue: [		page := scrollPane contents.		s := StringMorph new			color: self indexColor;			font: (ScratchFrameMorph getFont: #Label).		newNumbers := (numberMorphs size + 1 to: cellMorphs size)			collect: [:i | s fullCopy contents: (i - 1) printString].		newNumbers do: [:m | page addMorph: m].		numberMorphs := numberMorphs, newNumbers].	1 to: cellMorphs size do: [:i |		num := numberMorphs at: i.		cell := cellMorphs at: i.		num position: (rightX - num width) @ (cell top + ((cell height - num height) // 2))].! !!ScratchProcess methodsFor: 'microwitch' stamp: 'EiichiroIto 7/2/2018 07:01'!animateAndWait	"Scroll message and block until it has finished scrolling."	| block args message ubit |	block := stackFrame expression.	args := stackFrame arguments.	"first time: send the event and collect a list of processes"	args size = 0		ifTrue: [			message := block args first.			ubit := block receiver.			ubit animate: message]		ifFalse: [			ubit := args first].	"if sound has stopped, pop this frame and we're done"	ubit isAnimating ifFalse: [^ self popStackFrame].	"Set up the wait loop. We need to:		1.  yield to another process		2.  evaluate our termination condition again	Push these onto stack in reverse order."	"2.  evaluate this block again"	"(Remove the current frame and replace it with one that will force the termination condition to be re-evaluated.)"	self popStackFrameNoUnhightlight.	self pushStackFrame: (ScratchStackFrame new		expression: block;		addArgument: ubit).	"1.  yield to another process"	self pushStackFrame: (ScratchStackFrame new shouldYield: true).! !!ScratchProcess methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!scrollAndWait	"Scroll message and block until it has finished scrolling."	| block args message ubit |	block := stackFrame expression.	args := stackFrame arguments.	"first time: send the event and collect a list of processes"	args size = 0		ifTrue: [			message := block args first.			ubit := block receiver.			ubit scroll: message]		ifFalse: [			ubit := args first].	"if sound has stopped, pop this frame and we're done"	ubit isScrolling ifFalse: [^ self popStackFrame].	"Set up the wait loop. We need to:		1.  yield to another process		2.  evaluate our termination condition again	Push these onto stack in reverse order."	"2.  evaluate this block again"	"(Remove the current frame and replace it with one that will force the termination condition to be re-evaluated.)"	self popStackFrameNoUnhightlight.	self pushStackFrame: (ScratchStackFrame new		expression: block;		addArgument: ubit).	"1.  yield to another process"	self pushStackFrame: (ScratchStackFrame new shouldYield: true).! !!ScratchScriptEditorMorph methodsFor: 'initialization'!createTabPane	| tabOnForm tabOffForm tabID tabLabel |	"create tab pane"	tabPaneMorph _ ScratchTabPaneMorph new.	tabPaneMorph		borderWidth: 0;		color: Color transparent;		targetPane: self.	tabOnForm _ (ScratchFrameMorph skinAt: #tabOn).	tabOffForm _ (ScratchFrameMorph skinAt: #tabOff).	"add the tabs"	#(Scripts) do: [:spec |		tabID _ spec asString.		tabLabel _ tabID localized.		tabPaneMorph			createTab: tabID			withLabel: tabLabel			onForm: tabOnForm			offForm: tabOffForm].	"set current tab and add to frame"	tabPaneMorph currentTab: 'Scripts'.	self addMorph: tabPaneMorph.! !!ScratchScriptEditorMorph methodsFor: 'private'!addLockButton	"Add button to set sprite locked status."	self deleteLockButton.	lockButton _ ToggleButton		onForm: (ScratchFrameMorph skinAt: #locked)		offForm: (ScratchFrameMorph skinAt: #unlocked).	lockButton		target: self;		actionSelector: #toggleSpriteDraggable;		setBalloonText: 'draggable on website?' localized;		actWhen: #buttonUp;		isMomentary: true;		position: (nameMorph right + 4)@(nameMorph top + ((nameMorph height - lockButton height) / 2)).	"self addMorph: lockButton."	self updateLockButton.! !!ScratchScriptEditorMorph methodsFor: 'private'!addRotationButtons	"Add buttons to set the rotation style."	| specs x y style button |	self deleteRotationButtons.	(self target respondsTo: #rotationStyle:) ifFalse: [^ self].	specs _ #(		(Smooth		'can rotate')		(Flip		'only face left-right')		(None		'don''t rotate')).	x _ self left + 13.	y _ self top + 18.	specs do: [:pair |		style _ pair first.		button _ ToggleButton			onForm: (ScratchFrameMorph skinAt: ('rotStyle', style, 'On'))			offForm: (ScratchFrameMorph skinAt: ('rotStyle', style))			overForm: (ScratchFrameMorph skinAt: ('rotStyle', style, 'Over')).		button			target: self;			arguments: (Array with: style);			actionSelector: #setRotationStyle:;			setBalloonText: pair second localized;			actWhen: #buttonDown;			position: x@y.		"self addMorph: button."		rotationButtons _ rotationButtons copyWith: button.		y _ y + button height + 2].	self updateRotationButtonHighlight.! !!ScratchThread class methodsFor: 'class initialization'!initialize	"self initialize"	SystemCommands := IdentitySet new.	SystemCommands addAll: #(		doForever doForeverIf doIf doRepeat doReturn doWhile		doBroadcastAndWait doPlaySoundAndWait doWaitUntil scrollAndWait animateAndWait).! !!ScratchThumbnailMorph methodsFor: 'event handling'!handlesMouseDown: evt	^ false! !!ScratchViewerMorph methodsFor: 'initialization'!rebuildCategorySelectors	| catList maxExtent buttons label offForm onForm overForm b pad leftColumnX rightColumnX x y |	catList := #(		io				control		led			sensing		sound		operators		comm		variables).	"First, delete the old category buttons"	submorphs do: [:m | (m isKindOf: ResizableToggleButton2) ifTrue: [m delete]].	"Create new buttons, keeping track of the maximum extent."	maxExtent := 75@0.	buttons := catList collect: [:cat |		label := (ScratchTranslator translationFor: cat asString) capitalized.		offForm := (ScratchFrameMorph skinAt: cat).		onForm := (ScratchFrameMorph skinAt: (cat, 'Pressed')).		overForm := (ScratchFrameMorph skinAt: (cat, 'Over')).		ScratchTranslator isRTL			ifTrue:[				b := ResizableToggleButton2 new					offForm:	(offForm flipBy: #horizontal centerAt: offForm center)					onForm:		(onForm flipBy: #horizontal centerAt: onForm center)					overForm:	(overForm flipBy: #horizontal centerAt: overForm center)]			ifFalse:[				b := ResizableToggleButton2 new					offForm:	offForm					onForm:		onForm					overForm:	overForm].		b			label: label font: (ScratchFrameMorph getFont: #Category);			setLabelColor: Color white;			target: self;			actionSelector: #currentCategory:;			arguments: (Array with: cat);			toggleButtonMode: true;			toggleMode: false.		ScratchTranslator isRTL			ifTrue:[b rightJustifyInset: 10]			ifFalse:[b leftJustifyInset: 10].		maxExtent := maxExtent max: (b extent + (3 @ -6)).		b].	"calculate catButtonsExtent"	pad := 15. "padding on left, right, and betwen the button columns"	catButtonsExtent := ((2 * maxExtent x) + (3 * pad)) @ (((catList size // 2) * (maxExtent y + 6)) + 25).	"place the buttons"	leftColumnX := self left + 12 + pad.	rightColumnX := leftColumnX + maxExtent x + pad.	x := leftColumnX.	y := self top + 17.	1 to: buttons size do: [:i |		b := buttons at: i.		b extent: maxExtent.		self addMorph: (b position: x@y).		i even			ifTrue: [x := leftColumnX. y := y + b height + 6]			ifFalse: [x := rightColumnX]].	self width: catButtonsExtent x.	pageViewer position: self position + (0@catButtonsExtent y).	topSectionHeight := catButtonsExtent y - 4.! !!ScriptableScratchMorph methodsFor: 'list ops'!append: anObject toList: listName	| list |	list := self listNamed: listName ifNone: [^ 0].	list insertLine: (self asListElement: anObject) at: list lineCount.! !!ScriptableScratchMorph methodsFor: 'list ops'!lineNum: lineNum forList: list	| s |	lineNum isNumber ifTrue: [^ lineNum asInteger].	s := lineNum.	s isUnicode ifTrue: [s := String withAll: lineNum].	(s isKindOf: String) ifTrue: [		#first = s ifTrue: [^ 0].		#last = s ifTrue: [^ list lineCount - 1].		#any = s ifTrue: [			list lineCount = 0 ifTrue: [^ 0].			^ (0 to: list lineCount - 1) atRandom].		^ s asNumberNoError].	^ -1! !!ScriptableScratchMorph methodsFor: 'list ops'!listIndexForDeleteMenu	| menu |	menu := CustomMenu new.	#('0' last) do: [:s | menu add: s action: s].	menu addLine.	menu add: #all action: #all.	menu localize.	^ menu! !!ScriptableScratchMorph methodsFor: 'list ops'!listIndexMenu	| menu |	menu := CustomMenu new.	#('0' any last) do: [:s | menu add: s action: s].	menu localize.	^ menu! !!ScriptableScratchMorph methodsFor: 'other ops'!mathFunctionNames	"Answer a collection of math function names."	^ #(		'sqrt'		'sin'		'cos'		'tan'		'asin'		'acos'		'atan'		'log'	)! !!ScriptableScratchMorph methodsFor: 'blocks'!blockFromSpec: spec color: blockColor	"Create a block from the given block specification. Answer nil if I don't implement the block spec selector."	| blockLabelSpec blockType selector defaultArgs block rcvr argPermutation c |	c := blockColor.	blockLabelSpec := ScratchTranslator translationFor: (spec at: 1).	argPermutation := CommandBlockMorph argPermutationForSpec: (spec at: 1) withTranslation: blockLabelSpec.	blockType := spec at: 2.	selector := (spec at: 3) asSymbol.	defaultArgs := self defaultArgsFor: spec.	(#(E K M S W) includes: blockType) ifTrue: [		^ (self hatBlockType: blockType) color: blockColor].	"basic block type: normal or C-shaped"	(blockType includes: $c)		ifTrue:	[			selector = #doIfElse				ifTrue: [block := IfElseBlockMorph new isSpecialForm: true]				ifFalse: [block := CBlockMorph new isSpecialForm: true]]		ifFalse:	[			(blockType includes: $r) | (blockType includes: $b)				ifTrue: [block := ReporterBlockMorph new. c := c darker]				ifFalse: [block := CommandBlockMorph new]].	(blockType includes: $b) ifTrue: [block isBoolean: true].	(blockType includes: $s) ifTrue: [block isSpecialForm: true].	(blockType includes: $t) ifTrue: [block isTimed: true].	(ScriptableScratchMorph isSpriteSpecificTarget: self selector: selector)		ifTrue: [rcvr := self]		ifFalse: [rcvr := self ownerThatIsA: ScratchStageMorph].	^ block		argPermutation: argPermutation;		color: c;		selector: selector;		commandSpec: blockLabelSpec;		defaultArgs: defaultArgs;		receiver: rcvr! !!ScriptableScratchMorph methodsFor: 'blocks'!defaultArgsFor: blockSpec	"Answer the default argument for the given block specification."	| defaultArgs stage sel currentSize list |	defaultArgs := blockSpec copyFrom: 4 to: blockSpec size.  "may be empty"	stage := self ownerThatIsA: ScratchStageMorph.	sel := (blockSpec at: 3) asSymbol.	#gotoX:y: = sel ifTrue: [		defaultArgs := Array			with: self referencePosition x rounded			with: self referencePosition y rounded].	#glideSecs:toX:y:elapsed:from: = sel ifTrue: [		defaultArgs := Array			with: 1			with: self referencePosition x rounded			with: self referencePosition y rounded].	#motor:direction: = self ifTrue: [		defaultArgs := Array with: 'reverse' localized with: 'this way' localized with: 'that way'].	#setSizeTo: = sel ifTrue: [		currentSize := (100.0 * (self scalePoint x max: self scalePoint y)) rounded.		defaultArgs := Array with: currentSize].	#getAttribute:of: = sel ifTrue: [		(stage := self ownerThatIsA: ScratchStageMorph) ifNotNil: [			list := stage submorphs select: [:m | m isKindOf: ScratchSpriteMorph].			list sort: [:s1 :s2 | s1 objName asLowercase < s2 objName asLowercase].			list size > 0				ifTrue: [defaultArgs := Array with: 'x position' with: list first]				ifFalse: [defaultArgs := Array with: 'background #' with: stage]]		ifNil:[defaultArgs := Array with: 'x position' with: self]].	#concatenate:with: = sel ifTrue: [		defaultArgs := Array with: 'hello ' localized with: 'world' localized].	#doAsk = sel ifTrue: [		defaultArgs := Array with: 'What''s your name?' localized].	#letter:of: = sel ifTrue: [		defaultArgs := Array with: 1 with: 'world' localized].	#stringLength: = sel ifTrue: [		defaultArgs := Array with: 'world' localized].	#say:duration:elapsed:from: = sel ifTrue: [		defaultArgs := Array with: 'Hello!!' localized with: 2].	#say: = sel ifTrue: [		defaultArgs := Array with: 'Hello!!' localized].	#think:duration:elapsed:from: = sel ifTrue: [		defaultArgs := Array with: 'Hmm...' localized with: 2].	#think: = sel ifTrue: [		defaultArgs := Array with: 'Hmm...' localized].	(#(lookLike: showBackground:) includes: sel) ifTrue: [		defaultArgs := Array with: self costumeNames last].	(#(playSound: doPlaySoundAndWait) includes: sel) ifTrue: [		list := self soundNames.		defaultArgs := list size <= 2			ifTrue: [Array with: '']			ifFalse: [Array with: (list at: (list size - 2))]].	(#(broadcast: doBroadcastAndWait) includes: sel) ifTrue: [		stage ifNotNil: [defaultArgs := Array with: stage defaultEventName]].	(#(append:toList: deleteLine:ofList: insert:at:ofList:) includes: sel) ifTrue: [		defaultArgs size >= 1 ifTrue: [			defaultArgs at: 1 put: (defaultArgs at: 1) localized]].	(#(append:toList: deleteLine:ofList: getLine:ofList: insert:at:ofList: lineCountOfList:)		includes: sel) ifTrue: [			defaultArgs := defaultArgs copyWith: self defaultListName].	#setLine:ofList:to: = sel ifTrue: [		defaultArgs size >= 3 ifTrue: [			defaultArgs at: 2 put: self defaultListName.			defaultArgs at: 3 put: (defaultArgs at: 3) localized]].	#appendLettersOf:toList: = sel ifTrue: [		defaultArgs size >= 2 ifTrue: [			defaultArgs at: 1 put: (defaultArgs at: 1) localized.			defaultArgs at: 2 put: self defaultListName]].	#list:contains: = sel ifTrue: [		defaultArgs size >= 2 ifTrue: [			defaultArgs at: 1 put: self defaultListName.			defaultArgs at: 2 put: (defaultArgs at: 2) localized]].	#scrollAndWait = sel ifTrue: [		defaultArgs := Array with: 'Hello!!'].	#animateAndWait = sel ifTrue: [		defaultArgs := Array with: 'A'].	^ defaultArgs! !!ScriptableScratchMorph methodsFor: 'private' stamp: 'EiichiroIto 9/7/2017 12:03'!hatBlocks	^ blocksBin submorphs select: [:m | m isKindOf: HatBlockMorph]! !!ScriptableScratchMorph methodsFor: 'microwitch'!replaceAllList: listName with: aString 	| list data |	list := self listNamed: listName ifNone: [^ 0].	data := aString findTokens: ' '.	list newContents: data! !!ScriptableScratchMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/19/2018 07:59'!vars	^ vars! !!ScratchSpriteMorph methodsFor: 'right button menu'!rightButtonMenu	"Present the right button menu."	"| menu |	menu _ CustomMenu new.	menu add: 'grab screen region for new costume' action: #grabFromScreen.	menu add: 'export this sprite' action: #exportObject.	menu addLine.	menu add: 'duplicate' action: #duplicate.	menu add: 'delete' action: #undoableDeleteSprite.	menu addLine.	menu add: 'resize this sprite' action: #resizeHandle.	menu add: 'rotate this sprite' action: #rotateHandle.	menu localize; invokeOn: self."! !!ScratchStageMorph methodsFor: 'initialization'!initialize	super initialize.	color _ Color white.	self enableDragNDrop: true.	objName _ 'Stage' localized.	costume _ self defaultImageMedia.	media _ OrderedCollection with: costume "with: SoundMedia new".	zoom _ 1.0.	hPan _ 0.	vPan _ 0.	runningBlocks _ OrderedCollection new.	inProcessStep _ false.	sensorBoard _ SensorBoardMorph new.	midiPortNum _ -1.	notePlayerDict _ Dictionary new.	obsoleteSavedState _ nil.	sprites _ OrderedCollection new.	showMotorBlocks _ false.! !!ScratchStageMorph methodsFor: 'menus'!rightButtonMenu	"Present the right button menu."	| menu |	menu := CustomMenu new.	menu add: 'new micro:bit sprite' action: #createNewMicrobitSprite.	menu addLine.	menu add: 'save picture of stage...' action: #stageShot.	menu localize; invokeOn: self.! !!ScratchStageMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!createNewMicrobitSprite	| frame morph |	(frame := self ownerThatIsA: ScratchFrameMorph) ifNil: [^ self].	morph := MicrobitSpriteMorph new addMediaItem: (ImageMedia new mediaName: 'costume' localized , '1';				 form: (ScratchFrameMorph skinAt: #defaultSpriteCostume)).	frame addAndView: morph! !!ScriptableScratchMorph class methodsFor: 'block specs'!blockColorFor: aCategory	"Answer the block color for the given category."	'control' = aCategory ifTrue: [^ (Color h: 41 s: 0.85 v: 0.9)].	'io' = aCategory ifTrue: [^ (Color h: 225 s: 0.65 v: 0.83)].	'motor' = aCategory ifTrue: [^ (Color h: 220 s: 0.85 v: 0.725)].	'led' = aCategory ifTrue: [^ (Color h: 264 s: 0.62 v: 0.89)].	'comm' = aCategory ifTrue: [^ (Color h: 165 s: 1 v: 0.63)].	'operators' = aCategory ifTrue: [^ (Color h: 93 s: 0.9 v: 0.76)].	'sound' = aCategory ifTrue: [^ (Color h: 296 s: 0.66 v: 0.85)].	'sensing' = aCategory ifTrue: [^ (Color h: 200 s: 0.98 v: 0.86)].	'variables' = aCategory ifTrue: [^ (Color h: 25 s: 0.88 v: 0.95)].	'list' = aCategory ifTrue: [^ ListBlockColor].	^ (Color h: 0 s: 0.81 v: 0.83)  "a shade of red"! !!ScriptableScratchMorph class methodsFor: 'block specs'!blockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector> [optional initial argument values]).	Explanation of flags:		-	no flags		b	boolean reporter		c	c-shaped block containing a sequence of commands (always special form)		r	reporter		s	special form command with its own evaluation rule		t	timed command, like wait or glide		E	message event hat		K	key event hat		M	mouse-click event hat		S	start event hat		W	when <condition> hat (obsolete)"	^ self controlBlocks, self operatorsBlocks, self variablesBlocks! !!ScriptableScratchMorph class methodsFor: 'other'!isSpriteSpecificTarget: anObject selector: selector	"I determine whether the given selector is specific to a particular Sprite. ."	| i |	true ifTrue: [^ true].	(anObject isKindOf: ScratchSpriteMorph) ifFalse: [^ false].	i := selector asString		findAnySubStr: #('answer' 'key' 'Loud' 'mouse' 'sensor' 'soundLevel' 'tempo' 'timer')		startingAt: 1.	^ i > selector asString size! !!ScriptableScratchMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!controlBlocks	^ #(		'control'			('when %m clicked'				S	-)			-			('forever'						c	doForever)			('repeat %n'					c	doRepeat 10)			('while %b'					c	doWhile)			('repeat until %b'		c	doUntil)			-			('break'						-	break)			('continue'					-	continue)			-			('if %b'							c	doIf)			('if %b'							c	doIfElse)	)! !!ScriptableScratchMorph class methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!operatorsBlocks	^ #(		'operators'			('%n + %n'						r	x:plusY: - -)			('%n - %n'						r	x:minusY: - -)			('%n * %n'						r	x:mulY: - -)			('%n / %n'						r	x:divY: - -)			('%n mod %n'					r	x:modY: - -)			-			('pick random %n to %n'		r	randomFrom:to: 1 10)			('set random seed to %n'		-	setRandomSeed: 1234)			-			('%s < %s'						b	less:than: '' '')			('%s = %s'						b	equal:to: '' '')			('%s > %s'						b	more:than: '' '')			-			('%b and %b'				b	x:andY:)			('%b or %b'					b	x:orY:)			('not %b'						b	not:)			('true'							b	true)			('false'							b	false)			-			('string of %n'				r	stringOf:	0)			('join %s %s'				r	concatenate:with: 'hello ' 'world')			('letter %n of %s'			r	letter:of: 0 'world')			('length of %s'				r	stringLength: 'world')			('any of %s'					r	anyOf: )			-			('round %n'					r	rounded -)			('abs %n'						r	abs -)			('abs %n sign %n'			r	abs:sign:	- -)			-			('%f of %n'					r	computeFunction:of: 'sqrt' 10)	)! !!ScriptableScratchMorph class methodsFor: 'microwitch'!variablesBlocks	^ #(		'list'			('add %s to %L'					-	append:toList: 'thing')			-			('delete %y of %L'				-	deleteLine:ofList: 0)			('insert %s at %i of %L'			-	insert:at:ofList: 'thing' 0)			('replace item %i of %L with %s'		-	setLine:ofList:to: 0 'list' 'thing')			('replace all items of %L with %s'		- replaceAllList:with: 'list' 'a b c')			-			('item %i of %L'					r	getLine:ofList: 0)			('length of %L'					r	lineCountOfList:)			('%L contains %s'				b	list:contains: 'list' 'thing')	)! !!ScratchSpriteMorph class methodsFor: 'block specs'!blockSpecs	^ super blockSpecs! !!ScratchStageMorph class methodsFor: 'block specs'!blockSpecs	^ super blockSpecs! !!String methodsFor: 'microwitch' stamp: 'EiichiroIto 7/2/2018 21:11'!animateOn: aLed atInterval: anInteger	aLed animateString: self interval: anInteger.! !!String methodsFor: 'microwitch' stamp: 'EiichiroIto 6/19/2018 07:21'!isNumberString	| aStream d pointNumber digitAppears |	pointNumber := false.	digitAppears := false.	aStream := ReadStream on: self.	aStream peek = $- ifTrue: [aStream next].	[aStream atEnd]		whileFalse: 			[d := aStream next.			d = $.				ifTrue: 					[pointNumber ifTrue: [^ false].					pointNumber := true]				ifFalse: [(d < $0 or: [d > $9])						ifTrue: [^ false]						ifFalse: [digitAppears := true]]].	^ digitAppears! !!String class methodsFor: 'instance creation' stamp: 'EiichiroIto 6/13/2018 12:13'!lf	"Answer a string containing a linefeed."	^ self with: Character lf! !!VariableBlockMorph methodsFor: 'microwitch' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: aGenerator	^ aGenerator variableArgString: self.! !!WriteStream methodsFor: 'character writing' stamp: 'EiichiroIto 6/13/2018 12:12'!lf	"Append linefeed characters to the receiver."	self nextPutAll: String lf.! !ScratchThread initialize!ScratchThread initialize.ObjStream initialize.ScratchFrameMorph readDefaultSprite.ScratchFrameMorph readMicrowitchLogo.ScratchFrameMorph createCategories.ScriptableScratchMorph buildBlockSpecDictionary.MicrobitImage initialize.!
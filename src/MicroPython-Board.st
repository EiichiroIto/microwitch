Object subclass: #MPBoardProcess	instanceVariableNames: 'expression topBlock readyToYield errorFlag readyToTerminate mpboard code '	classVariableNames: ''	poolDictionaries: ''	category: 'MicroPython-Board'!!MPBoardProcess methodsFor: 'initialization'!initialize	expression := nil.	readyToYield := false.	errorFlag := false.	readyToTerminate := false.! !!MPBoardProcess methodsFor: 'entry points'!runStepFor: aStageMorph 	mpboard isConnecting		ifTrue: [code				ifNil: 					[mpboard isRunning ifTrue: [^ mpboard stop; step].					code := MicrobitCode new newlineCR; pythonScriptFrom: {topBlock} stageMorph: aStageMorph.					mpboard request: code]				ifNotNil: [mpboard isRunning ifFalse: [readyToTerminate := true]]]		ifFalse: [readyToTerminate := true].	readyToTerminate		ifTrue: 			[(expression isKindOf: BlockMorph)				ifTrue: [expression litUp: false].			expression := nil]! !!MPBoardProcess methodsFor: 'entry points'!stop	mpboard isRunning ifTrue: [mpboard stop].	readyToYield := true.	readyToTerminate := true.	topBlock ifNotNil: [topBlock scratchProc: nil].! !!MPBoardProcess methodsFor: 'accessing' stamp: 'EiichiroIto 6/25/2019 14:48'!errorFlag	^ errorFlag! !!MPBoardProcess methodsFor: 'accessing'!errorFlag: aBoolean 	errorFlag := aBoolean.	expression showError.	expression topBlock showErrorFeedback.! !!MPBoardProcess methodsFor: 'accessing'!expression: anObject	expression ifNotNil: [self error: 'Cannot modify expression'].	expression := anObject.! !!MPBoardProcess methodsFor: 'accessing'!includesDeletedReceiver	^ (expression isKindOf: CommandBlockMorph)		and: [expression receiver owner isNil]! !!MPBoardProcess methodsFor: 'accessing'!includesReceiver: anObject 	^ (expression respondsTo: #receiver)		and: [expression receiver == anObject]! !!MPBoardProcess methodsFor: 'accessing'!isRunning	^ expression notNil		and: [errorFlag not and: [self includesDeletedReceiver not]]! !!MPBoardProcess methodsFor: 'accessing' stamp: 'EiichiroIto 6/25/2019 20:36'!mpboard: anObject	mpboard := anObject.! !!MPBoardProcess methodsFor: 'accessing' stamp: 'EiichiroIto 6/25/2019 14:48'!topBlock: aBlock 	topBlock := aBlock.! !Object subclass: #MicroPythonBoard	instanceVariableNames: 'port portName currentState response count requests returnValue interrupt '	classVariableNames: 'PasteModeString PromptString '	poolDictionaries: ''	category: 'MicroPython-Board'!!MicroPythonBoard methodsFor: 'accessing' stamp: 'EiichiroIto 6/23/2019 20:42'!count	^ count! !!MicroPythonBoard methodsFor: 'accessing' stamp: 'EiichiroIto 6/23/2019 20:43'!count: anInteger	count := anInteger.! !!MicroPythonBoard methodsFor: 'accessing' stamp: 'EiichiroIto 6/23/2019 20:40'!currentState	^ currentState! !!MicroPythonBoard methodsFor: 'accessing' stamp: 'EiichiroIto 6/23/2019 20:43'!portName	^ portName! !!MicroPythonBoard methodsFor: 'accessing' stamp: 'EiichiroIto 6/24/2019 21:53'!requests	^ requests! !!MicroPythonBoard methodsFor: 'accessing' stamp: 'EiichiroIto 6/22/2019 15:39'!response	^ response! !!MicroPythonBoard methodsFor: 'accessing' stamp: 'EiichiroIto 6/23/2019 20:38'!returnValue	^ returnValue! !!MicroPythonBoard methodsFor: 'commands'!evaluate: aString timeout: anInteger 	| timeout |	self portIsOpen ifFalse: [^ nil].	self isReady ifFalse: [^ nil].	self request: aString.	self doSend.	timeout := Time millisecondClockValue + anInteger.	[Time millisecondClockValue > timeout]		whileFalse: 			[self step.			self isReady ifTrue: [^ self returnValue]].	^ nil! !!MicroPythonBoard methodsFor: 'commands'!reboot	interrupt := #reboot.! !!MicroPythonBoard methodsFor: 'commands'!request: aString 	aString lines do: [:each | requests add: each].! !!MicroPythonBoard methodsFor: 'commands'!step	currentState = #disconnect ifTrue: [^ self].	currentState = #reboot ifTrue: [^ self].	count > 0 ifTrue: [count := count - 1].	currentState = #idle ifTrue: [^ count = 0 ifTrue: [self doIdle]].	currentState = #opening ifTrue: [^ count = 0 ifTrue: [self doOpening]].	currentState = #connecting ifTrue: [^ count > 0			ifTrue: [self doConnecting]			ifFalse: [self closePort]].	currentState = #running ifTrue: [^ self doRunning].	currentState = #ready ifTrue: [^ count > 0			ifTrue: [self doSend]			ifFalse: [self doOpening]].	self error: 'invalid state'! !!MicroPythonBoard methodsFor: 'commands'!stop	interrupt := #stop.	currentState = #reboot ifTrue: [self doIdle].! !!MicroPythonBoard methodsFor: 'commands'!write: aString fileNamed: aFilename 	| cmd tmp |	cmd := 'f = open(''' , aFilename , ''', ''w'')'.	self request: cmd.	aString lines do: 		[:each | 		tmp := each copyReplaceAll: '''' with: '\'''.		cmd := 'f.write(''' , tmp , '\n'')'.		self request: cmd].	cmd := 'f.close()'.	^ self request: cmd! !!MicroPythonBoard methodsFor: 'initialize'!initialize	super initialize.	currentState := #disconnect.	requests := OrderedCollection new.	response := ''.	portName := ''.	count := 0.! !!MicroPythonBoard methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self class name;	 nextPut: $(;	 nextPutAll: currentState asString;	 nextPut: $-;	 nextPutAll: count asString;	 nextPut: $,;	 nextPutAll: requests size asString;	 nextPut: $,;	 nextPutAll: returnValue asString;	 nextPut: $).! !!MicroPythonBoard methodsFor: 'private'!clearRequests	self portIsOpen ifTrue: [port flushInputBuffer].	requests := OrderedCollection new! !!MicroPythonBoard methodsFor: 'private'!clearResponse	response := ''.	returnValue := nil.! !!MicroPythonBoard methodsFor: 'private'!doConnecting	self portIsOpen ifFalse: [^ self closePort].	self clearResponse.	(self waitPromptFor: 100) ifNotNil: [self setupReady].! !!MicroPythonBoard methodsFor: 'private'!doIdle	self openPort: portName.! !!MicroPythonBoard methodsFor: 'private'!doOpening	interrupt = #stop ifTrue: [^ self doStop].	self portIsOpen ifFalse: [^ self closePort].	(port nextPut: 13)		= 0 ifTrue: [^ self closePort].	self setupConnecting! !!MicroPythonBoard methodsFor: 'private'!doReboot	interrupt := nil.	self portIsOpen ifFalse: [^ self].	(port nextPut: 4)		= 0 ifTrue: [^ self closePort].	self setupReboot.! !!MicroPythonBoard methodsFor: 'private' stamp: 'EiichiroIto 6/28/2019 16:37'!doRunning	interrupt = #stop ifTrue: [^ self doStop].	self portIsOpen ifFalse: [^ self closePort].	returnValue := self waitPromptFor: 100.	returnValue		ifNotNil: 			[self setupReady].! !!MicroPythonBoard methodsFor: 'private'!doSend	self portIsOpen ifFalse: [^ self closePort].	requests isEmpty		ifTrue: 			[interrupt = #reboot ifTrue: [self doReboot].			^ self].	self clearResponse.	port flushInputBuffer.	(port nextPut: 5)		= 0 ifTrue: [^ self closePort].	requests do: 		[:each | 		port nextPutAll: each.		port nextPut: 13.		(Delay forMilliseconds: 100) wait.		self processIncomingMessages].	requests := OrderedCollection new.	(port nextPut: 4)		= 0 ifTrue: [^ self closePort].	self setupRunning! !!MicroPythonBoard methodsFor: 'private'!doStop	interrupt := nil.	self portIsOpen ifFalse: [^ self].	(port nextPut: 3)		= 0 ifTrue: [^ self closePort].	self setupRunning.! !!MicroPythonBoard methodsFor: 'private'!parseResponse	| p i |	(response includesSubString: self class promptString)		ifFalse: [^ nil].	p := 1.	i := response findString: self class promptString startingAt: p.	^ response copyFrom: p to: i - 1! !!MicroPythonBoard methodsFor: 'private'!processIncomingMessages	self portIsOpen ifFalse: [^ self].	response := response, port readString.	self removeDelimiter.! !!MicroPythonBoard methodsFor: 'private'!removeDelimiter	| p i |	p := 1.		[i := response findString: self class pasteModeString startingAt: p.	i > 0]		whileTrue: [p := i + self class pasteModeString size].	p > 1 ifTrue: [response := response copyFrom: p to: response size].! !!MicroPythonBoard methodsFor: 'private' stamp: 'EiichiroIto 6/24/2019 17:59'!setupConnecting	currentState := #connecting.	count := 10.! !!MicroPythonBoard methodsFor: 'private'!setupIdle	currentState := #idle.	count := 300.! !!MicroPythonBoard methodsFor: 'private' stamp: 'EiichiroIto 6/24/2019 18:01'!setupOpening	currentState := #opening.	count := 10.! !!MicroPythonBoard methodsFor: 'private' stamp: 'EiichiroIto 6/28/2019 15:35'!setupReady	currentState := #ready.	count := 100.! !!MicroPythonBoard methodsFor: 'private' stamp: 'EiichiroIto 6/24/2019 22:35'!setupReboot	currentState := #reboot.	count := 0.! !!MicroPythonBoard methodsFor: 'private' stamp: 'EiichiroIto 6/28/2019 16:36'!setupRunning	currentState := #running.	count := 10.! !!MicroPythonBoard methodsFor: 'private'!waitPromptFor: anInteger 	| ret timeout |	self portIsOpen ifFalse: [^ nil].	timeout := Time millisecondClockValue + anInteger.	[(Delay forMilliseconds: 100) wait.	self processIncomingMessages.	ret := self parseResponse.	ret ifNotNil: [^ ret withBlanksTrimmed].	Time millisecondClockValue > timeout] whileFalse.	^ nil! !!MicroPythonBoard methodsFor: 'serial port'!closePort	port		ifNotNil: 			[port flushInputBuffer.			port close].	port := nil.	self clearRequests.	self setupIdle.! !!MicroPythonBoard methodsFor: 'serial port' stamp: 'EiichiroIto 6/27/2019 21:56'!disconnect	self closePort.	currentState := #disconnect.! !!MicroPythonBoard methodsFor: 'serial port'!openPort: aString 	| p |	self closePort.	p := SerialPort2 new openPortNamed: aString baud: self class defaultBaudRate.	p isOpen ifFalse: [^ self].	port := p.	portName := aString.	port flushInputBuffer.	self setupOpening.! !!MicroPythonBoard methodsFor: 'serial port' stamp: 'EiichiroIto 6/22/2019 11:18'!port	^ port! !!MicroPythonBoard methodsFor: 'serial port' stamp: 'EiichiroIto 6/22/2019 11:06'!portIsOpen	^ port notNil and: [port isOpen]! !!MicroPythonBoard methodsFor: 'serial port'!portNames	Smalltalk isUnix ifTrue: [^ self unixPortNames].	Smalltalk isWindows ifTrue: [^ MicrowitchPlugin enumerateComPorts lines].	ScratchPlugin serialPortOpsAvailable ifFalse: [^ (1 to: 32)			collect: [:i | 'COM' , i printString]].	^ SerialPort2 portNames		reject: [:n | (n asLowercase includesSubString: 'modem')				or: [n asLowercase includesSubString: 'pda-sync']]! !!MicroPythonBoard methodsFor: 'serial port'!unixPortNames	| dir list |	dir := FileDirectory on: '/dev/'.	list := dir fileNames.	list := list				select: [:each | (each beginsWith: 'ttyUSB')						or: [each beginsWith: 'ttyACM']].	^ list collect: [:each | dir fullNameFor: each]! !!MicroPythonBoard methodsFor: 'testing' stamp: 'EiichiroIto 6/24/2019 18:48'!isConnecting	^ (#(disconnect idle opening connecting) includes: currentState) not! !!MicroPythonBoard methodsFor: 'testing' stamp: 'EiichiroIto 6/24/2019 18:49'!isError	^ (response includesSubString: 'Traceback')		or: [response includesSubString: 'Error']! !!MicroPythonBoard methodsFor: 'testing'!isReady	^ currentState = #ready! !!MicroPythonBoard methodsFor: 'testing'!isRunning	^ currentState = #reboot or: [currentState = #running]! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MicroPythonBoard class	instanceVariableNames: ''!!MicroPythonBoard class methodsFor: 'private' stamp: 'EiichiroIto 6/22/2019 11:02'!defaultBaudRate	^ 115200! !!MicroPythonBoard class methodsFor: 'private'!defaultTimeout	^ 10000! !!MicroPythonBoard class methodsFor: 'private' stamp: 'EiichiroIto 6/23/2019 17:36'!reset	"MicroPythonBoard reset."	PasteModeString := nil.	PromptString := nil.! !!MicroPythonBoard class methodsFor: 'accessing'!pasteModeString	^ PasteModeString ifNil: [PasteModeString := String crlf , '===']! !!MicroPythonBoard class methodsFor: 'accessing' stamp: 'EiichiroIto 6/22/2019 16:12'!promptString	^ PromptString ifNil: [PromptString := String crlf , '>>> ']! !
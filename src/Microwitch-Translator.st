Object subclass: #IntelHex	instanceVariableNames: 'stream address checksum '	classVariableNames: ''	poolDictionaries: ''	category: 'Microwitch-Translator'!!IntelHex methodsFor: 'accessing' stamp: 'EiichiroIto 6/26/2018 07:17'!address	^ address! !!IntelHex methodsFor: 'accessing' stamp: 'EiichiroIto 6/27/2018 19:00'!address: anInteger	address := anInteger bitAnd: 16rFFFF.! !!IntelHex methodsFor: 'accessing' stamp: 'EiichiroIto 6/27/2018 19:00'!script: aString 	| size str |	size := aString size.	str := 'MP' , (String with: (Character value: size \\ 256)					with: (Character value: size // 256)) , aString.	size := str size.	str := str , (String new: 16 - (size \\ 16) withAll: (Character value: 0)).	^ self generateString: str! !!IntelHex methodsFor: 'accessing' stamp: 'EiichiroIto 6/26/2018 07:22'!stream	^ stream! !!IntelHex methodsFor: 'accessing' stamp: 'EiichiroIto 6/26/2018 07:22'!stream: aStream	stream := aStream! !!IntelHex methodsFor: 'private' stamp: 'EiichiroIto 6/26/2018 07:23'!clearChecksum	checksum := 0! !!IntelHex methodsFor: 'private' stamp: 'EiichiroIto 6/26/2018 07:48'!generateByte: anInteger	checksum := checksum + anInteger.	stream nextPutAll: anInteger asHexString! !!IntelHex methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!generateChecksum	| data |	data := checksum negated bitAnd: 16rFF.	stream nextPutAll: data asHexString.	stream lf.	self clearChecksum.! !!IntelHex methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!generateChunk: aString 	aString do: [:each | self generateByte: each asciiValue]! !!IntelHex methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!generateSize: anInteger	stream nextPut: $:.	self generateByte: anInteger.	self generateByte: address // 256.	self generateByte: address \\ 256.	self generateByte: 0.! !!IntelHex methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!generateString: aString 	| total size end chunk |	total := aString size.	1		to: total		by: 16		do: 			[:each | 			self clearChecksum.			end := each + 15 min: total.			size := end - each + 1.			self generateSize: size.			chunk := aString copyFrom: each to: end.			self generateChunk: chunk.			self generateChecksum.			address := (address + size) bitAnd: 16rFFFF]! !Object subclass: #MicrobitCode	instanceVariableNames: 'generator stream varNo modules listVars vars '	classVariableNames: 'Firmware LedDict MusicDict SensorDict '	poolDictionaries: ''	category: 'Microwitch-Translator'!!MicrobitCode methodsFor: 'accessing' stamp: 'EiichiroIto 6/14/2018 22:29'!generator: aCodeGenerator stream: aStream	generator := aCodeGenerator.	stream := aStream.! !!MicrobitCode methodsFor: 'accessing' stamp: 'EiichiroIto 6/27/2018 19:00'!hexCodeFrom: aCollection stageMorph: aMorph 	| script intelHex out |	out := WriteStream on: ''.	out nextPutAll: self class mainFirmware.	out nextPutAll: ':020000040003F7'.	out lf.	intelHex := IntelHex new address: 57344;			 stream: out.	script := self pythonScriptFrom: aCollection stageMorph: aMorph.	intelHex script: script.	out nextPutAll: self class restFirmware.	^ out contents! !!MicrobitCode methodsFor: 'accessing' stamp: 'EiichiroIto 6/26/2018 10:29'!pythonScriptFrom: aCollection stageMorph: aMorph	| codeGenerator code header |	codeGenerator := ScratchCodeGenerator hats: aCollection target: self.	code := codeGenerator codeString.	header := codeGenerator headerStringOf: aMorph.	^ header, code! !!MicrobitCode methodsFor: 'accessing' stamp: 'EiichiroIto 6/16/2018 10:40'!stream: aStream	stream := aStream.! !!MicrobitCode methodsFor: 'arg generator' stamp: 'EiichiroIto 6/27/2018 19:00'!argString: anArgMorph 	| v |	^ anArgMorph labelMorph		ifNil: [self error: 'nil arg']		ifNotNil: 			[v := anArgMorph evaluate.			self literalStringFrom: v]! !!MicrobitCode methodsFor: 'arg generator' stamp: 'EiichiroIto 6/27/2018 19:00'!expressionArgWithMenuString: aMorph 	| v |	v := aMorph specialValue.	v ifNil: [^ self argString: aMorph].	aMorph ownerSelector = #append:toList:		ifTrue: 			[v = #all ifTrue: [^ ':'].			v = #last ifTrue: [^ '-1']].	aMorph ownerSelector = #setLine:ofList:to:		ifTrue: 			[v = #last ifTrue: [^ '-1']].	^ v! !!MicrobitCode methodsFor: 'arg generator' stamp: 'EiichiroIto 6/18/2018 20:10'!falseString	^ 'False'.! !!MicrobitCode methodsFor: 'arg generator' stamp: 'EiichiroIto 6/27/2018 19:00'!variableArgString: aString	self useVar: aString.	^ aString! !!MicrobitCode methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!generateElse	stream nextPutAll: 'else:'; lf! !!MicrobitCode methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!generateExpr: aCollection	| str |	aCollection do: 		[:each | 		str := each argString: generator.		stream nextPutAll: str.		stream nextPut: $,].	stream skip: -1.! !!MicrobitCode methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!generateHeaderOf: aWorkpane	stream nextPutAll: 'import microbit';	 lf.	modules do: 		[:each | 		stream nextPutAll: 'import '.		stream nextPutAll: each.		stream lf].	stream lf.	self generateInitVarsIn: aWorkpane vars.	self generateInitListsIn: aWorkpane lists.! !!MicrobitCode methodsFor: 'code generator' stamp: 'EiichiroIto 6/15/2018 08:53'!generateIndent: anInteger	anInteger timesRepeat: [stream nextPutAll: '    '].! !!MicrobitCode methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!generateInitList: aString in: aDictionary 	| list val |	stream nextPutAll: aString.	stream nextPutAll: ' = []'.	stream lf.	list := aDictionary at: aString ifAbsent: [^ self].	0 to: list lineCount - 1 do: 		[:each | 		val := list lineAt: each.		val := self literalStringFrom: val.		stream nextPutAll: aString.		stream nextPut: $[.		stream nextPutAll: each asString.		stream nextPutAll: '] = '.		stream nextPutAll: val.		stream lf].! !!MicrobitCode methodsFor: 'code generator' stamp: 'EiichiroIto 6/19/2018 08:20'!generateInitListsIn: aDictionary	listVars do: [:each | self generateInitList: each in: aDictionary ].! !!MicrobitCode methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!generateInitVar: aString in: aDictionary	| val |	val := aDictionary at: aString ifAbsent: [ ^ self ].	val := self literalStringFrom: val.	stream nextPutAll: aString.	stream nextPutAll: ' = '.	stream nextPutAll: val.	stream lf.! !!MicrobitCode methodsFor: 'code generator' stamp: 'EiichiroIto 6/19/2018 07:57'!generateInitVarsIn: aDictionary	vars do: [:each | self generateInitVar: each in: aDictionary ].! !!MicrobitCode methodsFor: 'code generator' stamp: 'EiichiroIto 6/15/2018 10:42'!generateLineFeed	stream lf! !!MicrobitCode methodsFor: 'code generator' stamp: 'EiichiroIto 6/15/2018 10:38'!generatePass	stream nextPutAll: 'pass'; lf! !!MicrobitCode methodsFor: 'control blocks' stamp: 'EiichiroIto 6/16/2018 11:38'!break: aMorph	stream nextPutAll: 'break'.! !!MicrobitCode methodsFor: 'control blocks' stamp: 'EiichiroIto 6/16/2018 11:38'!continue: aMorph	stream nextPutAll: 'continue'.! !!MicrobitCode methodsFor: 'control blocks' stamp: 'EiichiroIto 6/15/2018 06:19'!doForever: aMorph	stream nextPutAll: 'while True:'! !!MicrobitCode methodsFor: 'control blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!doIf: aMorph	stream nextPutAll: 'if '.	self generateExpr: aMorph blockArgs.	stream nextPutAll: ':'.! !!MicrobitCode methodsFor: 'control blocks' stamp: 'EiichiroIto 6/15/2018 07:39'!doIfElse: aMorph	self doIf: aMorph! !!MicrobitCode methodsFor: 'control blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!doRepeat: aMorph	| str |	stream nextPutAll: 'for '.	stream nextPutAll: self newVariable.	stream nextPutAll: ' in range('.	str := aMorph blockArgs first argString: generator.	stream nextPutAll: str.	stream nextPutAll: '):'.! !!MicrobitCode methodsFor: 'control blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!doUntil: aMorph	stream nextPutAll: 'while not('.	self generateExpr: aMorph blockArgs.	stream nextPutAll: '):'.! !!MicrobitCode methodsFor: 'control blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!doWhile: aMorph	stream nextPutAll: 'while '.	self generateExpr: aMorph blockArgs.	stream nextPut: $:.! !!MicrobitCode methodsFor: 'control blocks' stamp: 'EiichiroIto 6/22/2018 06:53'!mwaitelapsedfrom: aMorph 	stream nextPutAll: (self unaryFunction: 'microbit.sleep' of: aMorph).! !!MicrobitCode methodsFor: 'control blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!panic: aMorph	stream nextPutAll: (self unaryFunction: 'microbit.panic' of: aMorph).! !!MicrobitCode methodsFor: 'control blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!waitMsec: aMorph	stream nextPutAll: (self unaryFunction: 'microbit.sleep' of: aMorph).! !!MicrobitCode methodsFor: 'initialization' stamp: 'EiichiroIto 6/27/2018 19:00'!initialize	super initialize.	varNo := 0.	modules := Set new.	listVars := Set new.	vars := Set new.! !!MicrobitCode methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!buttonIsPressed: aMorph	^ (self buttonString: aMorph blockArgs first), '.is_pressed()'.! !!MicrobitCode methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!buttonWasPressed: aMorph	^ (self buttonString: aMorph blockArgs first), '.was_pressed()'! !!MicrobitCode methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!countOfButtonPressed: aMorph	^ (self buttonString: aMorph blockArgs first), '.get_presses()'! !!MicrobitCode methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!pinIsTouched: aMorph	^ (self pinString: aMorph blockArgs first), '.is_touched()'! !!MicrobitCode methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!readAnalog: aMorph	^ (self pinString: aMorph blockArgs first), '.read_analog()'! !!MicrobitCode methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!readDigital: aMorph	^ (self pinString: aMorph blockArgs first), '.read_digital()'! !!MicrobitCode methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!setAnalogPeriodmsec: aMorph	| args str |	args := aMorph blockArgs.	self generatePin: args first.	stream nextPutAll: '.set_analog_period_microseconds('.	str := args second argString: generator.	stream nextPutAll: str.	stream nextPutAll: ')'.! !!MicrobitCode methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!writeAnalogto: aMorph	| args str |	args := aMorph blockArgs.	self generatePin: args first.	stream nextPutAll: '.write_analog('.	str := args second argString: generator.	stream nextPutAll: str.	stream nextPutAll: ')'.! !!MicrobitCode methodsFor: 'io blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!writeDigitalto: aMorph	| args str |	args := aMorph blockArgs.	self generatePin: args first.	stream nextPutAll: '.write_digital('.	str := args second argString: generator.	stream nextPutAll: str.	stream nextPutAll: ')'.! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/19/2018 08:37'!allArrowsImage: aMorph	^ 'microbit.Image.ALL_ARROWS'! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/19/2018 08:37'!allClocksImage: aMorph	^ 'microbit.Image.ALL_CLOCKS'! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!clearPixels: aMorph	stream nextPutAll: 'microbit.display.clear()'.! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!getPixelAtxy: aMorph	^ self binaryFunction: 'microbit.display.get_pixel' of: aMorph! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!imageOf: aMorph	^ self unaryFunction: 'microbit.Image' of: aMorph! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!isOnLed: aMorph	^ 'microbit.display.is_on()'! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!offLed: aMorph	stream nextPutAll: 'microbit.display.off()'.! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!onLed: aMorph	stream nextPutAll: 'microbit.display.on()'.! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!scroll: aMorph 	| str |	stream nextPutAll: 'microbit.display.scroll(str('.	str := aMorph blockArgs first argString: generator.	stream nextPutAll: str.	stream nextPutAll: '), wait=False)'! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!scrollAndWait: aMorph 	| str |	stream nextPutAll: 'microbit.display.scroll(str('.	str := aMorph blockArgs first argString: generator.	stream nextPutAll: str.	stream nextPutAll: '))'! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!setPixelAtxyv: aMorph	| args x y v |	args := aMorph blockArgs.	stream nextPutAll: 'microbit.display.set_pixel('.	x := args first argString: generator.	y := args second argString: generator.	v := args third argString: generator.	stream nextPutAll: x.	stream nextPut: $,.	stream nextPutAll: y.	stream nextPut: $,.	stream nextPutAll: v.	stream nextPut: $).! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!showChar: aMorph	stream nextPutAll: (self unaryFunction: 'microbit.display.show' of: aMorph).! !!MicrobitCode methodsFor: 'led blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!showSymbol: aMorph	stream nextPutAll: 'microbit.display.show(microbit.Image.'.	stream nextPutAll: (self class showSymbolAt: aMorph blockArgs first choice).	stream nextPutAll: ')'.! !!MicrobitCode methodsFor: 'music blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!getTempo: aMorph	self useMusic.	^ 'music.get_tempo()'.! !!MicrobitCode methodsFor: 'music blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!playMusicList: aMorph	self useMusic.! !!MicrobitCode methodsFor: 'music blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!playMusicSymbol: aMorph	self useMusic.	stream nextPutAll: 'music.play('.	stream nextPutAll: (self class musicSymbolAt: aMorph blockArgs first choice).	stream nextPutAll: ')'.! !!MicrobitCode methodsFor: 'music blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!playMusicSymbolRepeat: aMorph	self useMusic.	stream nextPutAll: 'music.play('.	stream nextPutAll: (self class musicSymbolAt: aMorph blockArgs first choice).	stream nextPutAll: ', loop=True)'.! !!MicrobitCode methodsFor: 'music blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!playMusicSymbolWait: aMorph	self useMusic.	stream nextPutAll: 'music.play('.	stream nextPutAll: (self class musicSymbolAt: aMorph blockArgs first choice).	stream nextPutAll: ', wait=True)'.! !!MicrobitCode methodsFor: 'music blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!playPitchmsec: aMorph	| args p d |	args := aMorph blockArgs.	p := args first argString: generator.	d := args second argString: generator.	self useMusic.	stream nextPutAll: 'music.pitch('.	stream nextPutAll: p.	stream nextPutAll: ', duration='.	stream nextPutAll: d.	stream nextPut: $).! !!MicrobitCode methodsFor: 'music blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!resetMusic: aMorph	self useMusic.	stream nextPutAll: 'music.reset()'.! !!MicrobitCode methodsFor: 'music blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!resetTempo: aMorph	self useMusic.	stream nextPutAll: 'music.set_tempo()'.! !!MicrobitCode methodsFor: 'music blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!setTempoBpm: aMorph	| str |	self useMusic.	stream nextPutAll: 'music.set_tempo(bpm='.	str := aMorph blockArgs first argString: generator.	stream nextPutAll: str.	stream nextPut: $).! !!MicrobitCode methodsFor: 'music blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!setTempoTicks: aMorph	| str |	self useMusic.	stream nextPutAll: 'music.set_tempo(ticks='.	str := aMorph blockArgs first argString: generator.	stream nextPutAll: str.	stream nextPut: $).! !!MicrobitCode methodsFor: 'music blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!stopMusic: aMorph	self useMusic.	stream nextPutAll: 'music.stop()'.! !!MicrobitCode methodsFor: 'variables blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!appendtoList: aMorph	| args var |	args := aMorph blockArgs.	var := args second choice.	self useListVar: var.	stream nextPutAll: var.	stream nextPutAll: (self unaryFunction: '.append' of: aMorph).! !!MicrobitCode methodsFor: 'variables blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!changeVarby: aMorph	| args var val |	args := aMorph blockArgs.	var := args first choice.	val := args second argString: generator.	self useVar: var.	stream nextPutAll: var.	stream nextPutAll:  ' = '.	stream nextPutAll: var.	stream nextPutAll:  ' + '.	stream nextPutAll: val.! !!MicrobitCode methodsFor: 'variables blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!contentsOfList: aMorph	| var |	var := aMorph commandSpec.	self useListVar: var.	^ var! !!MicrobitCode methodsFor: 'variables blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!deleteLineofList: aMorph 	| args var pos |	args := aMorph blockArgs.	var := args second choice.	pos := args first argString: generator.	self useListVar: var.	stream nextPutAll: 'del '.	stream nextPutAll: var.	stream nextPut: $[.	pos = #all		ifTrue: [stream nextPut: $:]		ifFalse: [pos = #last				ifTrue: [stream nextPutAll: '-1']				ifFalse: [stream nextPutAll: pos]].	stream nextPut: $]! !!MicrobitCode methodsFor: 'variables blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!getLineofList: aMorph 	| args var pos |	args := aMorph blockArgs.	var := args second choice.	pos := args first argString: generator.	self useListVar: var.	pos = #any		ifTrue: 			[self useRandom.			^ 'random.choice(' , var , ')']		ifFalse: [pos = #last ifTrue: [pos := '-1']].	^ var , '[' , pos , ']'! !!MicrobitCode methodsFor: 'variables blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!insertatofList: aMorph	| args list pos val |	args := aMorph blockArgs.	val := args first argString: generator.	pos := args second argString: generator.	list := args third choice.	self useListVar: list.	stream nextPutAll: list.	stream nextPutAll: '.insert('.	stream nextPutAll: pos.	stream nextPut: $,.	stream nextPutAll: val.	stream nextPut: $).! !!MicrobitCode methodsFor: 'variables blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!lineCountOfList: aMorph	| args var |	args := aMorph blockArgs.	var := args first choice.	self useListVar: var.	^ 'len(', var, ')'! !!MicrobitCode methodsFor: 'variables blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!listcontains: aMorph 	| args var val |	args := aMorph blockArgs.	var := args first choice.	val := args second argString: generator.	self useListVar: var.	^ val, ' in ', var! !!MicrobitCode methodsFor: 'variables blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!setLineofListto: aMorph 	| args var pos val |	args := aMorph blockArgs.	pos := args first argString: generator.	var := args second choice.	val := args third argString: generator.	self useListVar: var.	pos = #any		ifTrue: 			[self useRandom.			pos := 'random.randrange(len(' , var , '))']		ifFalse: [pos = #last ifTrue: [pos := '-1']].	stream nextPutAll: var.	stream nextPut: $[.	stream nextPutAll: pos.	stream nextPutAll: '] = '.	stream nextPutAll: val! !!MicrobitCode methodsFor: 'variables blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!setVarto: aMorph	| args var val |	args := aMorph blockArgs.	var := args first choice.	val := args second argString: generator.	self useVar: var.	stream nextPutAll: var.	stream nextPutAll:  ' = '.	stream nextPutAll: val.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!abs: aMorph	^ self unaryFunction: 'abs' of: aMorph.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!abssign: aMorph	self useMath.	^ self binaryFunction: 'math.copysign' of: aMorph! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/19/2018 08:43'!anyOf: aMorph	self useRandom.	^ self unaryFunction: 'random.random_choice' of: aMorph! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!computeFunctionof: aMorph	| args f v |	self useMath.	args := aMorph blockArgs.	f := args first choice.	v := args second argString: generator.	^ 'math.', f, '(', v, ')'! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!concatenatewith: aBlock 	| args a b |	args := aBlock blockArgs.	a := args first argString: generator.	b := args second argString: generator.	^ a, '+', b! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:39'!equalto: aMorph 	^ self binary: ' == ' morph: aMorph.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:47'!false: aMorph	^ 'False'! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:38'!lessthan: aMorph 	^ self binary: ' < ' morph: aMorph.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!letterof: aMorph	| args a b |	args := aMorph blockArgs.	a := args first argString: generator.	b := args second argString: generator.	^ '(', b, ')[', a, ']'! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:39'!morethan: aMorph 	^ self binary: ' > ' morph: aMorph.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!randomFromto: aMorph	^ self binaryFunction: 'random.randint' of: aMorph! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!rounded: aMorph	^ self unaryFunction: 'round' of: aMorph! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!setRandomSeed: aMorph	self useRandom.	stream nextPutAll: (self unaryFunction: 'random.seed' of: aMorph)..! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!stringLength: aMorph	^ self unaryFunction: 'len' of: aMorph! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!stringOf: aMorph	^ self unaryFunction: 'str' of: aMorph.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:47'!true: aMorph	^ 'True'! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:42'!xandY: aMorph 	^ self binary: ' and ' morph: aMorph.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:25'!xdivY: aMorph 	^ self binary: ' / ' morph: aMorph.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:25'!xminusY: aMorph 	^ self binary: ' - ' morph: aMorph.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:25'!xmodY: aMorph 	^ self binary: ' % ' morph: aMorph.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:24'!xmulY: aMorph 	^ self binary: ' * ' morph: aMorph.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:43'!xorY: aMorph 	^ self binary: ' or ' morph: aMorph.! !!MicrobitCode methodsFor: 'operators blocks' stamp: 'EiichiroIto 6/23/2018 11:24'!xplusY: aMorph 	^ self binary: ' + ' morph: aMorph.! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!binary: aString morph: aMorph 	| args a b |	args := aMorph blockArgs.	a := args first argString: generator.	b := args second argString: generator.	^ '(', a, aString, b, ')'! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!binaryFunction: aString of: aMorph	| args a b |	args := aMorph blockArgs.	a := args first argString: generator.	b := args second argString: generator.	^ aString, '(', a, ',', b, ')'! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!buttonString: aMorph	^ 'microbit.button_', aMorph choice! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!generatePin: aMorph	| str |	str := self pinString: aMorph.	stream nextPutAll: str.! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!literalStringFrom: aString 	^ ((aString isKindOf: String)		and: [aString isNumberString not])		ifTrue: [self quotedString: aString]		ifFalse: [aString asString]! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/16/2018 11:16'!newVariable	varNo := varNo + 1.	^ 'var', varNo asString! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/18/2018 20:32'!pinString: aMorph	^ 'microbit.pin', aMorph evaluate asString! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!quotedString: aString 	| in out c |	in := ReadStream on: aString.	out := WriteStream on: ''.	out nextPut: $'.	[in atEnd]		whileFalse: 			[c := in next.			(c = $\ or: [c = $'])				ifTrue: [out nextPut: $\].			out nextPut: c].	out nextPut: $'.	^ out contents! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!unaryFunction: aString of: aMorph	| str |	str := aMorph blockArgs first argString: generator.	^ aString, '(', str, ')'! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/17/2018 11:49'!useListVar: aString	listVars add: aString.! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/17/2018 10:11'!useMath	modules add: #math.! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/16/2018 18:29'!useMusic	modules add: #music.! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/24/2018 20:09'!useRadio	modules add: #radio.! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/16/2018 18:29'!useRandom	modules add: #random.! !!MicrobitCode methodsFor: 'private' stamp: 'EiichiroIto 6/19/2018 07:26'!useVar: aString	vars add: aString.! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/16/2018 17:20'!calibrateCompass: aMorph	stream nextPutAll: 'microbit.compass.calibrate()'.! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/16/2018 17:21'!clearCalibration: aMorph	stream nextPutAll: 'microbit.compass.clear_calibration()'.! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!currentGesture: aMorph	^ 'microbit.accelerometer.current_gesture()'! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!fieldStrength: t1 	^ 'microbit.compass.get_field_strength()'! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!gestures: aMorph	^ 'microbit.accelerometer.get_gestures()'! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!headingCompass: aMorph	^ 'microbit.compass.heading()'.! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!isCalibrated: aMorph	^ 'microbit.compass.is_calibrated()'! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!isGesture: aMorph	^ 'microbit.accelerometer.is_gesture("', aMorph blockArgs first choice, '"'! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!runningTime: aMorph	^ 'microbit.running_time()'! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/23/2018 19:31'!sensorValueOf: aMorph	^ self class sensorCodeAt: aMorph blockArgs first choice asSymbol! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!temperature: aMorph	^ 'microbit.temperature()'! !!MicrobitCode methodsFor: 'sensor blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!wasGesture: aMorph	^ 'microbit.accelerometer.was_gesture("', aMorph blockArgs first choice, '"'! !!MicrobitCode methodsFor: 'comm blocks' stamp: 'EiichiroIto 6/24/2018 20:13'!offRadio: aMorph	self useRadio.	stream nextPutAll: 'radio.off()'.! !!MicrobitCode methodsFor: 'comm blocks' stamp: 'EiichiroIto 6/24/2018 20:12'!onRadio: aMorph	self useRadio.	stream nextPutAll: 'radio.on()'.! !!MicrobitCode methodsFor: 'comm blocks' stamp: 'EiichiroIto 6/24/2018 20:11'!receiveRadio: aMorph	self useRadio.	^ 'radio.receive()'! !!MicrobitCode methodsFor: 'comm blocks' stamp: 'EiichiroIto 6/24/2018 20:14'!resetRadio: aMorph	self useRadio.	stream nextPutAll: 'radio.reset()'.! !!MicrobitCode methodsFor: 'comm blocks' stamp: 'EiichiroIto 6/27/2018 19:00'!sendRadio: aMorph	self useRadio.	stream nextPutAll: (self unaryFunction: 'radio.send' of: aMorph).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MicrobitCode class	instanceVariableNames: ''!!MicrobitCode class methodsFor: 'accessing' stamp: 'EiichiroIto 6/26/2018 10:21'!mainFirmware	^ Firmware at: 1! !!MicrobitCode class methodsFor: 'accessing' stamp: 'EiichiroIto 6/27/2018 19:00'!musicSymbolAt: aSymbol	^ MusicDict at: aSymbol! !!MicrobitCode class methodsFor: 'accessing' stamp: 'EiichiroIto 6/26/2018 10:21'!restFirmware	^ Firmware at: 2! !!MicrobitCode class methodsFor: 'accessing' stamp: 'EiichiroIto 6/27/2018 19:00'!sensorCodeAt: aSymbol	^ SensorDict at: aSymbol! !!MicrobitCode class methodsFor: 'accessing' stamp: 'EiichiroIto 6/27/2018 19:00'!showSymbolAt: aSymbol	^ LedDict at: aSymbol! !!MicrobitCode class methodsFor: 'initialization' stamp: 'EiichiroIto 6/27/2018 19:00'!initialize	"MicrobitCode initialize."	self readFirmware.	self initializeLedDict.	self initializeMusicDict.	self initializeSensorDict.! !!MicrobitCode class methodsFor: 'initialization' stamp: 'EiichiroIto 6/26/2018 10:18'!initializeLedDict	LedDict := Dictionary new.	LedDict at: #heart put: 'HEART'.	LedDict at: #heartSmall put: 'HEART_SMALL'.	LedDict at: #happy put: 'HAPPY'.	LedDict at: #smile put: 'SMILE'.	LedDict at: #sad put: 'SAD'.	LedDict at: #confused put: 'CONFUSED'.	LedDict at: #angry put: 'ANGRY'.	LedDict at: #asleep put: 'ASLEEP'.	LedDict at: #surprised put: 'SURPRISED'.	LedDict at: #silly put: 'SILLY'.	LedDict at: #fabulous put: 'FABULOUS'.	LedDict at: #meh put: 'MEH'.	LedDict at: #yes put: 'YES'.	LedDict at: #no put: 'NO'.	LedDict at: #clock12 put: 'CLOCK12'.	LedDict at: #clock11 put: 'CLOCK11'.	LedDict at: #clock10 put: 'CLOCK10'.	LedDict at: #clock9 put: 'CLOCK9'.	LedDict at: #clock8 put: 'CLOCK8'.	LedDict at: #clock7 put: 'CLOCK7'.	LedDict at: #clock6 put: 'CLOCK6'.	LedDict at: #clock5 put: 'CLOCK5'.	LedDict at: #clock4 put: 'CLOCK4'.	LedDict at: #clock3 put: 'CLOCK3'.	LedDict at: #clock2 put: 'CLOCK2'.	LedDict at: #clock1 put: 'CLOCK1'.	LedDict at: #arrowN put: 'ARROW_N'.	LedDict at: #arrowNE put: 'ARROW_NE'.	LedDict at: #arrowE put: 'ARROW_E'.	LedDict at: #arrowSE put: 'ARROW_SE'.	LedDict at: #arrowS put: 'ARROW_S'.	LedDict at: #arrowSW put: 'ARROW_SW'.	LedDict at: #arrowW put: 'ARROW_W'.	LedDict at: #arrowNW put: 'ARROW_NW'.	LedDict at: #triangle put: 'TRIANGLE'.	LedDict at: #triangleLeft put: 'TRIANGLE_LEFT'.	LedDict at: #chessboard put: 'CHESSBOARD'.	LedDict at: #diamond put: 'DIAMOND'.	LedDict at: #diamondSmall put: 'DIAMOND_SMALL'.	LedDict at: #square put: 'SQUARE'.	LedDict at: #squareSmall put: 'SQUARE_SMALL'.	LedDict at: #rabbit put: 'RABBIT'.	LedDict at: #cow put: 'COW'.	LedDict at: #musicCrotchet put: 'MUSIC_CROTCHET'.	LedDict at: #musicQuaver put: 'MUSIC_QUAVER'.	LedDict at: #musicQuavers put: 'MUSIC_QUAVERS'.	LedDict at: #pitchfork put: 'PITCHFORK'.	LedDict at: #xmas put: 'XMAS'.	LedDict at: #pacman put: 'PACMAN'.	LedDict at: #target put: 'TARGET'.	LedDict at: #tshirt put: 'TSHIRT'.	LedDict at: #rollerskate put: 'ROLLERSKATE'.	LedDict at: #duck put: 'DUCK'.	LedDict at: #house put: 'HOUSE'.	LedDict at: #tortoise put: 'TORTOISE'.	LedDict at: #butterfly put: 'BUTTERFLY'.	LedDict at: #stickfigure put: 'STICKFIGURE'.	LedDict at: #ghost put: 'GHOST'.	LedDict at: #sword put: 'SWORD'.	LedDict at: #giraffe put: 'GIRAFFE'.	LedDict at: #skull put: 'SKULL'.	LedDict at: #umbrella put: 'UMBRELLA'.	LedDict at: #snake put: 'SNAKE'! !!MicrobitCode class methodsFor: 'initialization' stamp: 'EiichiroIto 6/27/2018 19:00'!initializeMusicDict	MusicDict := Dictionary new.	MusicDict at: #dadadadum put: 'music.DADADADUM'.	MusicDict at: #entertainer put: 'music.ENTERTAINER'.	MusicDict at: #prelude put: 'music.PRELUDE'.	MusicDict at: #ode put: 'music.ODE'.	MusicDict at: #nyan put: 'music.NYAN'.	MusicDict at: #ringtone put: 'music.RINGTONE'.	MusicDict at: #funk put: 'music.FUNK'.	MusicDict at: #blues put: 'music.BLUES'.	MusicDict at: #birthday put: 'music.BIRTHDAY'.	MusicDict at: #wedding put: 'music.WEDDING'.	MusicDict at: #funeral put: 'music.FUNERAL'.	MusicDict at: #punchline put: 'music.PUNCHLINE'.	MusicDict at: #python put: 'music.PYTHON'.	MusicDict at: #baddy put: 'music.BADDY'.	MusicDict at: #chase put: 'music.CHASE'.	MusicDict at: #baDing put: 'music.BA_DING'.	MusicDict at: #wawawawaa put: 'music.WAWAWAWAA'.	MusicDict at: #jumpUp put: 'music.JUMP_UP'.	MusicDict at: #jumpDown put: 'music.JUMP_DOWN'.	MusicDict at: #powerUp put: 'music.POWER_UP'.	MusicDict at: #powerDown put: 'music.POWER_DOWN'! !!MicrobitCode class methodsFor: 'initialization' stamp: 'EiichiroIto 6/26/2018 10:18'!initializeSensorDict	SensorDict := Dictionary new.	SensorDict at: #accelX put: 'microbit.accelerometer.get_x()'.	SensorDict at: #accelY put: 'microbit.accelerometer.get_y()'.	SensorDict at: #accelZ put: 'microbit.accelerometer.get_z()'.	SensorDict at: #compassX put: 'microbit.compass.get_x()'.	SensorDict at: #compassY put: 'microbit.compass.get_y()'.	SensorDict at: #compassZ put: 'microbit.compass.get_z()'! !!MicrobitCode class methodsFor: 'initialization' stamp: 'EiichiroIto 6/27/2018 19:00'!readFirmware	"MicrobitCode readFirmware."	| str lines main rest out |	str := (FileStream fileNamed: 'MicroPython/firmware.hex') contentsOfEntireFile.	lines := str lines.	out := WriteStream on: ''.	1 to: lines size - 2 do: 		[:each | 		out nextPutAll: (lines at: each).		out nextPut: Character lf].	main := out contents.	out := WriteStream on: ''.	lines size - 1 to: lines size do: 		[:each | 		out nextPutAll: (lines at: each).		out nextPut: Character lf].	rest := out contents.	Firmware := Array with: main with: rest! !Object subclass: #ScratchCodeGenerator	instanceVariableNames: 'hats target '	classVariableNames: 'OperatorDict '	poolDictionaries: ''	category: 'Microwitch-Translator'!!ScratchCodeGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 6/18/2018 20:09'!argString: anArgMorph 	^ target argString: anArgMorph.! !!ScratchCodeGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 6/18/2018 20:10'!booleanArgString: anArgMorph 	^ target falseString.! !!ScratchCodeGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 6/18/2018 20:12'!expressionArgWithMenuString: t1 	^ target expressionArgWithMenuString: t1! !!ScratchCodeGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 6/18/2018 20:13'!reporterArgString: aReporterMorph 	| selector |	selector := aReporterMorph selector copyWithout: $:.	selector := (selector, ':') asSymbol.	^ target perform: selector with: aReporterMorph.! !!ScratchCodeGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 6/18/2018 20:36'!valueString: aMorph	^ aMorph argString: self! !!ScratchCodeGenerator methodsFor: 'arg generator' stamp: 'EiichiroIto 6/18/2018 20:13'!variableArgString: aVariableMorph	^ target variableArgString: aVariableMorph variable.! !!ScratchCodeGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 6/15/2018 07:09'!emitBlock: aMorph indent: indent	self emitBlockCode: aMorph! !!ScratchCodeGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!emitBlockCode: aMorph 	| selector |	selector := aMorph selector copyWithout: $:.	selector := (selector, ':') asSymbol.	target perform: selector with: aMorph.	target generateLineFeed.! !!ScratchCodeGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!emitCBlock: aMorph indent: indent 	self emitBlockCode: aMorph.	aMorph nestedBlock ifNil: [self emitPassIndent: indent + 1]		ifNotNil: [self emitCode: aMorph nestedBlock indent: indent + 1].! !!ScratchCodeGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!emitCode	hats do: 		[:each | 		self emitCodeHat: each.		target generateLineFeed]! !!ScratchCodeGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!emitCode: aMorph indent: indent 	self emitIndent: indent.	aMorph emitCode: self indent: indent.	aMorph nextBlock		ifNotNil: [self				emitCode: aMorph nextBlock				indent: indent]! !!ScratchCodeGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!emitCodeHat: aHatBlock	self emitCode: aHatBlock indent: 0.! !!ScratchCodeGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 6/15/2018 07:10'!emitHatBlock: aMorph indent: indent	self! !!ScratchCodeGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!emitIfElseBlock: aMorph indent: indent 	self emitBlockCode: aMorph.	aMorph trueBlock ifNil: [self emitPassIndent: indent + 1]		ifNotNil: [self emitCode: aMorph trueBlock indent: indent + 1].	self emitIndent: indent.	target generateElse.	aMorph falseBlock ifNil: [self emitPassIndent: indent + 1]		ifNotNil: [self emitCode: aMorph falseBlock indent: indent + 1]! !!ScratchCodeGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!emitIndent: anInteger	target generateIndent: anInteger! !!ScratchCodeGenerator methodsFor: 'code generator' stamp: 'EiichiroIto 6/27/2018 19:00'!emitPassIndent: indent	self emitIndent: indent.	target generatePass.! !!ScratchCodeGenerator methodsFor: 'private' stamp: 'EiichiroIto 6/15/2018 10:55'!setHats: aCollection target: anObject	hats := aCollection.	target := anObject.! !!ScratchCodeGenerator methodsFor: 'accessing' stamp: 'EiichiroIto 6/27/2018 19:00'!codeString	| stream |	stream := ReadWriteStream on: (String new: 10000).	target generator: self stream: stream.	self emitCode.	^ stream contents! !!ScratchCodeGenerator methodsFor: 'accessing' stamp: 'EiichiroIto 6/14/2018 21:53'!hats	^ hats! !!ScratchCodeGenerator methodsFor: 'accessing' stamp: 'EiichiroIto 6/19/2018 08:01'!headerStringOf: aWorkpane	| stream |	stream := ReadWriteStream on: (String new: 1000).	target stream: stream.	target generateHeaderOf: aWorkpane.	^ stream contents! !!ScratchCodeGenerator methodsFor: 'accessing' stamp: 'EiichiroIto 6/15/2018 10:52'!target	^ target! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ScratchCodeGenerator class	instanceVariableNames: ''!!ScratchCodeGenerator class methodsFor: 'instance creation' stamp: 'EiichiroIto 6/15/2018 10:57'!hats: aCollection target: anObject 	^ self basicNew setHats: aCollection target: anObject;	 yourself! !!ScratchCodeGenerator class methodsFor: 'instance creation' stamp: 'EiichiroIto 6/15/2018 10:57'!new	self shouldNotImplement! !!ScratchCodeGenerator class methodsFor: 'accessing' stamp: 'EiichiroIto 6/16/2018 18:49'!operatorAt: aSymbol ifAbsent: aBlock	self assureExistsOperatorDict.	^ OperatorDict at: aSymbol ifAbsent: aBlock! !!ScratchCodeGenerator class methodsFor: 'private' stamp: 'EiichiroIto 6/27/2018 19:00'!assureExistsOperatorDict	"OperatorDict := nil."	OperatorDict ifNotNil: [^ OperatorDict].	OperatorDict := Dictionary new.	OperatorDict at: #+ put: 'plus'.	OperatorDict at: #- put: 'minus'.	OperatorDict at: #* put: 'mul'.	OperatorDict at: #/ put: 'div'.	OperatorDict at: #< put: 'less'.	OperatorDict at: #= put: 'equal'.	OperatorDict at: #> put: 'more'.! !MicrobitCode initialize!